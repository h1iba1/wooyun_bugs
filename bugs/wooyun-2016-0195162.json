{"id": 88595, "wybug_id": "wooyun-2016-0195162", "wybug_title": "dzzoffice任意文件包含下载(需要登录）                                      ", "wybug_corp": "dzzoffice", "wybug_author": "路人甲", "wybug_date": "2016-04-12 13:13", "wybug_open_date": "2016-07-11 17:50", "wybug_type": "任意文件遍历/下载", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["任意文件读取利用", "任意文件读取", "文件操作参数未加过滤"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2016-04-12：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2016-04-12：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2016-04-15：\t细节向第三方安全合作伙伴开放（绿盟科技、唐朝安全巡航、无声信息）\t\t\t\t\t\t\t\t\t2016-06-06：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2016-06-16：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2016-06-26：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2016-07-11：\t细节向公众公开  简要描述： rt... 详细说明：  任意文件包含漏洞问题文件在dzz/system/save.php之中\n}elseif($_GET['do']=='move'){\n当是move方法的时候从115行开始看\nif($sourcetype=='icoid'){//是ico时                $data=array();                $totalsize=0;                $data['gid']=$gid;                $data['iscopy']=$iscopy;                $icos=$folderids=array();                //分4种情况：a：本地到api；b：api到api；c：api到本地；d：本地到本地；                foreach($icoids as $icoid){                        //在目标位置创建                        $opath=rawurldecode($icoid);                        $path=rawurldecode(str_replace(array('_dock_','icosContainer_folder_','icosContainer_body_'),'',$container));                         $return=IO::CopyTo($opath,$path,$iscopy); //调用了IO类的CopyTo方法                         if(!$iscopy && !$return['moved']){                                 $return = IO::DeleteByData($return);                         }                        if($return['success']===true){                                $data['icoarr'][]=$return['newdata'];                                if(!$tbz){                                        addtoconfig($return['newdata'],$ticoid);                                }                                if($return['newdata']['type']=='folder') $data['folderarr'][]=IO::getFolderByIcosdata($return['newdata']);                                $data['successicos'][$return['icoid']]=$return['newdata']['icoid'];                        }else{                                $data['error'][]=$return['name'].':'.$return['success'];                        }                }\n 那么我们继续到CopyTo方法中看一下\nfunction CopyTo($opath,$path,$iscopy=0){                if($io=self::initIO($opath)) return $io->CopyTo($opath,$path,$iscopy);                else return false;        }\n 这里$io是io_dzz调用了io_dzz的CopyTo方法\ndefault:                                                $re=IO::multiUpload($icoid,$path,$data['name']);                                                if($re['error']) $data['success']=$re['error'];                                                else{                                                        $data['newdata']=$re;                                                        $data['success']=true;                                                }                                                break;                                }\n关键的代码段在这里，直接UPload到web应用的目录中来\npublic function multiUpload($opath,$path,$filename,$attach=array(),$ondup=\"newcopy\"){\n看到上传文件这里\nif($size<$partsize){                        //获取文件内容                        $fileContent='';                                          if(!$handle=fopen($filepath, 'rb')){                                return array('error'=>'打开文件错误');                        }                        while (!feof($handle)) {                          $fileContent .= fread($handle, 8192);                        }                        fclose($handle);                                          return self::upload($fileContent,$path,$filename);\n直接调用了自己的上传方法。这个upload方法会将文件上传的最终目录写在返回包中我自己在本地测试了一下\n\n\n\n\n\n百度了一下，发现存在好多的dzzoffice用户呢\n\n随便找了一个测试一下\n\n\n\n   漏洞证明：  任意文件包含漏洞问题文件在dzz/system/save.php之中\n}elseif($_GET['do']=='move'){\n当是move方法的时候从115行开始看\nif($sourcetype=='icoid'){//是ico时                $data=array();                $totalsize=0;                $data['gid']=$gid;                $data['iscopy']=$iscopy;                $icos=$folderids=array();                //分4种情况：a：本地到api；b：api到api；c：api到本地；d：本地到本地；                foreach($icoids as $icoid){                        //在目标位置创建                        $opath=rawurldecode($icoid);                        $path=rawurldecode(str_replace(array('_dock_','icosContainer_folder_','icosContainer_body_'),'',$container));                         $return=IO::CopyTo($opath,$path,$iscopy); //调用了IO类的CopyTo方法                         if(!$iscopy && !$return['moved']){                                 $return = IO::DeleteByData($return);                         }                        if($return['success']===true){                                $data['icoarr'][]=$return['newdata'];                                if(!$tbz){                                        addtoconfig($return['newdata'],$ticoid);                                }                                if($return['newdata']['type']=='folder') $data['folderarr'][]=IO::getFolderByIcosdata($return['newdata']);                                $data['successicos'][$return['icoid']]=$return['newdata']['icoid'];                        }else{                                $data['error'][]=$return['name'].':'.$return['success'];                        }                }\n 那么我们继续到CopyTo方法中看一下\nfunction CopyTo($opath,$path,$iscopy=0){                if($io=self::initIO($opath)) return $io->CopyTo($opath,$path,$iscopy);                else return false;        }\n 这里$io是io_dzz调用了io_dzz的CopyTo方法\ndefault:                                                $re=IO::multiUpload($icoid,$path,$data['name']);                                                if($re['error']) $data['success']=$re['error'];                                                else{                                                        $data['newdata']=$re;                                                        $data['success']=true;                                                }                                                break;                                }\n关键的代码段在这里，直接UPload到web应用的目录中来\npublic function multiUpload($opath,$path,$filename,$attach=array(),$ondup=\"newcopy\"){\n看到上传文件这里\nif($size<$partsize){                        //获取文件内容                        $fileContent='';                                          if(!$handle=fopen($filepath, 'rb')){                                return array('error'=>'打开文件错误');                        }                        while (!feof($handle)) {                          $fileContent .= fread($handle, 8192);                        }                        fclose($handle);                                          return self::upload($fileContent,$path,$filename);\n直接调用了自己的上传方法。这个upload方法会将文件上传的最终目录写在返回包中我自己在本地测试了一下\n\n\n\n\n\n百度了一下，发现存在好多的dzzoffice用户呢\n\n随便找了一个测试一下\n\n\n\n   修复方案：  对文件的上传做好限制就行了   版权声明：转载请注明来源 路人甲@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：高 漏洞Rank：20  确认时间：2016-04-12 17:42 厂商回复： 感谢你的反馈，通过上面一个任意包含文件的反馈，我们已经意识到这个问题，再修补上个问题时同时修复了这个问题。非常感谢你，如有更多交流欢迎邮件到我的邮箱 最新状态： 暂无  ", "replys": "漏洞评价：\n评价\n     2016-04-12 17:53 |    \t\thear7v \t\t\t( 普通白帽子  |\t\t\t        Rank:175 漏洞数:26        | 求组织收留啊)\t\t \n  好吧，敢问大神哪队    \n  \n\n\n", "wybug_level_fromcorp": "高", "wybug_rank_fromcorp": 20, "Ranks": null}