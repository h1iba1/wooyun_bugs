{"id": 35830, "wybug_id": "wooyun-2015-0103092", "wybug_title": "KingCms最新版目录遍历及任意文件读取漏洞（无需截断）", "wybug_corp": "KingCms", "wybug_author": "路人甲", "wybug_date": "2015-03-24 14:40", "wybug_open_date": "2015-05-08 14:42", "wybug_type": "敏感信息泄露", "wybug_level": "高", "wybug_rank_0": "10", "wybug_status": "未联系到厂商或者厂商积极忽略", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["应用敏感信息泄漏"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2015-03-24：\t积极联系厂商并且等待厂商认领中，细节不对外公开\t\t\t\t\t\t\t\t\t2015-05-08：\t厂商已经主动忽略漏洞，细节向公众公开  简要描述： KingCms最新版目录遍历及任意文件读取漏洞（无需截断） 详细说明：  朋友的公司想购买kingcms的授权，让我帮忙看下。发现kingcms很长一段时间没更新了，憋了一段时间放出了最新版的k9(2014-12-13更新)，官网下下来学习一下。在wooyun上看到了几个漏洞，如： WooYun: kingcms最新版sql注入漏洞 问题出在这里：/api/conn.php先首需要说明的是，这里的目录遍历与文件读取并不是因为服务器配置不当等引起的，而是该cms的某些函数没过过滤+使用不当引起的。0x00：先来看看如何目录遍历的。\n无关代码$get=$_GET;if(empty($get['jsoncallback'])) exit('非法提交!');$jsoncallback=$_GET['jsoncallback'];if(empty($_GET['USERID'])) exit($jsoncallback.'('.json_encode(array('error'=>\"用户ID不能为空，请求失败!\")).')');$str=new str;$db=new db;$file=new file;if(empty($get['SIGN'])) exit($jsoncallback.'('.json_encode(array('error'=>'丢失密文，禁止解析!')).')');//验证权限$sign=$get['SIGN'];unset($get['SIGN'],$get['_'],$get['jsoncallback']);$arr=array();foreach($get as $key => $val){\t$arr[$key]=$key.'='.urlencode($val);}ksort($arr);$param=implode('&',$arr);$sign1=md5($param.kc_config('system.salt'));if($sign!=$sign1) exit($jsoncallback.'('.json_encode(array('error'=>'审核失败,数据不一致!')).')');$arr=array();$get=array_map('base64_decode',$get);foreach($get as $key=>$val){\tif(substr($key,0,8)=='data_one'){\t\t$arr[$key]=$db->get_one($val);\t}elseif(substr($key,0,4)=='data'){\t\t$arr[$key]=$db->get($val);\t}elseif(substr($key,0,5)=='count'){\t\t$res=$db->get($val);\t\t$arr[$key]=empty($res[0]['c']) ? 0 : $res[0]['c'];\t}elseif(substr($key,0,5)=='newid'){\t\tlist($table,$id)=explode('|',$val,2);\t\t$arr[$key]=$db->newid($table,'',$id);\t}elseif(substr($key,0,6)=='getdir'){\t\tlist($path,$filetype)=explode('|',$val,2);\t\tif(empty($filetype)) $filetype='*';\t\t$arr[$key]=$file->getDir($path,$filetype);\t}elseif(substr($key,0,7)=='getfile'){\t\t$arr[$key]=$file->get($val);\t\t\t}elseif(substr($key,0,6)=='config'){\t\t$arr[$key]=kc_config($val);\t}elseif(substr($key,0,6)=='isfile'){\t\t$arr[$key]=is_file(ROOT.$val)?1:0;\t}}//判断url值，如果有这个值就有分页,count,rn和pid不能为空if(!empty($get['url'])){\t$url=$get['url'];\t$rows=$arr['count'];\t$pid=$get['pid'];\t$rn=$get['rn'];\t$arr['pagelist']=$str->pagelist($url, $rows, $pid, $rn,'<em>[count]</em>[standard][next]');}\n先来看看怎么绕过上面代码中的权限验证，也即要使得$sign1与$sign相等，其中$sing是用户输入的，$sign1的计算方法如下：\n$arr=array();foreach($get as $key => $val){\t$arr[$key]=$key.'='.urlencode($val);}ksort($arr);$param=implode('&',$arr);$sign1=md5($param.kc_config('system.salt'));\n计算过程中所用到的参数只有kc_config('system.salt')不是用户输入的，但是在kingcms中，这个参数全都是空的，也就是说$sing1完全由用户的输入参数按上述算法计算得来，因此，这里可以轻松绕过。然后执行到这句$arr[$key]=$file->getDir($path,$filetype);跟进\nfunction getDir($path='',$type='*',$ignore=array('.','..','.svn')){\tif (!is_dir(ROOT.$path)) {\t\treturn array();\t}\t$dirs = $files = array();\t$handle=opendir(ROOT.$path);\tif($handle){\t\twhile (false !== ($file=@readdir($handle))){\t\t\t$file=$this->encode($file);\t\t\tif(!in_array($file,$ignore)){\t\t\t\tif(is_dir(ROOT.$path.$file)){//如果是dir\t\t\t\t\tif($type=='*'||$type=='dir')\t\t\t\t\t\t$dirs[$path.$file]=$file;\t\t\t\t}else{//文件\t\t\t\t\tif($type=='*'||$type=='file'||preg_match(\"/^.+\\.({$type})$/i\",$file))\t\t\t\t\t\t$files[$path.$file]=$file;\t\t\t\t}\t\t\t}\t\t}\t\tclosedir($handle);\t\t//sort($files);\t\t//sort($dirs);\t\t$union=array_merge($dirs,$files);\t\treturn $union;\t}else{\t\tkc_tip('找不到指定的目录<br/>'.$path);\t}}\n直接把目录列出来了。路径是从根文件开始的，这里输入路径时，要base64 encode一下。成功列目录，如图\n\n0x01：再来看看如何实现任意文件读取的。代码与上面第一段相同，这里就不贴出来了。看到这句$arr[$key]=$file->get($val);跟进\npublic function get($filename){\t$s='';\t$filename=$this->encode($filename,1);\tif(empty($GLOBALS['file_get_contents_array']))\t\t$GLOBALS['file_get_contents_array']=array();\tif(is_file(ROOT.$filename)){//如果存在则读取\t\t$s='';\t\t$fh = fopen(ROOT.$filename,\"r\");\t\t\twhile (!feof($fh)) {\t\t\t$s.=fgets($fh);\t\t}\t\tfclose($fh);\t}\treturn $s;}\n直接把文件读出并返回了，路径是从根文件开始的，这里输入文件名及路径时，要base64 encode一下。文件成功读取，如图\n\n   漏洞证明：  见 详细说明   修复方案：  验证   版权声明：转载请注明来源 路人甲@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 未能联系到厂商或者厂商积极拒绝  ", "replys": "漏洞评价：\n评论\n  \n\n\n", "wybug_level_fromcorp": "无影响厂商忽略", "wybug_rank_fromcorp": 0, "Ranks": null}