{"id": 45945, "wybug_id": "wooyun-2015-093347", "wybug_title": "我是如何层层突破中国联通某省营业系统后台的（成功的案例）", "wybug_corp": "中国联通", "wybug_author": "黑暗游侠", "wybug_date": "2015-01-22 17:02", "wybug_open_date": "2015-03-08 17:04", "wybug_type": "设计缺陷/逻辑错误", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "已交由第三方合作机构(cncert国家互联网应急中心)处理", "wybug_from": "http://www.wooyun.org", "wybug_tags": "", "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2015-01-22：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2015-01-27：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2015-02-06：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2015-02-16：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2015-02-26：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2015-03-08：\t细节向公众公开  简要描述： 我是如何层层突破中国联通某省营业系统后台的（成功的案例） 详细说明：  中国联通广东省的微店业务系统，涉及金融订单，1元购买6 plus， 店家数据，任意篡改等等等等具体我搜了下wooyun，发现有一部分案例，可以先看一下：\nhttp://wooyun.org/bugs/wooyun-2010-084466http://wooyun.org/bugs/wooyun-2010-084515http://wooyun.org/bugs/wooyun-2010-084519http://wooyun.org/bugs/wooyun-2010-084524\n但是这些案例都有缺陷，比如有些只给出了购买逻辑可以1元购买，但是后台是人工审核的呀，人家又不是傻子，给你1元买。也有些是SQL注入，但是只给出了数据证明，数据是有用的呀，但是你可知道前台有2层认证的呀，登陆认证然后手机验证码双重认证的呀，所以你SQL注入这是没有用的呀！！（万万没想到看多了，说话情不自禁就这样了。。。。）   漏洞证明：  1、突破登陆层先来看下后台登陆界面：\nhttp://app.weixin.gzuni.com/admin/user/login/?path=/admin/\n\n\n遗憾的是，不存在任何注入于是找突破口，看到“忘记密码”功能于是点进去，一步一步来，输入admin\n\n找回密码需要的不是邮箱，是手机，又是发验证码，下一步\n\n确认发送后并没有数据包，根据console发现是.send()方法，所以当然截获不到数据包那么线索到这里就断了，不能更换手机不能截获验证码于是抓取页面所有js文件来看看有没有其他新的线索通过排除发现这么一个JS函数：\n$(function(){    var _LoginLocal = function(){        var self = this;                self.user_id  = ko.observable(\"\");        self.password = ko.observable(\"\");        self.checkcode = ko.observable(\"\");        self.password_confirm = ko.observable(\"\");        self.loginStatusText = ko.observable(\"下一步\");        self.disableLoginBtn = ko.observable(false);        self.errMsg = ko.observable(\"登录状态:\");        self.hiteMsg = ko.observable(\"验证状态\");        self.shouldShowgoBackBtn = ko.observable(false);        self.shouldShowMessage = ko.observable(false);        self.shouldShowHiteMessage = ko.observable(false);        self.shouldShowStepOne = ko.observable(true);        self.shouldShowStepTwo = ko.observable(false);        self.shouldShowStepThree = ko.observable(false);        self.goback= function(){            self.shouldShowStepOne(true);            self.loginStatusText(\"下一步\");            self.shouldShowgoBackBtn(false);            self.shouldShowHiteMessage(false);        }        self.login = function(){           self.shouldShowMessage(false);           self.shouldShowHiteMessage(false);           self.disableLoginBtn(true);           if(self.shouldShowStepOne()){               self.loginStatusText('正在验证...');               $.post('/admin/user/login/user_verify',{                   user_id: self.user_id(),               },function(data,status){                   if(!data.result){                    self.disableLoginBtn(false);                    self.loginStatusText(\"下一步\");                    self.errMsg(data.msg);                    self.shouldShowMessage(true);                   }else{                    self.shouldShowStepOne(false);                      self.disableLoginBtn(false);                    self.loginStatusText(\"确定发送\");                    self.hiteMsg(data.msg);                    self.shouldShowHiteMessage(true);                    self.shouldShowgoBackBtn(true);                   }               },'json')           }else if(self.shouldShowgoBackBtn()){                self.loginStatusText('正在发送...');                $.post('/admin/user/login/chk_code',{                user_id: self.user_id()            },function(data,status){               if(!data.result){               }else{                    self.shouldShowStepThree(true);                      self.shouldShowgoBackBtn(false);                    self.loginStatusText('验证');                    self.disableLoginBtn(false);               }             },'json')           }else if(self.shouldShowStepThree()){               self.loginStatusText('正在验证...');               $.post('/admin/user/login/verify_chkcode',{                   user_id: self.user_id(),                   checkcode: self.checkcode()                   }, function(data, status){                   if(!data.result){                    self.errMsg(data.msg);                    self.shouldShowMessage(true);                    self.loginStatusText('验证');                    self.disableLoginBtn(false);                   }else{                     self.shouldShowStepThree(false);                       self.shouldShowStepTwo(true);                      self.loginStatusText('提交');                    self.disableLoginBtn(false);                   }                },'json')            }else if(self.shouldShowStepTwo()){               self.loginStatusText('正在提交...');               $.post('/admin/user/login/confirm_password',{                   user_id: self.user_id(),                   password: self.password(),                   password_confirm: self.password_confirm()                   }, function(data, status){                   if(!data.result){                    self.disableLoginBtn(false);                    self.loginStatusText(\"提交\");                    self.errMsg(data.msg);                    self.shouldShowMessage(true);                   }else{                     self.shouldShowStepThree(false);                       self.shouldShowStepTwo(true);                      self.loginStatusText('提交成功，正在跳转');                     window.setTimeout(window.location.href= data.redirect,800);                    }                },'json')           }        }    };    var modLoginLocal = new _LoginLocal();    ko.applyBindings(modLoginLocal, document.getElementById('divLoginLocal'));})\n脑海中闪电划过，我惊呆了这里的验证是通过true和false来是否继续下一个页面所以我们修改返回的数据包为true或者1都可以突破验证码页面来到更改密码页面但是！！这并不是最优化方案！来看最后一段：\nif(self.shouldShowStepTwo()){               self.loginStatusText('正在提交...');               $.post('/admin/user/login/confirm_password',{                   user_id: self.user_id(),                   password: self.password(),                   password_confirm: self.password_confirm()                   }, function(data, status){                   if(!data.result){                    self.disableLoginBtn(false);                    self.loginStatusText(\"提交\");                    self.errMsg(data.msg);                    self.shouldShowMessage(true);                   }else{                     self.shouldShowStepThree(false);                       self.shouldShowStepTwo(true);                      self.loginStatusText('提交成功，正在跳转');                     window.setTimeout(window.location.href= data.redirect,800);                    }\n直接构造post数据包，填好用户名、密码、再次确认密码然后直接发送就可以更改任意用户的密码。地址提交到这里：/admin/user/login/confirm_password3个参数：user_id、password、password_confirm这里我将admin账户密码修改成为了wooyunorg\n\n返回的数据包，成功，我们来登陆试试\n\n登陆成功，下面开启第二层验证！2、突破第二层手机验证：\n\n登陆后又提示验证码输入，有了上一次的经验，继续爬行js，从js找出漏洞然后看到这一段代码\nvar _LoginLocal = function(){        var self = this;                self.user_id  = ko.observable(\"\");        self.password = ko.observable(\"\");        self.checkcode = ko.observable(\"\");        self.loginStatusText = ko.observable(\"登录\");        self.disableLoginBtn = ko.observable(false);        self.errMsg = ko.observable(\"登录状态:\");        self.hiteMsg = ko.observable(\"验证状态\");        self.shouldShowMessage = ko.observable(false);        self.shouldShowHiteMessage = ko.observable(false);        self.shouldShowStepOne = ko.observable(true);        self.shouldShowStepTwo = ko.observable(false);        self.login = function(){           self.shouldShowMessage(false);           self.shouldShowHiteMessage(false);           self.disableLoginBtn(true);           if(self.shouldShowStepOne()){               self.loginStatusText('正在验证...');               $.post('/admin/user/login/check',{                   user_id: self.user_id(),                   pwd: self.password()               },function(data,status){                   if(!data.result){                    self.disableLoginBtn(false);                    self.loginStatusText(\"登录\");                    self.errMsg(data.msg);                    self.shouldShowMessage(true);                   }else{                    self.shouldShowStepTwo(true);                      self.shouldShowStepOne(false);                      self.disableLoginBtn(false);                    self.loginStatusText(\"验证\");                    self.hiteMsg(data.msg);                    self.shouldShowHiteMessage(true);                   }               },'json')           }else{            self.loginStatusText('正在登录...');            $.post('/admin/user/login/chkcode_verify',{                user_id: self.user_id(),                checkcode:self.checkcode()            },function(data,status){               if(!data.result){                   self.loginStatusText(\"验证\");                   self.disableLoginBtn(false);                   self.shouldShowMessage(true);                   self.errMsg(data.msg);               }else{                   self.loginStatusText(\"登录成功,正在跳转...\");                   window.setTimeout(2000, window.location.href = data.redirect);               }             },'json')           }        }    };\n问题出在这里：\n$.post('/admin/user/login/chkcode_verify',{                user_id: self.user_id(),                checkcode:self.checkcode()            },function(data,status){               if(!data.result){                   self.loginStatusText(\"验证\");                   self.disableLoginBtn(false);                   self.shouldShowMessage(true);                   self.errMsg(data.msg);               }else{                   self.loginStatusText(\"登录成功,正在跳转...\");                   window.setTimeout(2000, window.location.href = data.redirect);\nwindow.setTimeout(2000, window.location.href = data.redirect)这里设置了response，可以来跳转那么构造以下response试试\n\n\n\n\n\n但是结果并不尽人如意，跳转从admin转回了login，看来修改返回包还不能一步突破继续看代码：发现以下2处\n'json')\n\n// -*- coding:utf-8 -*-(function(){    var _setCookie = function(key, val, path, maxAge){\tpath = typeof path=='string'? path: '/';\tmaxAge = typeof maxAge == 'number'? maxAge: 0;\tvar cookieStr = escape(key)+'='+escape(val)+'; path='+path;\tif(maxAge){\t    cookieStr += '; max-age='+maxAge;\t}\tdocument.cookie = cookieStr;    };    var _parseCookies = function(){\tvar pt = /(\\w+)\\s*\\=\\s*([^\\=\\;]+)/gi;\tvar m = null;\tvar c = {};\tdo{\t    m = pt.exec(document.cookie);\t    if(m){\t\tc[m[1]] = m[2];\t    }\t}while(m);\treturn c;    };    var cookieUtils = {\tsetCookie: _setCookie,\tparseCookies: _parseCookies    };    if(typeof window.cookieUtils == 'undefined'){\twindow.cookieUtils = cookieUtils;    }})();\n这里设置了一个状态undefined，json提交数据那么伪造cookie是可以突破验证的由于比较费时间，还要fuzzing正则，不深入这条路那么就来最简单的，爆破验证码突破吧4位数验证码，设置payload 1000-9999爆破出这次验证码是1068，然后登陆确认成功突破前台，来到了后台\n\n有了后台，1元购买终于成了可能\n\n旗下所有微店、订单、数据全部泄露，包括新闻发布   修复方案：     版权声明：转载请注明来源 黑暗游侠@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：中 漏洞Rank：9  确认时间：2015-01-27 14:46 厂商回复： CNVD确认所述情况，已经转由CNCERT下发给广东分中心，由其后续协调网站管理单位处置。 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n     2015-03-08 17:29 |    \t\tD_in \t\t\t( 普通白帽子  |\t\t\t        Rank:413 漏洞数:62        | 到我嘴里来)\t\t \n  牛逼    \n     2015-03-08 17:34 |    \t\t明月影 \t\t\t( 路人 |\t\t\t        Rank:12 漏洞数:8        | 学姿势，学思路。)\t\t \n  来膜拜大牛了    \n     2015-03-08 21:09 |    \t\tZtz \t\t\t( 普通白帽子  |\t\t\t        Rank:152 漏洞数:40        | 自由职业)\t\t \n  思路很清晰。不过仓库出货的时候可能会看到订单价格一元吧。    \n  \n\n\n", "wybug_level_fromcorp": "中", "wybug_rank_fromcorp": 9, "Ranks": null}