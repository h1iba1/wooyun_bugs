{"id": 52, "wybug_id": "wooyun-2014-077763", "wybug_title": "SAE又允许JVM内存对象直接读写操作", "wybug_corp": "新浪", "wybug_author": "Nebula", "wybug_date": "2014-09-29 14:02", "wybug_open_date": "2014-11-13 14:04", "wybug_type": "设计缺陷/逻辑错误", "wybug_level": "高", "wybug_rank_0": "10", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["设计缺陷"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-09-29：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2014-09-29：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2014-10-09：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2014-10-19：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2014-10-29：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2014-11-13：\t细节向公众公开  简要描述： RT! 详细说明：        在上一期的沙盒bypass漏洞中, WooYun: SAE允许JVM内存对象直接读写操作 的修复是直接Ban掉了sun.misc.Unsafe这个类的实例化访问:\n\n   漏洞证明：    但是SAE沙盒的设计者在设计沙盒之初,可能只对jdk默认沙盒权限控制了解了一部分,大致结构知道点,没有深读或不完整.默认沙盒环境每层权限做得是非常细致的,比如:前例中是对敏感包访问限制,SAE没做(sun.misc.*包,当然我之前看了一下,SAE好像就限制了这个类,不知道最近改了没有?这个问题以后再说,先说这个问题).   看到java.util.concurrent.atomic.AtomicLong这个类的源代码: \n/* * %W% %E% * * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved. * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. */package java.util.concurrent.atomic;import sun.misc.Unsafe;/** * A {@code long} value that may be updated atomically.  See the * {@link java.util.concurrent.atomic} package specification for * description of the properties of atomic variables. An * {@code AtomicLong} is used in applications such as atomically * incremented sequence numbers, and cannot be used as a replacement * for a {@link java.lang.Long}. However, this class does extend * {@code Number} to allow uniform access by tools and utilities that * deal with numerically-based classes. * * @since 1.5 * @author Doug Lea */public class AtomicLong extends Number implements java.io.Serializable {    private static final long serialVersionUID = 1927816293512124184L;    // setup to use Unsafe.compareAndSwapLong for updates    private static final Unsafe unsafe = Unsafe.getUnsafe();    private static final long valueOffset;    /**     * Records whether the underlying JVM supports lockless     * CompareAndSet for longs. While the unsafe.CompareAndSetLong     * method works in either case, some constructions should be     * handled at Java level to avoid locking user-visible locks.     */    static final boolean VM_SUPPORTS_LONG_CAS = VMSupportsCS8();    /**     * Returns whether underlying JVM supports lockless CompareAndSet     * for longs. Called only once and cached in VM_SUPPORTS_LONG_CAS.     */    private static native boolean VMSupportsCS8();    static {      try {        valueOffset = unsafe.objectFieldOffset            (AtomicLong.class.getDeclaredField(\"value\"));      } catch (Exception ex) { throw new Error(ex); }    }    private volatile long value;    /**     * Creates a new AtomicLong with the given initial value.     *     * @param initialValue the initial value     */    public AtomicLong(long initialValue) {        value = initialValue;    }    /**     * Creates a new AtomicLong with initial value {@code 0}.     */    public AtomicLong() {    }    /**     * Gets the current value.     *     * @return the current value     */    public final long get() {        return value;    }    /**     * Sets to the given value.     *     * @param newValue the new value     */    public final void set(long newValue) {        value = newValue;    }    /**     * Eventually sets to the given value.     *     * @param newValue the new value     * @since 1.6     */    public final void lazySet(long newValue) {        unsafe.putOrderedLong(this, valueOffset, newValue);    }    /**     * Atomically sets to the given value and returns the old value.     *     * @param newValue the new value     * @return the previous value     */    public final long getAndSet(long newValue) {        while (true) {            long current = get();            if (compareAndSet(current, newValue))                return current;        }    }    /**     * Atomically sets the value to the given updated value     * if the current value {@code ==} the expected value.     *     * @param expect the expected value     * @param update the new value     * @return true if successful. False return indicates that     * the actual value was not equal to the expected value.     */    public final boolean compareAndSet(long expect, long update) {\treturn unsafe.compareAndSwapLong(this, valueOffset, expect, update);    }    /**     * Atomically sets the value to the given updated value     * if the current value {@code ==} the expected value.     *     * <p>May <a href=\"package-summary.html#Spurious\">fail spuriously</a>     * and does not provide ordering guarantees, so is only rarely an     * appropriate alternative to {@code compareAndSet}.     *     * @param expect the expected value     * @param update the new value     * @return true if successful.     */    public final boolean weakCompareAndSet(long expect, long update) {\treturn unsafe.compareAndSwapLong(this, valueOffset, expect, update);    }    /**     * Atomically increments by one the current value.     *     * @return the previous value     */    public final long getAndIncrement() {        while (true) {            long current = get();            long next = current + 1;            if (compareAndSet(current, next))                return current;        }    }    /**     * Atomically decrements by one the current value.     *     * @return the previous value     */    public final long getAndDecrement() {        while (true) {            long current = get();            long next = current - 1;            if (compareAndSet(current, next))                return current;        }    }    /**     * Atomically adds the given value to the current value.     *     * @param delta the value to add     * @return the previous value     */    public final long getAndAdd(long delta) {        while (true) {            long current = get();            long next = current + delta;            if (compareAndSet(current, next))                return current;        }    }    /**     * Atomically increments by one the current value.     *     * @return the updated value     */    public final long incrementAndGet() {        for (;;) {            long current = get();            long next = current + 1;            if (compareAndSet(current, next))                return next;        }    }    /**     * Atomically decrements by one the current value.     *     * @return the updated value     */    public final long decrementAndGet() {        for (;;) {            long current = get();            long next = current - 1;            if (compareAndSet(current, next))                return next;        }    }    /**     * Atomically adds the given value to the current value.     *     * @param delta the value to add     * @return the updated value     */    public final long addAndGet(long delta) {        for (;;) {            long current = get();            long next = current + delta;            if (compareAndSet(current, next))                return next;        }    }    /**     * Returns the String representation of the current value.     * @return the String representation of the current value.     */    public String toString() {        return Long.toString(get());    }    public int intValue() {\treturn (int)get();    }    public long longValue() {\treturn (long)get();    }    public float floatValue() {\treturn (float)get();    }    public double doubleValue() {\treturn (double)get();    }}\n  看到正好有个unsafe 私有属性,还是直接实例化的:\nprivate static final Unsafe unsafe = Unsafe.getUnsafe();\n   然后通过反射又可以获取实例,直接又bypass了...(利用见前例中的PoC,直接替换获取实例部分就好了) \nField field =java.util.concurrent.atomic.AtomicLong.class.getDeclaredField(\"unsafe\");\t\tfield.setAccessible(true);\t\tsun.misc.Unsafe unsafe = (sun.misc.Unsafe) field.get(null);\n测试地址:http://1.unsafe.sinaapp.com/\n\n \n默认jdk沙盒是有限制的,属性访问权限限制(前例是包访问限制),SAE这次又漏掉了...\n\n\n   修复方案：    建议SAE沙盒的设计者好好读一下jdk默认沙盒权限控制!(充点云豆吧?就测试了两次SAE,免费的云豆就快没了...)   版权声明：转载请注明来源 Nebula@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：高 漏洞Rank：10  确认时间：2014-09-29 16:11 厂商回复： 感谢关注新浪安全，我们马上通知相应开发人员处理修复。 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n     2014-09-29 14:08 |    \t\t浮萍 \t\t\t( 普通白帽子  |\t\t\t        Rank:555 漏洞数:118        | 默默潜水)\t\t \n  这个又字用的颇好    \n     2014-09-29 14:18 |    \t\tluwikes \t\t\t( 普通白帽子  |\t\t\t        Rank:512 漏洞数:77        | 潜心学习~~~)\t\t \n  pia pia pia    \n     2014-09-29 14:55 |    \t\the1renyagao \t\t\t( 普通白帽子  |\t\t\t        Rank:225 漏洞数:29        | 是金子总会发光，在还未发光之前，先打磨打...)\t\t \n  高尚大    \n     2014-10-20 10:10 |    \t\twefgod \t\t\t( 普通白帽子  |\t\t\t        Rank:1807 漏洞数:179        | 力不从心)\t\t \n  好给力。送豆了吗    \n  \n\n\n", "wybug_level_fromcorp": "高", "wybug_rank_fromcorp": 10, "Ranks": null}