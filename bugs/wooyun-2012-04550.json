{"id": 21336, "wybug_id": "wooyun-2012-04550", "wybug_title": "android系统sqlite数据库注入漏洞", "wybug_corp": "android", "wybug_author": "冷森", "wybug_date": "2012-02-15 18:44", "wybug_open_date": "2012-02-15 18:44", "wybug_type": "设计错误/逻辑缺陷", "wybug_level": "中", "wybug_rank_0": "5", "wybug_status": "未联系到厂商或者厂商积极忽略", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["安全"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2012-02-15：\t积极联系厂商并且等待厂商认领中，细节不对外公开\t\t\t\t\t\t\t\t\t2012-02-15：\t厂商已经主动忽略漏洞，细节向公众公开  简要描述： android平台使用sqlite做为数据库，对于数据库查询，如果开发者采用字符串连接方式构造SQL语句，就会产生sql注入。 详细说明：  android自身实现了一个sqlite操作类SQLiteOpenHelper，我们继承此类，然后重载onCreate,onUpgrade等方法DatabaseHelper.java如下：package com.xiaod.sqlinj; import android.content.Context;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteDatabase.CursorFactory;import android.database.sqlite.SQLiteOpenHelper; public class DatabaseHelper extends SQLiteOpenHelper {public static final String TB_NAME=\"usertable\";public static final String ID=\"_id\";public static final String USERNAME=\"username\";public static final String PASSWORD=\"password\";DatabaseHelper(Context context, String name, CursorFactory cursorFactory, int version) {super(context, name, cursorFactory, version);} @Overridepublic void onCreate(SQLiteDatabase db) {db.execSQL(\"CREATE TABLE IF NOT EXISTS \"+TB_NAME+\" (\"+ID+\" INTEGER PRIMARY KEY,\"+USERNAME+\" VARCHAR,\"+PASSWORD+\" VARCHAR )\");db.execSQL(\"INSERT INTO \"+TB_NAME+\"(\"+USERNAME+\",\"+PASSWORD+\") VALUES\"+\"('admin','admin888')\");db.execSQL(\"INSERT INTO \"+TB_NAME+\"(\"+USERNAME+\",\"+PASSWORD+\") VALUES\"+\"('root','root123')\");db.execSQL(\"INSERT INTO \"+TB_NAME+\"(\"+USERNAME+\",\"+PASSWORD+\") VALUES\"+\"('xiaod','xiaodwin')\");} @Overridepublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { } @Overridepublic void onOpen(SQLiteDatabase db) {super.onOpen(db); }} 界面上添加一个查询框，查询按钮，在textview显示查询结果SqlinjActivity.java如下：package com.xiaod.sqlinj; import android.app.Activity;import android.database.Cursor;import android.database.sqlite.SQLiteDatabase;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;import android.widget.TextView; public class SqlinjActivity extends Activity {public static final String DB_NAME = \"sqlinj.db\";public static final int VERSION = 1;private String result = \"\";private TextView m_tv;private EditText m_et;DatabaseHelper m_dbhelper;SQLiteDatabase m_db;Button m_btnselect;/** Called when the activity is first created. */@Overridepublic void onCreate(Bundle savedInstanceState) {super.onCreate(savedInstanceState);setContentView(R.layout.main); m_tv = (TextView)findViewById(R.id.tv_view);m_btnselect = (Button)findViewById(R.id.btn_select);m_et = (EditText)findViewById(R.id.et_id); m_btnselect.setOnClickListener(new OnClickListener(){ @Overridepublic void onClick(View arg0) {// TODO Auto-generated method stubString m_id = m_et.getText().toString();m_tv.setText(ShowData(m_id));} }); m_dbhelper = new DatabaseHelper(this, DB_NAME, null, VERSION);m_db = m_dbhelper.getWritableDatabase(); } private String ShowData(String m_id){result = \"\";Cursor m_cursor;String m_argv[] = {m_id};m_cursor = m_db.rawQuery(\"SELECT * FROM usertable WHERE _id = '\" + m_id +\"'\", null);m_cursor.moveToFirst();while(!m_cursor.isAfterLast()){result += \"id: \" + m_cursor.getInt(0) + \"\\n\" +\"user: \" + m_cursor.getString(1) + \"\\n\" +\"pass: \" + m_cursor.getString(2) + \"\\n\\n\";m_cursor.moveToNext();}m_cursor.close();return result;}}   漏洞证明：  在ShowData函数中，通过传递id号，来查询记录，而54行语句SELECT * FROM usertable WHERE _id= 使用字符串连接方式，构造SQL语句。我们运行程序，测试下是否能注入。运行后，提交1，返回正常\n\n提交2′ and ’1′=’1返回正常\n\n提交2′ and ’1′=’2查询不到数据\n\n输入2′ or _id <> ‘ 返回所有数据\n\n   修复方案：  sql injection防护方式和常规思路一致，使用参数化查询增加一个数组存储查询参数   版权声明：转载请注明来源 冷森@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 未能联系到厂商或者厂商积极拒绝 漏洞Rank：6 (WooYun评价)  ", "replys": "漏洞评价：\n评论\n     2012-02-15 18:59 |    \t\txsser  \t\t\t( 普通白帽子  |\t\t\t        Rank:254 漏洞数:18        | 当我又回首一切,这个世界会好吗?)\t\t \n  有点意思    \n     2012-02-15 20:50 |    \t\triusksk \t\t\t( 实习白帽子  |\t\t\t        Rank:38 漏洞数:8        )\t\t \n  自娱自乐！！！    \n     2012-02-15 22:08 |    \t\tpiaoye \t\t\t( 普通白帽子  |\t\t\t        Rank:343 漏洞数:53        | ww)\t\t \n  以为是数据库问题那。。也是注射ShowData参数值没过滤验证导致    \n     2012-02-15 22:15 |    \t\txsser  \t\t\t( 普通白帽子  |\t\t\t        Rank:254 漏洞数:18        | 当我又回首一切,这个世界会好吗?)\t\t \n  http://www.sectop.com/?p=176 非作者本人?    \n     2012-02-15 22:17 |    \t\tpiaoye \t\t\t( 普通白帽子  |\t\t\t        Rank:343 漏洞数:53        | ww)\t\t \n  @xsser 好像还真是。。去年的东西。难道这位是换账号来的？    \n     2012-02-15 22:23 |    \t\tpiaoye \t\t\t( 普通白帽子  |\t\t\t        Rank:343 漏洞数:53        | ww)\t\t \n  @xsser package name一样。。 这个东西没啥意义，自己写个注射点注射的case    \n     2012-02-16 09:22 |    \t\txiao.D \t\t\t( 路人 |\t\t\t        Rank:5 漏洞数:1        )\t\t \n  不是我发的.. -_-!    \n     2012-02-16 12:13 |    \t\tFrankie \t\t\t( 路人 |\t\t\t        Rank:10 漏洞数:1        | 你存在,我的代码里...Line 0://你)\t\t \n  ...晕了.自己写个SQL注入再发也算啊? 传说中的刷RANK?围观下.    \n     2012-02-16 12:58 |    \t\ticefish \t\t\t( 普通白帽子  |\t\t\t        Rank:104 漏洞数:8        | 欢迎大家和我用邮件进行交流~)\t\t \n  这个问题好像官方默认的api也有拼接的，但是我记得权限做得很好，基本上没有什么利用价值的    \n     2012-02-16 13:07 |    \t\txsser  \t\t\t( 普通白帽子  |\t\t\t        Rank:254 漏洞数:18        | 当我又回首一切,这个世界会好吗?)\t\t \n  @xiao.D android那个文章是你写的木    \n     2012-02-16 13:41 |    \t\txiao.D \t\t\t( 路人 |\t\t\t        Rank:5 漏洞数:1        )\t\t \n  @xsser 恩。    \n     2012-02-16 13:57 |    \t\txsser  \t\t\t( 普通白帽子  |\t\t\t        Rank:254 漏洞数:18        | 当我又回首一切,这个世界会好吗?)\t\t \n  @xiao.D 赞    \n     2012-04-13 10:38 |    \t\t一刀终情 \t\t\t( 普通白帽子  |\t\t\t        Rank:156 漏洞数:28        | ‮‮PKAV技术宅社区-安全爱好者)\t\t \n  有没人测试，啥特殊的，畸形的短信字符，可以让android出现bug呢    \n     2012-12-27 16:48 |    \t\t老林 \t\t\t( 路人 |\t\t\t        还没有发布任何漏洞        | 擅长python，android，php，请多关照！)\t\t \n  这也算bug？    \n  \n\n\n", "wybug_level_fromcorp": "未能联系到厂商或者厂商积极拒绝", "wybug_rank_fromcorp": 6, "Ranks": null}