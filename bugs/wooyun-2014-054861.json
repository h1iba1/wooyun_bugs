{"id": 57254, "wybug_id": "wooyun-2014-054861", "wybug_title": "cmseasy某处点击触发xss", "wybug_corp": "cmseasy", "wybug_author": "phith0n", "wybug_date": "2014-03-30 15:42", "wybug_open_date": "2014-06-25 15:43", "wybug_type": "xss跨站脚本攻击", "wybug_level": "中", "wybug_rank_0": "8", "wybug_status": "漏洞已经通知厂商但是厂商忽略漏洞", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["持久型", "存储型", "源码审核"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-03-30：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2014-04-04：\t厂商主动忽略漏洞，细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2014-05-29：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2014-06-08：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2014-06-18：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2014-06-25：\t细节向公众公开  简要描述： 点击触发，鸡肋一些。 详细说明：  　　cmseasy是一款轻型cms，虽然这么说，但它也有bbs功能，其中bbs发帖处就有一个富文本框。　　但最新版的cmseasy过滤函数非常厉害，形式类似于会在敏感代码里加“<x>”，但cmseasy的规则更加严格，过滤了style和expression。看下图：\n\n　　但它依旧是没有处理好伪协议的部分。因为a和href没有过滤（也不可能过滤），所以我们可以借助href=javascript:xxx来执行javascript。但我们看到，$ra1 = array('javascript'这里直接就过滤了javascript这个关键词，怎么办？　　读到这里，大家应该很快就能反应过来，当然是用字符编码。对，因为javascript是在href这个属性中的，所以我们可以用html实体替换。比如用&#114;替换r。这样：\n<a href=javasc&#114;ipt:alert(document.cookie)>click me</a>\n　　但我们再读源码：\n　　\tfor ($i = 0; $i < strlen($search); $i++) {　　　　\t\t$val = preg_replace('/(&#[xX]0{0,8}'.dechex(ord($search[$i])).';?)/i', $search[$i], $val);　　\t\t$val = preg_replace('/(&#0{0,8}'.ord($search[$i]).';?)/', $search[$i], $val);　　\t}\n　　这里似乎过滤了html实体呢。这个for循环的功能就是将html实体替换成原字符，比如我们这里的javasc&#114;ipt经过这个循环后就变成了javascript，然后就被后面的fliter过滤了。　　怎么办？　　既然它把html实体替换成了原字符，那么这样写呢：&#&#49;14;　　&#49;被替换成了1，和外面的字符又组成了新的&#114;。好，这样我们试试能不能绕过fliter：\n<a href=javasc&#&#49;14;ipt:alert(document.cookie)>click me</a>\n　　我们在cmseasy中试试。注册用户，到bbs目录下，发帖：\n\n　　点击Click me触发：\n\n　　所以，虽然这个xss fliter看似十分变态，过滤了很多很多标签和属性。但某些标签和属性是不可能过滤的。比如img、a、href、src，因为这都是一些正常到不能再正常，富文本中必须用到的标签。　　但因为有了伪协议的存在，所以这些标签也变得十分危险。   漏洞证明：  见详细说明。   修复方案：  　　我提供几个建设性的方案。　　. 放弃黑名单，使用白名单方式过滤xss。推荐使用一个强大的类库HTML Purifier：http://htmlpurifier.org/ 。这个类简单易用，最精简的过滤代码只要这几行即可：　　<?php　　require_once 'library/HTMLPurifier.includes.php';　　　　$dirty_html = <<<EOF　　<h1>Hello　　<script>alert(\"world\");</script>　　EOF;　　　　$purifier = new HTMLPurifier();　　$cleanHtml = $purifier->purify($dirty_html);　　它能够自动补全html标签，这段代码最后输出的是<h1>Hello</h1>。这里有他的一些过滤规则：http://htmlpurifier.org/live/smoketests/xssAttacks.php　　b). 使用UBB代码。类似于白名单的过滤，用户只能使用UBB代码中允许的标签和属性，不允许的直接不会显示出来。国内discuz论坛、国外的phpbb论坛，对于UBB代码已经做的很成熟了，可以借鉴。　　既有ubb编辑器：http://www.ubbeditor.com/cn/　　其还给了php、asp、c#、java语言的ubb转换html的后端代码，可以参考：http://www.ubbeditor.com/cn/download/　　　　c). 使用markdown处理富文本。效果类似于ubb代码，但处理的脚本在前端，也算是近些年比较流行的一个方式。　　但我并没有细致去研究javascript是怎么处理的markdown代码，所以对其解析的安全性，可能还有待观察。　　pagedown可参考：https://code.google.com/p/pagedown/   版权声明：转载请注明来源 phith0n@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：无影响厂商忽略 忽略时间：2014-06-25 15:43 厂商回复：  最新状态： 2014-04-04：官方并没收到漏洞通知  ", "replys": "漏洞评价：\n评论\n  \n\n\n", "wybug_level_fromcorp": "无影响厂商忽略", "wybug_rank_fromcorp": 0, "Ranks": null}