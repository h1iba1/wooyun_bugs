{"id": 54552, "wybug_id": "wooyun-2014-064037", "wybug_title": "phpdisk V7 （20140604） 绕过补丁继续上传任意文件。", "wybug_corp": "phpdisk.com", "wybug_author": "′雨。", "wybug_date": "2014-06-11 09:01", "wybug_open_date": "2014-09-09 09:02", "wybug_type": "文件上传导致任意代码执行", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": "", "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-06-11：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2014-06-11：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2014-06-14：\t细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2014-08-05：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2014-08-15：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2014-08-25：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2014-09-09：\t细节向公众公开  简要描述： 验证encrypt_key.这个会上首页吗。。 好紧张。。 详细说明：  首先说一下 官方的demo站竟然还没打补丁。我进去的时候已经看见里面有几个马儿了。。 打下补丁 清下马儿把。来看看0604出的补丁修改了哪里。在plugins/phpdisk_client/client_sub.php\nswitch ($action){\tcase 'upload_file':\t\t\t//write_file(PHPDISK_ROOT.'system/2.txt',var_export($_POST,true));\t\t//write_file(PHPDISK_ROOT.'system/3.txt',var_export($_FILES,true));\t\t$sign_md5 = md5($uid.$settings[encrypt_key]);\t\tif(!$sign and $sign_md5<>$sign){\t\t\t\t\t\techo 'Sign Error!';\t\t\texit;\t\t}\n在这里上传的时候验证了\t\n$sign_md5 = md5($uid.$settings[encrypt_key]);\t\tif(!$sign and $sign_md5<>$sign){\t\t\t\t\t\techo 'Sign Error!';\t\t\texit;\n 如果不相等则退出. $uid倒还容易搞 来看看$settings[encrypt_key]\n'encrypt_key' => 'Bw5xe2XIlwwj',\n我擦 这么复杂?再来看看是如何生成这个的。\nfunction make_key(){\t\tvar chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\t\tvar tmp = \"\";\t\tvar code = \"\";\t\tfor(var i=0;i<12;i++){\t\t\tcode += chars.charAt(Math.ceil(Math.random()*100000000)%chars.length);\t\t}\t\tdocument.getElementById('encrypt_key').value = code;\t}\n这么多字符中随机取12个。 我擦 放弃逆这个了。在plugins/phpdisk_client/client_sub.php中\n$agent = $_SERVER['HTTP_USER_AGENT'];if($agent!='phpdisk-client'){\texit('<a href=\"http://faq.phpdisk.com/search?w=p403&err=code\" target=\"_blank\">[PHPDisk Access Deny] Invalid Entry!</a>');}$u_info = trim(gpc('u_info','P',''));parse_str(pd_encode(base64_decode($u_info),'DECODE'));\nparse_str(pd_encode(base64_decode($u_info),'DECODE')); 这里调用了自定义的pd_encode 来解密 如果可以逆到key 就可以自己通过key来生成一个加密的 然后解密之后就可以变量覆盖。\nfunction pd_encode($string, $operation = 'ENCODE',$key = ''){\tglobal $settings;\t$ckey_length = 4;\t$key = md5($key ? $key : ($settings['encrypt_key'] ? $settings['encrypt_key'] : 'PHPDisk=Rc9o'));\t$keya = md5(substr($key, 0, 16));\t$keyb = md5(substr($key, 16, 16));\t$keyc = $ckey_length ? ($operation == 'DECODE' ? substr($string, 0, $ckey_length): substr(md5(microtime()), -$ckey_length)) : '';\t$cryptkey = $keya.md5($keya.$keyc);\t$key_length = strlen($cryptkey);\t$string = $operation == 'DECODE' ? base64_decode(substr($string, $ckey_length)) : sprintf('%010d',0).substr(md5($string.$keyb), 0, 16).$string;\t$string_length = strlen($string);\t$result = '';\t$arr = range(0, 255);\t$rndkey = array();\tfor($i = 0; $i <= 255; $i++) {\t\t$rndkey[$i] = ord($cryptkey[$i % $key_length]);\t}\tfor($j = $i = 0; $i < 256; $i++) {\t\t$j = ($j + $arr[$i] + $rndkey[$i]) % 256;\t\t$tmp = $arr[$i];\t\t$arr[$i] = $arr[$j];\t\t$arr[$j] = $tmp;\t}\tfor($a = $j = $i = 0; $i < $string_length; $i++) {\t\t$a = ($a + 1) % 256;\t\t$j = ($j + $arr[$a]) % 256;\t\t$tmp = $arr[$a];\t\t$arr[$a] = $arr[$j];\t\t$arr[$j] = $tmp;\t\t$result .= chr(ord($string[$i]) ^ ($arr[($arr[$a] + $arr[$j]) % 256]));\t}\tif($operation == 'DECODE') {\t\tif((substr($result, 0, 10) == 0 || substr($result, 0, 10) - time() > 0) && substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16)) {\t\t\treturn substr($result, 26);\t\t} else {\t\t\treturn '';\t\t}\t} else {\t\treturn $keyc.str_replace('=', '', base64_encode($result));\t}}\n调用了那12位的key。。 对算法不懂 放弃了。。那就找找有没有哪里调用这函数来进行加密的。如果要加密的可控的话也行。那就来找找在哪里调用了这函数来进行加密了的。在plugins/phpdisk_client/client_main.php中\nif($action && $action<>'download'){\t$agent = $_SERVER['HTTP_USER_AGENT'];\tif($agent!='phpdisk-client'){\t\texit('<a href=\"http://faq.phpdisk.com/search?w=p403&err=code\" target=\"_blank\">[PHPDisk Access Deny] Invalid Entry!</a>');\t}}// checked username and pwd...$username = trim(gpc('username','GP',''));$password = trim(gpc('password','GP',''));$username = is_utf8() ? convert_str('gbk','utf-8',$username) : $username;$password = is_utf8() ? convert_str('gbk','utf-8',$password) : $password;$rs = $db->fetch_one_array(\"select * from {$tpf}users where username='$username' and password='$password'\");if(!$rs){\t$str = '网盘登录出错：用户名或密码不正确，请重新输入';\tif(is_utf8()){\t\techo convert_str('utf-8','gbk',$str);\t}else{\t\techo $str;\t}\texit;}else{\tif($rs[is_locked]){\t\t$str = '网盘登录出错：用户名被锁定';\t\tif(is_utf8()){\t\t\techo convert_str('utf-8','gbk',$str);\t\t}else{\t\t\techo $str;\t\t}\t\texit;\n验证了user agent 可以修改一下就行了然后去注册一个号就行了。   再往下面看。\ncase 'loadset':\t\tif($settings['open_multi_server']){\t\t\t$server_host = @$db->result_first(\"select server_host from {$tpf}servers where server_id>1 order by is_default desc limit 1\");\t\t}\t\t$server_host = $server_host ? trim($server_host) : $settings[phpdisk_url];\t\t$sign = md5($uid.$settings[encrypt_key]);\t\techo 'true'.LF;\t\techo $server_host.LF;\t\techo '0'.LF;\t\techo base64_encode(pd_encode('username='.$username.'&password='.$password.'&sign='.$sign)).LF;\t\techo $settings[client_api_key];\t\texit;\t\tbreak;\n这里调用了pd_encode 不是DECODE 是ENCODE。 看看里面的。\necho base64_encode(pd_encode('username='.$username.'&password='.$password.'&sign='.$sign)).LF;$sign = md5($uid.$settings[encrypt_key]);\n。。可以看到 自己把做验证的带入到了pd_encode里面 然后输出了。。这特么的太爽了。   漏洞证明：  首先注册一个号 \n\n由于密码他这里没有md5。  所以自己把自己的密码进行md5一次后再放进去。然后得到加密字符串。MjdjNWpzd0lOYTFtQTd6R1l1alkxRlhlS2ZiYnc4azV1VFIyNHFXLzluZ1p1K2JFOVdqZlRTbVJXMXZLL0FYb21ScGlVMU5wcU1hSjZXOHYzZXk4MnpOWU1pdk1oV2Zzb0RTQk9tNHdCYWpjeHNUWG9sZUtMK0s5VzlrMUJhNzkrOXgrSVV2dTZrVitscURFZk16djJtM0lsWjV6OUZvSE9JU0lUZw==然后在client_sub.php中\n$u_info = trim(gpc('u_info','P',''));parse_str(pd_encode(base64_decode($u_info),'DECODE'));\n解密后 就注册了$sign变量。就通过了这个验证 就能继续上传任意文件了。\n\nsign错误 把刚才的加密字符串复制进去。\n\n上传成功。\n\n嗯。_________________________________________________________________________测试一下demo。\n\n成功得到加密字符串。在测试过程中发现不用这加密的也能上传成功。看看原因。\n\n原来官方竟然都忘记给自己的demo站打补丁了。出于人道我给官方把补丁弄上去把。\nswitch ($action){\tcase 'upload_file':\t\t//write_file(PHPDISK_ROOT.'system/2.txt',var_export($_POST,true));\t\t//write_file(PHPDISK_ROOT.'system/3.txt',var_export($_FILES,true));\t\t$sign_md5 = md5($uid.$settings[encrypt_key]);\t\tif(!$sign and $sign_md5<>$sign){\t\t\t\t\t\techo 'Sign Error!';\t\t\texit;\t\t}\n不过这补丁还得继续修改 因为能像上面那样绕过。   修复方案：  加强验证。   版权声明：转载请注明来源 ′雨。@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：高 漏洞Rank：15  确认时间：2014-06-11 13:04 厂商回复： 感谢反馈 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n  \n\n\n", "wybug_level_fromcorp": "高", "wybug_rank_fromcorp": 15, "Ranks": null}