{"id": 72012, "wybug_id": "wooyun-2015-0141054", "wybug_title": "广州银行android客户端应用配置可绕过自签名验证", "wybug_corp": "http://www.gzcb.com.cn/", "wybug_author": "路人甲", "wybug_date": "2015-09-14 13:29", "wybug_open_date": "2015-12-16 11:12", "wybug_type": "非授权访问/认证绕过", "wybug_level": "中", "wybug_rank_0": "7", "wybug_status": "已交由第三方合作机构(广东省信息安全测评中心)处理", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["设计缺陷", "设计不当", "安全", "手机软件安全"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2015-09-14：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2015-09-17：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2015-09-20：\t细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2015-11-11：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2015-11-21：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2015-12-01：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2015-12-16：\t细节向公众公开  简要描述： 通过绕过签名验证伪造成官方应用后可以运行获知进一步的信息如客户的重要个人信息以及核心的业务流程，可能造成进一步的危害 详细说明：  一般安全性要求高一点的android应用都要在内部进行自签名验证，防止黑客篡改apk内容后重新打包运行。我将广州银行最新的2.0.2版本的客户端进行解包之后再重新用一个keystore进行打包签名，安装后运行客户端提示\n\n由此可知广州银行客户端在应用内部有做自签名验证的，但是我要弄清楚其实现方式是什么，是否可以被破解，于是我在解包的string.xml文件中搜索提示的字符串，\n\n。为了找到该字符串资源在程序中的位置，我通过android sdk的aapt工具获取到编译完成的字符串资源对应的十六进制格式的资源id\n\n，通过在反编译后的代码里面搜索资源id可以获知判断程序的位置\n\n，通过阅读上图代码可以知道程序的逻辑就是通过判断资源id为0x7f0900bc以及0x7f0900bb对应的字符串来确认应用是否为官方签名的应用，从上图代码中还可以获知客户端如何处理取得的应用签名的字符串\n\n，\n\n。最后通过将其处理签名字符串的程序提取出来\npublic class MainActivity extends ActionBarActivity {\tprivate TextView signatureTxt;\t@Override\tprotected void onCreate(Bundle savedInstanceState) {\t\tsuper.onCreate(savedInstanceState);\t\tsetContentView(R.layout.activity_main);\t\t\t\tsignatureTxt = (TextView)findViewById(R.id.signature);\t\tString result = \"\";\t\ttry {\t\t\tString signature = this.getPackageManager().getPackageInfo(this.getPackageName(), 64).signatures[0].toCharsString();\t\t\tMessageDigest msgDigest = MessageDigest.getInstance(\"MD5\");\t\t\tbyte[] arrayOfByte;\t\t\tStringBuffer localStringBuffer;\t\t\tint i;\t\t\ttry {\t\t\t\tmsgDigest.reset();\t\t\t\tmsgDigest.update(signature.getBytes(\"UTF-8\"));\t\t\t} catch (UnsupportedEncodingException unsupportedencodingexception) {\t\t\t\tunsupportedencodingexception.printStackTrace();\t\t\t}\t\t\tarrayOfByte = msgDigest.digest();\t\t\tlocalStringBuffer = new StringBuffer();\t\t\ti = 0;\t\t\tdo {\t\t\t\tif (i >= arrayOfByte.length) {\t\t\t\t\tresult = localStringBuffer.toString();\t\t\t\t\tbreak;\t\t\t\t}\t\t\t\tif (Integer.toHexString(0xff & arrayOfByte[i]).length() == 1) {\t\t\t\t\tlocalStringBuffer.append(\"0\").append(\t\t\t\t\t\t\tInteger.toHexString(0xff & arrayOfByte[i]));\t\t\t\t} else {\t\t\t\t\tlocalStringBuffer.append(Integer\t\t\t\t\t\t\t.toHexString(0xff & arrayOfByte[i]));\t\t\t\t}\t\t\t\ti++;\t\t\t} while (true);\t\t} catch (NameNotFoundException e) {\t\t\te.printStackTrace();\t\t} catch (NoSuchAlgorithmException e) {\t\t\te.printStackTrace();\t\t}\t\tsignatureTxt.setText(result);\t\tLog.i(\"Signature\", result + \"\");\t}}\n并新建另一个工程，将刚才测试的keystore作为该工程的签名keystore进行导出apk，apk文件安装运行后即可得到一个字符串，将该字符串替换资源id为0x7f0900bc以及0x7f0900bb对应的字符串资源。重新打包签名apk，安装运行后验证通过\n\n\n\n\n\n   漏洞证明：  当我用czw12345作为密钥生成keystore，之后运行测试程序得到一串处理过的签名字符串70289abe147313f0c5a79d63c6f1c3a5，将string.xml资源文件中的defaultkey以及testkey内容替换为该签名字符串\n\n，重新签名打包apk后，安装运行通过。   修复方案：  1.建议客户端不要将验证签名的逻辑代码暴露出来，可以将验证的逻辑代码封装到native代码中2.不要将验证的签名字符串暴露在可修改配置的string.xml文件中，应该将其封装进native代码中并做一定的隐蔽处理   版权声明：转载请注明来源 路人甲@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：高 漏洞Rank：10  确认时间：2015-09-17 11:11 厂商回复： 非常感谢您的报告。报告中的问题已确认并复现.影响的数据：高攻击成本：低造成影响：高综合评级为：高，rank：10正在联系相关网站管理单位处置。 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n     2015-09-14 13:42 |    \t\t骑虎打狗 \t\t\t( 路人 |\t\t\t        Rank:5 漏洞数:4        | 认真对待每个洞..)\t\t \n  二次打包？    \n     2015-09-14 13:45 |    \t\txsser  \t\t\t( 普通白帽子  |\t\t\t        Rank:267 漏洞数:20        | 当我又回首一切,这个世界会好吗?)\t\t \n  @骑虎打狗 绕过了监测吧    \n     2015-12-16 11:26 |    \t\t骑虎打狗 \t\t\t( 路人 |\t\t\t        Rank:5 漏洞数:4        | 认真对待每个洞..)\t\t \n  就是二次打包。。。    \n  \n\n\n", "wybug_level_fromcorp": "高", "wybug_rank_fromcorp": 10, "Ranks": null}