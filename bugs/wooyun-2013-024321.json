{"id": 10491, "wybug_id": "wooyun-2013-024321", "wybug_title": "SupperRadius商业系例 加密算法破解", "wybug_corp": "亿联S-Radiuss系列产品", "wybug_author": "Lee Swagger", "wybug_date": "2013-05-23 10:29", "wybug_open_date": "2013-08-21 10:29", "wybug_type": "设计错误/逻辑缺陷", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "已交由第三方合作机构(cncert国家互联网应急中心)处理", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["商业系例", "加密破解", "破解以后可以一个账号公用多个人", "需", "拨号客户端"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2013-05-23：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2013-05-28：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2013-05-31：\t细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2013-07-22：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2013-08-01：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2013-08-11：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2013-08-21：\t细节向公众公开  简要描述： SupperRadius商业系例 加密破解 破解以后可以一个账号公用多个人 无需 拨号客户端 详细说明：  \n\n账号保留 密码提取出来.如果密码为70da4k 其中7,0,4为数字 就到数字表中查找;d,a,k 则在字母表查找对应的代码(列表中都是2位十六进制,其实在后面再加2个0 就是 真实密码,为了清楚,在表格中省略00)【1】7在密码第一位 则查找7对应的第一位5d,然后5d后加上00  (每个字符后都要加)->也就是5d00【2】字母d在字母表对应的第三位是05,->0500一一对应这样子70da4k的真实密码也就是5D00590005000E0053000A00直接复制这个当拨号连接密码就是真实密码 登录即可   漏洞证明：  \ntry            {                this.textBox2.Text = \"\";                char[,] chArray = new char[,] { { 'A', '9', '1', 'F', '7', '1' }, { 'B', '8', '0', 'E', '6', '0' }, { '8', 'B', '3', 'D', '5', '3' }, { '9', 'A', '2', 'C', '4', '2' }, { 'E', 'D', '5', 'B', '3', '5' }, { 'F', 'C', '4', 'A', '2', '4' }, { 'C', 'F', '7', '9', '1', '7' }, { 'D', 'E', '6', '8', '0', '6' }, { '2', '1', '9', '7', 'F', '9' }, { '3', '0', '8', '6', 'E', '8' } };                if ((this.textBox1.Text != null) && (this.textBox1.Text.Length <= 6))                {                    for (int i = 0; i < this.textBox1.Text.Length; i++)                    {                        int num2 = int.Parse(this.textBox1.Text.Substring(i, 1));                        object text = this.textBox2.Text;                        this.textBox2.Text = string.Concat(new object[] { text, \"5\", chArray[num2, i], \"00\" });                    }                }                else                {                    MessageBox.Show(\"请输入密码不符！\");                }            }            catch (Exception exception)            {                MessageBox.Show(exception.Message.ToString());            }\n\n\n   修复方案：  修改加密方式(防止内存读取)   版权声明：转载请注明来源 Lee Swagger@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：高 漏洞Rank：14  确认时间：2013-05-28 08:19 厂商回复：   最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n     2013-05-23 10:30 |    \t\tnone \t\t\t( 实习白帽子  |\t\t\t        Rank:40 漏洞数:5        | 十次十次啊 hack it then know more~)\t\t \n  如果是freeradius的 更劲爆    \n     2013-06-17 10:29 |    \t\txsjswt \t\t\t( 普通白帽子  |\t\t\t        Rank:156 漏洞数:49        | 我思故我猥琐，我猥琐故我强大)\t\t \n  这个就是一个带扰动的轮盘机嘛    \n     2013-06-17 12:16 |    \t\tLee Swagger \t\t\t( 路人 |\t\t\t        Rank:28 漏洞数:5        | 洗洗睡吧)\t\t \n  @xsjswt ?何解  有新的方法?    \n     2013-06-17 12:39 |    \t\txsjswt \t\t\t( 普通白帽子  |\t\t\t        Rank:156 漏洞数:49        | 我思故我猥琐，我猥琐故我强大)\t\t \n  @Lee Swagger 没有什么新方法，这个就是最原始的带扰动多表替换嘛。二战时候德国老的那个英格码都比这个复杂。    \n     2013-09-06 23:59 |    \t\tLee Swagger \t\t\t( 路人 |\t\t\t        Rank:28 漏洞数:5        | 洗洗睡吧)\t\t \n  VC 重写NET程序#include <stdio.h>#include \"windows.h\"int ClearClipboradBuffer();int AppendBufferToClipboard( char *cBuffer, int nSize );//**********************************************************************//Main Functionint main(){\t//The table of breaking the code\tchar a[10][6]={{'A','9','1','F','7','1',},\t{'B','8','0','E','6','0',},\t{'8','D','3','D','5','3',},\t{'9','A','2','C','4','2',},\t{'E','D','5','B','3','5',},\t{'F','C','4','A','2','4',},\t{'C','F','7','9','1','7',},\t{'D','E','6','8','0','6',},\t{'2','1','9','7','F','9',},\t{'3','0','8','6','E','8',}};\t int b,c,d,e,f,g;\t \t printf(\"www.wooyun.org\\n-------------------------------\\n\");\t int i;pk:printf(\"请输入你设置的六位密码,用空格分割每一位\\n\\n\");\t  scanf(\"%d%d%d%d%d%d\",&b,&c,&d,&e,&f,&g);\t  printf(\"\\n真正的密码是：:\\n*******************************\\n    5%c005%c005%c005%c005%c005%c00\\n*******************************\\n\\n\\n\",a[b][0],a[c][1],a[d][2],a[e][3],a[f][4],a[g][5]);\t char cTest[ 512 ]={ 0 };\t char cClip[ 512 ] = { 0 };\t int nRet = 0;\t //将数据写入字符cTest中\t nRet=sprintf(cTest,\"5%c005%c005%c005%c005%c005%c00\",\t\t a[b][0],a[c][1],a[d][2],a[e][3],a[f][4],a[g][5]);\tClearClipboradBuffer();\t//判断是否有写入剪切板\tif( AppendBufferToClipboard( cTest, nRet ) )\t {\t  printf( \"对不起，密码复制失败！ \\n\\n#############################################################\\n\\n\" );//\t  return 0;\t }\telse\t{\t\tprintf(\"密码已经复制到剪贴板，可以用快捷键CTRL+V粘贴。\\n\\n#############################################################\\n\\n\");//\treturn 0;\t}\tgoto pk;}//*************************************************************************************//清空剪切板int ClearClipboradBuffer(){ HGLOBAL hClipboard = NULL; if( OpenClipboard( NULL ) ) {   hClipboard = GetClipboardData( CF_TEXT );  GlobalFree( hClipboard );  EmptyClipboard();  CloseClipboard(); return 0; } else {  return -1; }}//将字符串放到剪切板int AppendBufferToClipboard( char *cBuffer, int nSize ){ HGLOBAL hClipboard = NULL; char *pClipBuf = NULL; if( OpenClipboard( NULL ) ) {   hClipboard = GlobalAlloc( GMEM_DDESHARE, nSize+1 );  pClipBuf = (char*)GlobalLock(hClipboard);  memset( pClipBuf, 0, nSize+1 );  memcpy( pClipBuf, cBuffer, nSize );  GlobalUnlock( hClipboard );  SetClipboardData( CF_TEXT, hClipboard );  CloseClipboard(); } else {  return -1; } return 0;}    \n  \n\n\n", "wybug_level_fromcorp": "高", "wybug_rank_fromcorp": 14, "Ranks": null}