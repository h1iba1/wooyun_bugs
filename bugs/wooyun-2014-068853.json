{"id": 680, "wybug_id": "wooyun-2014-068853", "wybug_title": "Phpyun注入漏洞二", "wybug_corp": "php云人才系统", "wybug_author": "′雨。", "wybug_date": "2014-07-17 15:56", "wybug_open_date": "2014-10-15 16:00", "wybug_type": "SQL注射漏洞", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": "", "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-07-17：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2014-07-17：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2014-07-20：\t细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2014-09-10：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2014-09-20：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2014-09-30：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2014-10-15：\t细节向公众公开  简要描述： 刚在官网下的。前台注入。 可以直接出管理员的帐号和密码。无视360webscan。 详细说明：  本来以为挖不到了 无聊翻翻文件看看。 翻到了上次那个注入的文件。 model/register.class.php\nfunction regsave_action(){\t\t$_POST=$this->post_trim($_POST);\t\t$_POST['username']=iconv(\"utf-8\",\"gbk\",$_POST['username']);\t\t$_POST['unit_name']=iconv(\"utf-8\",\"gbk\",$_POST['unit_name']);\n省略点\nip = $this->obj->fun_ip_get();\t\t\t$data['username']=$_POST['username'];\t\t\t$data['password']=$pass;\t\t\t$data['moblie']=$_POST['moblie'];\t\t\t$data['email']=$_POST['email'];\t\t\t$data['usertype']=$_POST['usertype'];\t\t\t$data['status']=$satus;\t\t\t$data['salt']=$salt;\t\t\t$data['reg_date']=time();\t\t\t$data['reg_ip']=$ip;\t\t\t$data['qqid']=$_SESSION['qq']['openid'];\t\t\t$data['sinaid']=$_SESSION['sinaid'];\t\t\t\t\t$userid=$this->obj->insert_into(\"member\",$data);\n主要看到这里ip = $this->obj->fun_ip_get(); 一开始就是想的会不会有很古老的xff洞? 后面想了想不太可能把 phpyun这程序目测还算不错的。可是还是看了看这函数。 然后看到两个文件里面都声明了这函数1 在　/include/public.function.php　中\nfunction fun_ip_get() {\tif (getenv(\"HTTP_CLIENT_IP\") && strcasecmp(getenv(\"HTTP_CLIENT_IP\"), \"unknown\")) {\t\t$ip = getenv(\"HTTP_CLIENT_IP\");\t} else\t\tif (getenv(\"HTTP_X_FORWARDED_FOR\") && strcasecmp(getenv(\"HTTP_X_FORWARDED_FOR\"), \"unknown\")) {\t\t\t$ip = getenv(\"HTTP_X_FORWARDED_FOR\");\t\t} else\t\t\tif (getenv(\"REMOTE_ADDR\") && strcasecmp(getenv(\"REMOTE_ADDR\"), \"unknown\")) {\t\t\t\t$ip = getenv(\"REMOTE_ADDR\");\t\t\t} else\t\t\t\tif (isset ($_SERVER['REMOTE_ADDR']) && $_SERVER['REMOTE_ADDR'] && strcasecmp($_SERVER['REMOTE_ADDR'], \"unknown\")) {\t\t\t\t\t$ip = $_SERVER['REMOTE_ADDR'];\t\t\t\t} else {\t\t\t\t\t$ip = \"unknown\";\t\t\t\t}\t $preg=\"/\\A((([0-9]?[0-9])|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\.){3}(([0-9]?[0-9])|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\Z/\";\t if(preg_match($preg,$ip)){\t \t\treturn ($ip);\t }\n这个文件里面的这函数验证了。２　/model/class/action.class.php\nfunction fun_ip_get() {\t\tif (getenv(\"HTTP_CLIENT_IP\") && strcasecmp(getenv(\"HTTP_CLIENT_IP\"), \"unknown\")) {\t\t\t$ip = getenv(\"HTTP_CLIENT_IP\");\t\t} else\t\t\tif (getenv(\"HTTP_X_FORWARDED_FOR\") && strcasecmp(getenv(\"HTTP_X_FORWARDED_FOR\"), \"unknown\")) {\t\t\t\t$ip = getenv(\"HTTP_X_FORWARDED_FOR\");\t\t\t} else\t\t\t\tif (getenv(\"REMOTE_ADDR\") && strcasecmp(getenv(\"REMOTE_ADDR\"), \"unknown\")) {\t\t\t\t\t$ip = getenv(\"REMOTE_ADDR\");\t\t\t\t} else\t\t\t\t\tif (isset ($_SERVER['REMOTE_ADDR']) && $_SERVER['REMOTE_ADDR'] && strcasecmp($_SERVER['REMOTE_ADDR'], \"unknown\")) {\t\t\t\t\t\t$ip = $_SERVER['REMOTE_ADDR'];\t\t\t\t\t} else {\t\t\t\t\t\t$ip = \"unknown\";\t\t\t\t\t}\t\treturn ($ip);\n而这/model/class/action.class.php文件里面的却没验证ip是否合法。。而刚才调用的函数 就是调用的这文件里面的。。。。。碉堡了。。继续在model/register.class.php里面看。\n$ip = $this->obj->fun_ip_get();\t\t\t$data['username']=$_POST['username'];\t\t\t$data['password']=$pass;\t\t\t$data['moblie']=$_POST['moblie'];\t\t\t$data['email']=$_POST['email'];\t\t\t$data['usertype']=$_POST['usertype'];\t\t\t$data['status']=$satus;\t\t\t$data['salt']=$salt;\t\t\t$data['reg_date']=time();\t\t\t$data['reg_ip']=$ip;\t\t\t$data['qqid']=$_SESSION['qq']['openid'];\t\t\t$data['sinaid']=$_SESSION['sinaid'];\t\t\t\t\t$userid=$this->obj->insert_into(\"member\",$data);\n然后就带入到了insert当中\nfunction insert_into($table,$data=array()){\t\t$value=\"\";\t\t$FieldSQL = \"SELECT `COLUMN_NAME` FROM INFORMATION_SCHEMA.Columns WHERE TABLE_NAME = '\".$this->def.$table.\"'\";\t\t$Fquery = $this->db->query($FieldSQL);\t\twhile($Frow=$this->db->fetch_array($Fquery)){\t\t\t$Freturn[]=$Frow;\t\t}\t\tif(is_array($Freturn))\t\t{\t\t\tforeach($Freturn as $Fkey=>$Fval)\t\t\t{\t\t\t\t$fields[] =  $Fval['COLUMN_NAME'];\t\t\t}\t\t\tif(is_array($data)){\t\t\t\tforeach($data as $key=>$v){\t\t\t\t\tif(in_array($key,$fields))\t\t\t\t\t{\t\t\t\t\t\t$v = $this->FilterStr($v);\t\t\t\t\t\t$value[]=\"`\".$key.\"`='\".mysql_real_escape_string($v).\"'\";\n可是在这里 mysql_real_escape_string  转义了 没办法用。在找找其他哪个文件调用了这函数。在model/login.class.php中\nfunction loginsave_action()\t{ \t\t$username=iconv(\"utf-8\",\"gbk\",$_POST['username']);\t\tif($_COOKIE['uid']!=\"\"&&$_COOKIE['username']!=\"\")\t\t{\t\t\t$this->ajaxlogin($_POST['comid'],\"您已经登陆了，您不是个人用户！\");\t\t\techo \"您已经登录了！\";die;\t\t}\t\tif($_POST['path']!=\"index\")\t\t{\t\t\tif(strstr($this->config[\"code_web\"],'前台登陆'))\t\t\t{\t\t\t\tif(md5($_POST[\"authcode\"])!=$_SESSION[\"authcode\"])\t\t\t\t{\t\t\t\t\t$this->ajaxlogin($_POST['comid'],\"验证码错误!\");\t\t\t\t\techo \"验证码错误!\";die;\t\t\t\t}\t\t\t}\t\t}\n省略一点\n$time = time();\t\t\t\t\t\t\t\t\t\t\t\t\t$ip = $this->obj->fun_ip_get();\t\t\t\t\t\t\t$this->obj->DB_update_all(\"member\",\"`login_ip`='$ip',`login_date`='$time',`login_hits`=`login_hits`+1\",\"`uid`='\".$user['uid'].\"'\");\t\t\t\t\t\t\t$this->unset_cookie();\t\t\t\t\t\t\t$this->add_cookie($user['uid'],$user['username'],$user['salt'],$user['email'],$user['password'],$_POST['usertype']);\n然后在这里$this->obj->fun_ip_get(); 再次调用了这函数,进入DB_update_all\nfunction DB_update_all($tablename, $value, $where = 1){    \t$SQL = \"UPDATE `\" . $this->def . $tablename . \"` SET $value WHERE $where\"; \t\t$this->db->query(\"set sql_mode=''\");\t\t$return=$this->db->query($SQL);\t\treturn $return;\t}\n这函数里没有转义 所以可以直接来注入了。而且由于可控的是在set位 所以我们可以想update 哪个column 就update哪个column。这里我们update一下email.再来看一下360webscan。 \nforeach($_GET as $key=>$value) {      webscan_StopAttack($key,$value,$getfilter,\"GET\");    }  }  if ($webscan_post) {    foreach($_POST as $key=>$value) {      webscan_StopAttack($key,$value,$postfilter,\"POST\");    }  }  if ($webscan_cookie) {    foreach($_COOKIE as $key=>$value) {      webscan_StopAttack($key,$value,$cookiefilter,\"COOKIE\");    }  }  if ($webscan_referre) {    foreach($webscan_referer as $key=>$value) {      webscan_StopAttack($key,$value,$postfilter,\"REFERRER\");    }  }}\n检测了get post cookie  server里面只检测了referer所以 xff的话 不用管360。   漏洞证明：  \n\n然后注销账户 重新登录一次。\n\n   修复方案：  检测是否合法。   版权声明：转载请注明来源 ′雨。@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：高 漏洞Rank：10  确认时间：2014-07-17 15:59 厂商回复： 感谢您的支持，我们会及时发布更新补丁！ 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n     2014-07-17 16:13 |    \t\t′  雨。 \t\t\t( 普通白帽子  |\t\t\t        Rank:1231 漏洞数:190        | Only Code Never Lie To Me.)\t\t \n   - - 厂商真速度。      \n     2014-07-17 16:16 |    \t\t′  雨。 \t\t\t( 普通白帽子  |\t\t\t        Rank:1231 漏洞数:190        | Only Code Never Lie To Me.)\t\t \n  就不能让我再首页上多待一会吗?    \n     2014-07-17 16:20 |    \t\t小川  \t\t\t( 核心白帽子 |\t\t\t        Rank:1344 漏洞数:216        | 一个致力要将乌云变成搞笑论坛的男人)\t\t \n  雨神V5    \n     2014-09-03 15:21 |    \t\tPower \t\t\t( 实习白帽子  |\t\t\t        Rank:54 漏洞数:22        | 还需要等待.........)\t\t \n  霸气    \n  \n\n\n", "wybug_level_fromcorp": "高", "wybug_rank_fromcorp": 10, "Ranks": null}