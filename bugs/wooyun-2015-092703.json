{"id": 40001, "wybug_id": "wooyun-2015-092703", "wybug_title": "LebiShop商城系统最新版SQL注入一(同一文件多处)", "wybug_corp": "www.lebi.cn", "wybug_author": "xfkxfk", "wybug_date": "2015-01-23 11:18", "wybug_open_date": "2015-04-23 11:20", "wybug_type": "SQL注射漏洞", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["第三方不可信程序", "安全意识不足", "源码审核"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2015-01-23：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2015-01-26：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2015-01-29：\t细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2015-03-22：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2015-04-01：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2015-04-11：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2015-04-23：\t细节向公众公开  简要描述： LebiShop商城系统最新版SQL注入一，同一文件多处，官方demo演示 详细说明：  LebiShop商城系统最新版V3.1.00，多处存在SQL注入漏洞，可拖库更多案例：使用关键字搜索：powered by LebiShop可搜索大量使用用户反编译/bin/shop.dll，在SHop.Ajax中的Ajax_order文件中存在多处SQL注入漏洞\n\nSHop.Ajax.Ajax_order即根目录下的Ajax目录，Ajax_order文件第一处SQL注入我们来看看Ajax_order文件中的Address_Del方法：\n// Shop.Ajax.Ajax_orderpublic void Address_Del(){\tstring id = RequestTool.RequestString(\"id\");\tif (id == \"\")\t{\t\tbase.Response.Write(\"{\\\"msg\\\":\\\"\" + base.Tag(\"请选择要删除的信息\") + \"\\\"}\");\t\treturn;\t}\tB_Lebi_User_Address.Delete(string.Concat(new object[]\t{\t\t\"User_id = \",\t\tthis.CurrentUser.id,\t\t\" and id in(\",\t\tid,\t\t\")\"\t}));\tif (B_Lebi_User_Address.GetModel(string.Concat(new object[]\t{\t\t\"User_id = \",\t\tthis.CurrentUser.id,\t\t\" and id = \",\t\tthis.CurrentUser.User_Address_id\t})) == null)\t{\t\tLebi_User_Address models = B_Lebi_User_Address.GetModel(\"User_id = \" + this.CurrentUser.id);\t\tif (models != null)\t\t{\t\t\tthis.CurrentUser.User_Address_id = B_Lebi_User_Address.GetMaxId(\"User_id=\" + this.CurrentUser.id);\t\t}\t\tB_Lebi_User.Update(this.CurrentUser);\t}\tbase.Response.Write(\"{\\\"msg\\\":\\\"OK\\\"}\");}\n参数通过RequestTool.RequestString获取，跟进RequestTool.RequestString方法\n// Shop.Tools.RequestToolpublic static string RequestString(string nKey, string def){\tstring ojb = HttpContext.Current.Request.QueryString[nKey];\tif (ojb != null)\t{\t\treturn StringTool.InjectFiltrate(ojb.Trim());\t}\tojb = HttpContext.Current.Request.Form[nKey];\tif (ojb != null)\t{\t\treturn StringTool.InjectFiltrate(ojb.Trim());\t}\treturn def;}\nid参数又通过StringTool.InjectFiltrate过滤处理：\n// Shop.Tools.StringToolpublic static string InjectFiltrate(string str){\tif (!StringTool.IsSafeSqlString(str))\t{\t\tstr = str.Replace(\"'\", \"&#180;\");\t}\treturn str;}\n这里的过滤只是转义了单引号再回到我们的Address_Del方法中id通过处理后，进入了B_Lebi_User_Address.Delete方法中而且这里的id进入了in条件中，没有使用单引号保护，继续跟进B_Lebi_User_Address.Delete方法\npublic void Delete(string strWhere)\t{\t\tif (strWhere.IndexOf(\"}\") > 0)\t\t{\t\t\tSQLPara para = new SQLPara(strWhere, \"\", \"\");\t\t\tthis.Delete(para);\t\t}\t\tStringBuilder strSql = new StringBuilder();\t\tstrSql.Append(\"delete from [Lebi_User_Address] \");\t\tstrSql.Append(\" where \" + strWhere);\t\tSqlUtils.SqlUtilsInstance.TextExecuteNonQuery(strSql.ToString());\t}\n可以看到这里的条件strWhere也没有加处理，直接进入了delete sql语句中，导致注入第二处SQL注入order_save方法：\n// Shop.Ajax.Ajax_orderpublic void order_save(){\tif (this.CurrentUserLevel.BuyRight != 1)\t{\t\tbase.Response.Write(\"{\\\"msg\\\":\\\"\" + base.Tag(\"您所在的分组不允许下单\") + \"\\\"}\");\t\treturn;\t}\tint pay_id = RequestTool.RequestInt(\"pay_id\", 0);\tint onlinepay_id = RequestTool.RequestInt(\"onlinepay_id\", 0);\tdecimal Money_UserCut = RequestTool.RequestDecimal(\"Money_UserCut\", 0m);\tint usermoneytype = RequestTool.RequestInt(\"usermoneytype\", 0);\tstring Pay_Password = RequestTool.RequestString(\"Pay_Password\");......string pay2 = RequestTool.RequestString(\"pay312\");\t\tif (pay2 != \"\")\t\t{\t\t\tList<Lebi_Card> cs = B_Lebi_Card.GetList(string.Concat(new object[]\t\t\t{\t\t\t\t\"User_id=\",\t\t\t\tthis.CurrentUser.id,\t\t\t\t\" and id in (\",\t\t\t\tpay2,\t\t\t\t\")\"\t\t\t}), \"id asc\");\t\t\tint flag = cs.FirstOrDefault<Lebi_Card>().IsCanOtherUse;\t\t\tif (flag == 0 && cs.Count > 1)\t\t\t{\t\t\t\tbase.Response.Write(\"{\\\"msg\\\":\\\"\" + base.Tag(\"代金券异常\") + \"\\\"}\");\t\t\t\treturn;\t\t\t}\t\t\tforeach (Lebi_Card c in cs)\t\t\t{\t\t\t\tif (flag != c.IsCanOtherUse)\t\t\t\t{\t\t\t\t\tbase.Response.Write(\"{\\\"msg\\\":\\\"\" + base.Tag(\"代金券异常\") + \"\\\"}\");\t\t\t\t\treturn;\t\t\t\t}\t\t\t\tif (!Basket.CheckCard(basket, c))\t\t\t\t{\t\t\t\t\tbase.Response.Write(\"{\\\"msg\\\":\\\"\" + base.Tag(\"代金券异常\") + \"\\\"}\");\t\t\t\t\treturn;\t\t\t\t}\t\t\t}\t\t}\n可以看到这里的pay2通过RequestTool.RequestString获取然后没有加单引号保护，进入了in条件语句最后进入了Getlist函数，跟进：\npublic List<Lebi_Card> GetList(string strWhere, string strFieldOrder)\t{\t\tif (strWhere.IndexOf(\"}\") > 0)\t\t{\t\t\tSQLPara para = new SQLPara(strWhere, strFieldOrder, \"\");\t\t\treturn this.GetList(para);\t\t}\t\tStringBuilder strSql = new StringBuilder();\t\tstrSql.Append(\"select * \");\t\tstrSql.Append(\" FROM [Lebi_Card] \");\t\tif (strWhere.Trim() != \"\")\t\t{\t\t\tstrSql.Append(\" where \" + strWhere);\t\t}\t\tif (strFieldOrder.Trim() != \"\")\t\t{\t\t\tstrSql.Append(\" order by \" + strFieldOrder);\t\t}\t\tList<Lebi_Card> list = new List<Lebi_Card>();\t\tusing (IDataReader dataReader = SqlUtils.SqlUtilsInstance.TextExecuteReader(strSql.ToString()))\t\t{\t\t\twhile (dataReader.Read())\t\t\t{\t\t\t\tlist.Add(this.ReaderBind(dataReader));\t\t\t}\t\t}\t\treturn list;\t}\n在GetList函数中，strWhere也没有进行处理，至今进入了select sql语句，导致sql注入产生第三处SQL注入torder_save方法：\n// Shop.Ajax.Ajax_orderpublic void torder_save(){\tint order_id = RequestTool.RequestInt(\"order_id\", 0);\tstring opid = RequestTool.RequestString(\"opid\");\tif (opid == \"\")\t{\t\tbase.Response.Write(\"{\\\"msg\\\":\\\"\" + base.Tag(\"未选择任何商品\") + \"\\\"}\");\t\treturn;\t}\tint count = 0;\tLebi_Order order = B_Lebi_Order.GetModel(order_id);\tif (order == null)\t{\t\tbase.Response.Write(\"{\\\"msg\\\":\\\"\" + base.Tag(\"参数错误\") + \"\\\"}\");\t\treturn;\t}\tif (order.User_id != this.CurrentUser.id)\t{\t\tbase.Response.Write(\"{\\\"msg\\\":\\\"\" + base.Tag(\"参数错误\") + \"\\\"}\");\t\treturn;\t}\tList<Lebi_Order_Product> ops = B_Lebi_Order_Product.GetList(\"id in (\" + opid + \")\", \"\");\n同样opid通过RequestTool.RequestString获取然后opid进入了GetList函数，并且在in条件中，没有引号包含进入GetList函数后，直接带入查询语句select中，没有处理，导致sql注入   漏洞证明：  以第一处sql注入为例官方demo演示\n\n\n\n使用SQLmap即可跑出数据   修复方案：  RequestTool.RequestInt(\"id\")或者进入sql语句时使用单引号保护   版权声明：转载请注明来源 xfkxfk@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：高 漏洞Rank：20  确认时间：2015-01-26 11:45 厂商回复： 漏洞已修复，感谢 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n     2015-01-24 00:44 |    \t\tManning \t\t\t( 普通白帽子  |\t\t\t        Rank:559 漏洞数:78        | 就恨自己服务器太少)\t\t \n  搞上.net了！    \n  \n\n\n", "wybug_level_fromcorp": "高", "wybug_rank_fromcorp": 20, "Ranks": null}