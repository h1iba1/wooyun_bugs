{"id": 59584, "wybug_id": "wooyun-2013-046843", "wybug_title": "PHPSHE SQL注入1（登录绕过）", "wybug_corp": "phpshe.com", "wybug_author": "xfkxfk", "wybug_date": "2013-12-24 10:22", "wybug_open_date": "2014-03-21 10:23", "wybug_type": "SQL注射漏洞", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "漏洞已经通知厂商但是厂商忽略漏洞", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["逻辑错误", "源码审核", "注射漏洞利用技巧", "源码分析", "白盒测试", "后台验证绕过"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2013-12-24：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2013-12-29：\t厂商主动忽略漏洞，细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2014-02-22：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2014-03-04：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2014-03-14：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2014-03-21：\t细节向公众公开  简要描述： PHPSHE SQL注入，导致任意用户登录，包括管理员。 详细说明：  /module/index/user.php第13行，判断登录时用户输入的用户名密码。\n//#####################@ 用户登录 @#####################//\tcase 'login':\t\tif (isset($_p_pesubmit)) {\t\t\t$_p_info['user_pw'] = md5($_p_info['user_pw']);\t\t\tif ($info = $db->pe_select('user', pe_dbhold($_p_info))) {//问题在这里，当这里的条件返回为true，则进入下面操作，登陆成功\t\t\t\t$db->pe_update('user', array('user_id'=>$info['user_id']), array('user_ltime'=>time()));\t\t\t\t$_SESSION['user_idtoken'] = md5($info['user_id'].$pe['host_root']);\t\t\t\t$_SESSION['user_id'] = $info['user_id'];\t\t\t\t$_SESSION['user_name'] = $info['user_name'];\t\t\t\t//未登录时的购物车列表入库                                ...........                                pe_success('用户登录成功！', $_g_fromto);\n这里判断，如果然会的$info部位空，即查询结果返回不为空就登录成功了。进入pe_dbhold函数，在/include/function/global.func.php文件31行：\n//数据库安全function pe_dbhold($str, $exc=array()){\tif (is_array($str)) {\t\tforeach($str as $k => $v) {\t\t\t$str[$k] = in_array($k, $exc) ? pe_dbhold($v, 'all') : pe_dbhold($v);\t\t}\t}\telse {\t\t$str = $exc == 'all' ? mysql_real_escape_string($str) : mysql_real_escape_string(htmlspecialchars($str));\t}\treturn $str;}\n这里对我们输入的内容进行了转义。继续看pe_select函数，在/include/class/db.class.php文件135行：\npublic function pe_select($table, $where = '', $field = '*')\t{\t\t//处理条件语句\t\t$sqlwhere = $this->_dowhere($where);\t\treturn $this->sql_select(\"select {$field} from `\".dbpre.\"{$table}` {$sqlwhere} limit 1\");\t}//处理条件语句\tprotected function _dowhere($where)\t{\t\tif (is_array($where)) {\t\t\tforeach ($where as $k => $v) {\t\t\t\tif (is_array($v)) {\t\t\t\t\t$where_arr[] = \"`{$k}` in('\".implode(\"','\", $v).\"')\";\t\t\t\t\t\t\t}\t\t\t\telse {\t\t\t\t\tin_array($k, array('order by', 'group by')) ? ($sqlby = \" {$k} {$v}\") : ($where_arr[] = \"`{$k}` = '{$v}'\");\t\t\t\t}\t\t\t}\t\t\t$sqlwhere = is_array($where_arr) ? 'where '.implode($where_arr, ' and ').$sqlby : $sqlby;\t\t}\t\telse {\t\t\t$where && $sqlwhere = (stripos(trim($where), 'order by') === 0 or stripos(trim($where), 'group by') === 0) ? \"{$where}\" : \"where 1 {$where}\";\t\t}\t\treturn $sqlwhere;\t}\n这里对我们输入的内容进行了处理，因为输入的是键值对，对键值$k用反引号`括起来了，然后带入sql语句进行查询。问题就出在这个里的反引号。因为在pe_dbhold函数中，对用户输入的内容进行转义，但是这里的转义是不会转义反引号的，而且这里的$k，也就是键值，我们是可控的，所以我们的反引号是可以带入sql语句的。次漏洞，在后台管理员登录时同样存在，具体利用见漏洞证明。   漏洞证明：  1、正常的用户登录输入内容，及数据库执行语句如下图：\n\n这里的$k就是post_data里面的user_name字段，再进入sql语句时，加上了反引号。再来看看我们构造的输入，及数据库执行语句如下图：\n\n没有被过滤，成功带入数据库执行。而这条语句在数据库中执行的返回为非空，正好符合user.php中的判断，成功登陆了。\n\n2、目前通杀。那官方的经典案例演示一下：\n\n找到后台：\n\n随便输入一个用户名密码，然后抓包，修改数据：\n\n从返回的数据，及跳转的地址可以看出，已经登陆成功了。\n\n3、后台登陆绕过利用方法在前台会员登录时，抓包，修改如下：\n\n在后台登陆管理员时，抓包，修改如下：\n\n 本来这里是admin_name，但是admin_name带入数据库查询返回为空，修改为admin_id返回为非空，成功绕过登陆后台。   修复方案：  过滤。修改逻辑。   版权声明：转载请注明来源 xfkxfk@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：无影响厂商忽略 忽略时间：2014-03-21 10:23 厂商回复：  最新状态： 2014-05-19：感谢@xfkxfk 提供代码审计，sql注入漏洞已修复！  ", "replys": "漏洞评价：\n评论\n  \n\n\n", "wybug_level_fromcorp": "无影响厂商忽略", "wybug_rank_fromcorp": 0, "Ranks": null}