{"id": 84229, "wybug_id": "wooyun-2015-0145450", "wybug_title": "瑞星驱动protreg.sys存在一处DOS漏洞", "wybug_corp": "RiSing", "wybug_author": "iometer", "wybug_date": "2015-10-14 12:30", "wybug_open_date": "2016-01-12 15:48", "wybug_type": "拒绝服务", "wybug_level": "低", "wybug_rank_0": "4", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["浏览器安全", "驱动"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2015-10-14：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2015-10-14：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2015-10-17：\t细节向第三方安全合作伙伴开放（绿盟科技、唐朝安全巡航）\t\t\t\t\t\t\t\t\t2015-12-08：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2015-12-18：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2015-12-28：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2016-01-12：\t细节向公众公开  简要描述： 瑞星浏览器保护驱动protreg.sys,在Vista之后的系统上存在一处拒绝服务BUG，会导致系统BSOD. 详细说明：  瑞星浏览器保护驱动protreg.sys, 在NtBuildNumber>=6000的系统上会注册一个注册表回调，在该回调例程中对于注册表表根键的NtFlushKey的操作会触发一个   漏洞证明：  通过设置HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\DisallowRun下任意一个Value，其Name和Data的大小在0x400B, Data的大小大于0x220，就可以覆盖一处指针，该指针会被ExFree掉。\nPCWSTR szKey_DisallowRun = L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\Explorer\\\\DisallowRun\";void __stdcall CMCALLBACK_BSOD_ROUTINE(PCWSTR KeyNameBuf){\tSIZE_T         KeyNameLength; \tUNICODE_STRING KeyName; \tULONG          ResultLength = 0; \tULONG          i = 0; // [sp+10h] [bp-844h]@1\tPKEY_FULL_INFORMATION FullKeyInfo = NULL; \tNTSTATUS Status = STATUS_UNSUCCESSFUL; \tWCHAR    ValueNameBuf[256] = {0}; // [esp+1Ch] [ebp-838h] \tWCHAR    ValueDataBuf[256] = {0}; // [esp+21Ch] [ebp-638h] \tOBJECT_ATTRIBUTES obja = {0}; // [esp+420h] [ebp-434h]\tPKEY_VALUE_FULL_INFORMATION FullValueInfo = NULL; // [esp+438h]\tchar           Unused[512] = {0}; \tUNICODE_STRING ValueName; \tULONG          ValueNumbers = 0; \tHANDLE         KeyHandle; \tULONG          Index = 0; \tWCHAR          NameBuf[256] = {0}; \tKeyNameLength = wcslen(KeyNameBuf);\tif ( KeyNameLength + wcslen(szKey_DisallowRun) + 1 <= 0x100 )\t{\t\twcscpy(NameBuf, KeyNameBuf);\t\twcscat(NameBuf, szKey_DisallowRun);\t\tRtlInitUnicodeString(&KeyName, NameBuf);\t\tInitializeObjectAttributes(&obja, &KeyName, OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE, NULL, NULL);\t\t\t\tStatus = ZwOpenKey(&KeyHandle, 0xF003Fu, &obja);\t\tif ( NT_SUCCESS(Status) )\t\t{\t\t\tStatus = ZwQueryKey(KeyHandle, KeyFullInformation, 0, 0, &ResultLength);\t\t\tif ( Status == STATUS_BUFFER_OVERFLOW || Status == STATUS_BUFFER_TOO_SMALL )\t\t\t{\t\t\t\tFullKeyInfo = (PKEY_FULL_INFORMATION)ExAllocatePool(NonPagedPool, ResultLength);\t\t\t\tif ( FullKeyInfo )\t\t\t\t{\t\t\t\t\tStatus = ZwQueryKey(KeyHandle, KeyFullInformation, FullKeyInfo, ResultLength, &ResultLength);\t\t\t\t\tif ( NT_SUCCESS(Status) )\t\t\t\t\t{\t\t\t\t\t\tValueNumbers = FullKeyInfo->Values;\t\t\t\t\t\tFullValueInfo = ExAllocatePool(NonPagedPool, 0x418);\t\t\t\t\t\tif ( FullValueInfo )\t\t\t\t\t\t{\t\t\t\t\t\t\tfor ( Index = 0; Index < ValueNumbers; ++Index )\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\tStatus = ZwEnumerateValueKey(\t\t\t\t\t\t\t\tKeyHandle,\t\t\t\t\t\t\t\tIndex,\t\t\t\t\t\t\t\tKeyValueFullInformation,\t\t\t\t\t\t\t\tFullValueInfo,\t\t\t\t\t\t\t\t0x418u,\t\t\t\t\t\t\t\t&ResultLength);\t\t\t\t\t\t\t\tif ( NT_SUCCESS(Status) )\t\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\t\tmemset(ValueNameBuf, 0, 0x200);\t\t\t\t\t\t\t\t\tmemset(ValueDataBuf, 0, 0x200);\t\t\t\t\t\t\t\t\tmemcpy(ValueNameBuf, FullValueInfo->Name, FullValueInfo->NameLength);\t\t\t\t\t\t\t\t\tmemcpy(ValueDataBuf, (PCH)FullValueInfo + FullValueInfo->DataOffset, FullValueInfo->DataLength);//Buffer over flow\t\t\t\t\t\t\t\t\tfor ( i = 0; ProcessNameList2[i]; ++i )\t\t\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\t\t\tif ( !wcsicmp(ProcessNameList2[i], ValueDataBuf) )\t\t\t\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\t\t\t\tRtlInitUnicodeString(&ValueName, ValueNameBuf);\t\t\t\t\t\t\t\t\t\t\tStatus = ZwDeleteValueKey(KeyHandle, &ValueName);\t\t\t\t\t\t\t\t\t\t\tif ( Status >= 0 )\t\t\t\t\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\t\t\t\t\t--Index;\t\t\t\t\t\t\t\t\t\t\t\t--ValueNumbers;\t\t\t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t}\t\t\t\t\t\t\tZwClose(KeyHandle);\t\t\t\t\t\t\tExFreePoolWithTag(FullKeyInfo, 0);\t\t\t\t\t\t\tExFreePoolWithTag(FullValueInfo, 0);//BSOD\t\t\t\t\t\t}\t\t\t\t\t\telse\t\t\t\t\t\t{\t\t\t\t\t\t\tStatus = STATUS_INSUFFICIENT_RESOURCES;\t\t\t\t\t\t\tZwClose(KeyHandle);\t\t\t\t\t\t\tExFreePoolWithTag(FullKeyInfo, 0);\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t\telse\t\t\t\t\t{\t\t\t\t\t\tZwClose(KeyHandle);\t\t\t\t\t\tExFreePoolWithTag(FullKeyInfo, 0);\t\t\t\t\t}\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\tStatus = STATUS_INSUFFICIENT_RESOURCES;\t\t\t\t\tZwClose(KeyHandle);\t\t\t\t}\t\t\t}\t\t}\t}}\n   修复方案：  严格把控缓冲区的大小，不要随意执行内存复制操作.   版权声明：转载请注明来源 iometer@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：低 漏洞Rank：1  确认时间：2015-10-14 15:51 厂商回复： 3Q 最新状态： 暂无  ", "replys": "漏洞评价：\n评价\n  \n\n\n", "wybug_level_fromcorp": "低", "wybug_rank_fromcorp": 1, "Ranks": null}