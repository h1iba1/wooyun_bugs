{"id": 43560, "wybug_id": "wooyun-2014-082383", "wybug_title": "kppw任意文件上传-1", "wybug_corp": "kppw", "wybug_author": "路人甲", "wybug_date": "2014-11-07 16:31", "wybug_open_date": "2015-02-05 16:32", "wybug_type": "文件上传导致任意代码执行", "wybug_level": "中", "wybug_rank_0": "10", "wybug_status": "未联系到厂商或者厂商积极忽略", "wybug_from": "http://www.wooyun.org", "wybug_tags": "", "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-11-07：\t积极联系厂商并且等待厂商认领中，细节不对外公开\t\t\t\t\t\t\t\t\t2015-02-05：\t厂商已经主动忽略漏洞，细节向公众公开  简要描述： KPPW是客客团队主打的开源威客系统，同类开源建站产品的领跑者，搭建无物流电子商务在线服务交易平台的首选系统。2014年6月新版KPPW2.5发布了，新版借助客客团队近4年来威客行业的开源产品和商业项目的成熟经验，对前端功能进行了深入改进。KPPW从产品规划、UI设计、程序开发多个环节进行了优化，在未做框架重构情况下对程序进行更优秀的改进。 详细说明：  在control/ajax/upload.php中：\n$pathDir = setUploadPath($fileType, $objType);$upload = new keke_upload_class(S_ROOT.$pathDir ,$fileFormat,$maxSize);$savename = $upload->run( $filename , 1);\n再来看run方法：\nfunction run($fileInput, $randName = 1) {\t\tif (isset ( $_FILES [$fileInput] )) {\t\t\t$fileArr = $_FILES [$fileInput];\t\t\tif (is_array ( $fileArr ['name'] )) { \t\t\t\t....\t\t\t}\t\t\telse { \t\t\t\t$this->getExt ( $fileArr ['name'] ); \t\t\t\t$this->setSavename (); \t\t\t\tif ($this->copyfile ( $fileArr, $randName )) { \t\t\t\t\t$this->returnArray [] = $this->returninfo;\t\t\t\t} else {\t\t\t\t\t$this->returninfo ['error'] = $this->errmsg ();\t\t\t\t\t$this->returnArray [] = $this->returninfo;\t\t\t\t}\t\t\t\treturn $this->errno ? $this->errmsg () : $this->returnArray;\t\t\t}\t\t\treturn false;\t\t}\n在这段方法中，先是获取了$this->getExt ( $fileArr ['name'] ); 文件后缀，这里没有什么问题，然后再生成上传后的随机名+后缀. 最后执行上传操作copyfile\nfunction copyfile($fileArray, $randName) {\t\t$this->returninfo = array ();\t\t$this->returninfo ['name'] = $fileArray ['name'];\t\tif ($randName) {\t\t\t$this->returninfo ['saveName'] = $this->saveName;\t\t} else {\t\t\t$this->saveName = $this->returninfo ['saveName'] = $fileArray ['name'];\t\t}\t\t$this->returninfo ['size'] = $fileArray ['size']; \t\t$this->returninfo ['type'] = $fileArray ['type'];\t\tif (! $this->validateFormat ()) {\t\t\t$this->errno = 11;\t\t\treturn false;\t\t}\t\tif(!$this->fileFilter($fileArray [\"tmp_name\"],$this->ext)){\t\t\t$this->errno = 21;\t\t\treturn false;\t\t}\t\tif ($this->savePathFunc) {\t\t\t$savePathFunc = $this->savePathFunc;\t\t\t$this->savePath = $savePathFunc ( $this->saveName );\t\t\t$this->returninfo ['path'] = $this->savePath;\t\t}\t\t$this->makeDirectory ( $this->savePath );\t\tif (! @is_writable ( $this->savePath )) {\t\t\t@mkdir ( $this->savePath, 0777, true );\t\t}\t\tif ($this->overwrite == 0 && @file_exists ( $this->savePath . $this->saveName )) {\t\t\t$this->errno = 13;\t\t\treturn false;\t\t}\t\tif ($this->maxSize != 0) {\t\t\tif ($fileArray [\"size\"] > $this->maxSize) {\t\t\t\t$this->errno = 14;\t\t\t\treturn false;\t\t\t}\t\t}\t\tif (! @copy ( $fileArray [\"tmp_name\"], $this->savePath . $this->saveName )) {\t\t\t$this->errno = $fileArray [\"error\"];\t\t\treturn false;\t\t}\t}\n这里先做了$this->validateFormat (),根据文件名来获取后缀，再判断后缀是否合法：\nfunction validateFormat() {\t\tif (! is_array ( $this->fileFormat ) || in_array ( strtolower ( $this->ext ), $this->fileFormat ) || in_array ( strtolower ( $this->returninfo ['type'] ), $this->fileFormat ))\t\t\treturn true;\t\telse\t\t\treturn false;\t}\n关键看这个条件：in_array ( strtolower ( $this->returninfo ['type'] ), $this->fileFormat ),这里判断type是否合法而且用了或操作，等于这边为true了，整个if条件就为true了，  而这个type我们可以改动的，只要抓包把Content-Disposition: form-data; name=\"name\"; filename=\"1.php\"Content-Type: 中的Content-Type设置成我们想要的值就可以绕过了。绕过了这个地方以为后面就一帆风顺了，但是还是上传不上去，继续看下面的一个操作$this->fileFilter($fileArray [\"tmp_name\"],$this->ext）这个操作实际上是根据文件头来确定文件的后缀，再检测后缀与之前的文件名获取的后缀是否一致。 这本来是一个很好的过滤方法，但开发人员又写错了：\nfunction fileFilter($path,$ext){\t\tif(keke_file_class::get_file_type($path,$this->ext)==$ext){\t\t\treturn true;\t\t}else{\t\t\treturn false;\t\t}\t}static function get_file_type($file_path, $ext = '') {\t\t$fp = fopen ( $file_path, 'r' );\t\t$bin = fread ( $fp, 2 );\t\tfclose ( $fp );\t\t$strInfo = @unpack ( \"C2chars\", $bin );\t\t$typeCode = intval ( $strInfo ['chars1'] . $strInfo ['chars2'] );\t\t$fileType = 'unknown';\t\t$typeCode == '3780' && $fileType = \"pdf\";\t\t$typeCode == '6787' && $fileType = \"swf\";\t\t$typeCode == '7784' && $fileType = \"midi\";\t\t$typeCode == '7790' && $fileType = \"exe\";\t\t$ext == 'txt' && $fileType = \"txt\";\t\tin_array ( $typeCode, array ('8297', '8075' ) ) && $fileType = $ext; \t\tif (in_array ( $typeCode, array ('255216', '7173', '6677', '13780' ) )) { \t\t\tin_array ( $ext, array ('jpg', 'gif', 'bmp', 'png', 'jpeg' ) ) and $fileType = $ext or $fileType = 'jpg';\t\t}\t\tif ($typeCode == '208207') { \t\t\tin_array ( $ext, array ('wps', 'ppt', 'dot', 'xls', 'doc', 'docx' ) ) and $fileType = $ext or $fileType = 'doc';\t\t}\t\treturn $fileType;\t}\n关键看这个操作：in_array ( $typeCode, array ('8297', '8075' ) ) && $fileType = $ext; 如果typecode 等于8297或者8075的时候，就会将filetype赋值为$ext,这样不就是饶过了之前的那个if判断。POC:  只需要将content-type 设置成jpg  再在上传的文件开头写上Ra 就可以成功绕过上传过滤。 （Ra 获取以后的code值就是8297）\n\n\n\n\n\n   漏洞证明：  \n\n\n\n\n\n   修复方案：     版权声明：转载请注明来源 路人甲@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 未能联系到厂商或者厂商积极拒绝  ", "replys": "漏洞评价：\n评论\n  \n\n\n", "wybug_level_fromcorp": "无影响厂商忽略", "wybug_rank_fromcorp": 0, "Ranks": null}