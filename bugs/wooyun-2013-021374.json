{"id": 11655, "wybug_id": "wooyun-2013-021374", "wybug_title": "ROYCMS漏洞完结篇，身份伪造，直入管理后台！", "wybug_corp": "roycms.cn", "wybug_author": "wefgod", "wybug_date": "2013-04-08 10:34", "wybug_open_date": "2013-07-07 10:34", "wybug_type": "设计缺陷/逻辑错误", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["第三方不可信程序", "设计缺陷", "设计不当导致攻击界面扩大", "认证设计不合理", "逻辑错误", "源码审核", "源码分析", "安全", "白盒测试", "欺骗"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2013-04-08：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2013-04-10：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2013-04-13：\t细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2013-06-04：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2013-06-14：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2013-06-24：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2013-07-07：\t细节向公众公开  简要描述： 发现厂商连上次的SQL注入都不愿意去修改，感觉完全不重视安全方面的问题，所以就发到这了……这次也会附上分析，可以直接伪造身份进后台！然后getshell什么的就不用多解释了 http://www.wooyun.org/bugs/wooyun-2013-020667 详细说明：  先关注下一些后台相关的页面。比如createDB.aspx这个页面，看看后端的代码（就是cs文件）：\npublic partial class createDB : ROYcms.AdminPage\n很明显可以看出，都是继承了父类AdminPage的，再转到AdminPage.cs围观下部分主要代码：\nprotected override void OnPreInit(EventArgs e){       base.OnPreInit(e);       ROYcms.Config.SessionData.SessionKey = \"administrator\";       if (!ROYcms.Config.SessionData.IsLogin())        {           Response.Redirect(string.Format(\"~/administrator/login.aspx?Page={0}\", Request.Path));        }         ……}\n在这个初始化的方法中我们可以看见他为SessionKey赋值administrator，接着关注下IsLogin()这个方法的主要代码：\npublic static bool IsLogin(){       bool ret = false;       if (ROYcms.Common.Session.Get(SessionKey) != null || ROYcms.Common.cooks.GetCookie(SessionKey) != null) //问题所在        {            if (ROYcms.Common.cooks.GetCookie(SessionKey) == null)//如果该cookie为空……            {                    ROYcms.Common.cooks.SaveCookie(SessionKey, ROYcms.Common.Session.Get(SessionKey), 2);             }\t\t\t//如果cookie中的SessionKey不为空的情况下，分配cookie！             else { ROYcms.Common.Session.Add(SessionKey, ROYcms.Common.cooks.GetCookie(SessionKey)); }             ret = true;}return ret;}\n可能看代码有点乱，简单分析下，最开始用了一个或条件来判断，第一个条件是session中保存有sessionkey的值就可以继续执行下面的代码，第二个条件是cookie中的sessionkey不为空。看看上面我们提到的给sessionkey赋值为什么？ROYcms.Config.SessionData.SessionKey = \"administrator\";简单说，我们虽然无法控制服务器端的session是否为空，但是我们可以控制我们本地提交的cookie是否包含有这个字段！接着看：if (ROYcms.Common.cooks.GetCookie(SessionKey) == null)如果cookie中的administrator字段为空……则执行下面的分配cookie到本地的操作。但是如果这个值不为空呢？执行下面的else分配session：else { ROYcms.Common.Session.Add(SessionKey, ROYcms.Common.cooks.GetCookie(SessionKey)); }也就是说，当cookie中的administrator字段不为空的时候，无论该字段是什么值，服务器都会为你分配一个session！自动的把你当成已经登录的管理员了！上面的代码我们也可以看见，基本上就是两点：1.\t判断session是否为空，不判断session某个键对应的值；2.\t判断cookie中的指定字段是否为空，不判断该字段内容是否是伪造的、是否是合法的。为了验证我们的想法，再看login.aspx.cs中的protected void AdminLogin_Click方法的一点代码：ROYcms.Common.cooks.SaveCookie(\"administrator\", username.Text.Trim(), 2);看见这段代码就知道，服务器分配给客户端的cookie，也基本只是包含这部分自定义的字段（当然肯定也会有sessionid，那个不用明文写出来）。   漏洞证明：  这下明白了？在访问比如刚才的createDB.aspx，提交某cookie（自行构造不解释啊，已经明说了“cookie中的administrator字段啊”！），会报错：\n\n其实可以不用理会，因为当“某字段不为空”的时候，他还会重新给我们cookie赋值一次的，然后访问后台的index.aspx：\n\n   修复方案：  相关的权限用session在服务器端判断，而不是过分的依靠cookie去判断。其实有一个sessionid就可以了啊！干嘛在客户端那搞那么多东西啊   版权声明：转载请注明来源 wefgod@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：高 漏洞Rank：20  确认时间：2013-04-10 16:24 厂商回复： ------ 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n  \n\n\n", "wybug_level_fromcorp": "高", "wybug_rank_fromcorp": 20, "Ranks": null}