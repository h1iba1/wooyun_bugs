{"id": 43657, "wybug_id": "wooyun-2014-082108", "wybug_title": "WeiPHP微信开发框架SQL注入漏洞", "wybug_corp": "WeiPHP", "wybug_author": "L.N.", "wybug_date": "2014-11-07 12:33", "wybug_open_date": "2015-02-05 12:34", "wybug_type": "设计错误/逻辑缺陷", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "未联系到厂商或者厂商积极忽略", "wybug_from": "http://www.wooyun.org", "wybug_tags": "", "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-11-07：\t积极联系厂商并且等待厂商认领中，细节不对外公开\t\t\t\t\t\t\t\t\t2015-02-05：\t厂商已经主动忽略漏洞，细节向公众公开  简要描述： 程序简介:     weiphp是一个开源，高效，简洁的微信开发平台，它是基于oneThink这个简单而强大的内容管理框架实现的。旨在帮助开发者快速实现微信公众账号的个性化功能。开源产品WeiPHP下载量10万多，被众多开发者安装使用。危害简介：     无任何限制，通杀sql注入。 详细说明：  一个漏洞个人认为需要两个必要因数:1.数据，你所能控制的数据（直接控制、间接控制）。2.方法，使用到数据的方法（此处的数据是你能控制的数据）。下面我们找我们能控制的数据：\\Application\\Home\\Controller\\WeixinController.class.php\npublic function index() {\t\t// 删除微信传递的token干扰\t\tunset ( $_REQUEST ['token'] );\t\t$weixin = D ( 'Weixin' );\t\t// 获取数据\t\t$data = $weixin->getData ();//此处有数据传入，我们具体看下它传入的方式               //var_dump($data);exit;\t\t$this->data = $data;\t\tif (! empty ( $data ['ToUserName'] )) {\t\t\tget_token ( $data ['ToUserName'] );\t\t}\t\tif (! empty ( $data ['FromUserName'] )) {\t\t\tsession ( 'openid', $data ['FromUserName'] );\t\t}\t\t\t\t$this->token = $data ['ToUserName'];//赋值给了token\t\t\t\t$this->initFollow ( $weixin );\t\t\t\t// 记录日志\t\taddWeixinLog ( $data, $GLOBALS ['HTTP_RAW_POST_DATA'] );\t\t\t\t// 回复数据\t\t$this->reply ( $data, $weixin );\t\t\t\t// 结束程序。防止oneThink框架的调试信息输出\t\texit ();\t}\n\\Application\\Home\\Model\\WeixinModel.class.php\npublic function __construct() {\t\tif ($_REQUEST ['doNotInit'])\t\t\treturn true;\t\t\t$content = file_get_contents ( 'php://input' );//相当霸气的数据传入\t\t! empty ( $content ) || die ( '这是微信请求的接口地址，直接在浏览器里无效' );\t\t$data = new \\SimpleXMLElement ( $content );//xml解析                $data || die ( '参数获取失败' );\t\tforeach ( $data as $key => $value ) {//数据赋值\t\t\t$this->data [$key] = strval ( $value );\t\t}\t}\t/* 获取微信平台请求的信息 */\tpublic function getData() {\t\treturn $this->data;\t}\n有了可控制的数据，然后我们寻找数据进入过的方法（数据在流动的过程中，会赋值，会被处理而改变，过程繁复复杂，动态调试是一个让我们不至于被程序绕晕的好方法），最后我动态调试，找到了一个利用点：通过第一段代码，我们知道我们的数据有被赋值给this->token:\\Application\\Home\\Controller\\WeixinController.class.php\nprivate function reply($data, $weixin) {\t\t$key = $data ['Content'];\t\t$keywordArr = array ();\t\t\t\t````````                代码省略                                ````````\t\tif (! empty ( $forbit_addon )) {\t\t\t$like ['addon'] = array (\t\t\t\t\t'not in',\t\t\t\t\t$forbit_addon \t\t\t);\t\t}\t\t$like ['token'] = array (\t\t\t\t'exp',\t\t\t\t\"='0' or token='{$this->token}'\" //此处被赋值给$like\t\t);\t\tif (! isset ( $addons [$key] )) {\t\t\t$like ['keyword'] = $key;\t\t\t$like ['keyword_type'] = 0;\t\t\t$keywordArr = M ( 'keyword' )->where ( $like )->order ( 'id desc' )->find ();//$like被加入数据库中查询\t\t\t\t\t\tif (! empty ( $keywordArr ['addon'] )) {\t\t\t\t$addons [$key] = $keywordArr ['addon'];\t\t\t\t$this->request_count ( $keywordArr );\t\t\t}\t\t}\t\t````````                代码省略                                ````````\t\t}\t}\n最后经过层层数据库的处理最后query\\ThinkPHP\\Library\\Think\\Model.class.php此时的\n$str=\"SELECT * FROM `wp_keyword` WHERE (  (`token` ='0' or token='222'')  ) AND ( `keyword` = '33333' ) AND ( `keyword_type` = 0 ) ORDER BY id desc LIMIT 1  \"public function query($str) {        if(0===stripos($str, 'call')){ // 存储过程查询支持            $this->close();            $this->connected    =   false;        }        $this->initConnect(false);        if ( !$this->_linkID ) return false;        $this->queryStr = $str;        //释放前次的查询结果        if ( $this->queryID ) {    $this->free();    }        N('db_query',1);        // 记录开始执行时间        G('queryStartTime');        $this->queryID = mysql_query($str, $this->_linkID);//注入进去了        $this->debug();        if ( false === $this->queryID ) {            $this->error();            return false;        } else {            $this->numRows = mysql_num_rows($this->queryID);            return $this->getAll();        }    }\n通过上面分析，我们可以看出我们有两个参数可控，一个是token，一个是keyword，对应的数据传入的变量ToUserName和Content------------------------------------------------------通过上面的分析，其实我们挖一般sql注入有个非常好的方法是：记录所有的mysql_error()-->写个工具fuzz数据输入点-->查看错误日志反向寻找注入   漏洞证明：  构造poc:\n<?xml version=\"1.0\" encoding=\"utf-8\"?><xml><ToUserName>请看测试代码</ToUserName><FromUserName>111</FromUserName></xml>\n\n\n\n\n   修复方案：  输入过滤。   版权声明：转载请注明来源 L.N.@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 未能联系到厂商或者厂商积极拒绝  ", "replys": "漏洞评价：\n评论\n     2015-05-02 21:25 |    \t\t动后河 \t\t\t( 实习白帽子  |\t\t\t        Rank:51 漏洞数:13        | ☭)\t\t \n  洞主，6wb敬上！    \n  \n\n\n", "wybug_level_fromcorp": "无影响厂商忽略", "wybug_rank_fromcorp": 0, "Ranks": null}