{"id": 49972, "wybug_id": "wooyun-2014-079425", "wybug_title": "大米CMS一处sql注入", "wybug_corp": "damicms.com", "wybug_author": "SLAckEr", "wybug_date": "2014-10-19 23:23", "wybug_open_date": "2015-01-17 23:24", "wybug_type": "SQL注射漏洞", "wybug_level": "中", "wybug_rank_0": "10", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["数字类型注射", "源码审核"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-10-19：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2014-10-19：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2014-10-22：\t细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2014-12-13：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2014-12-23：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2015-01-02：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2015-01-17：\t细节向公众公开  简要描述： Rt 详细说明：  上次提交了一次，原因没说明白，，看了半天搞清楚了\\Web\\Lib\\Action\\MemberAction.class.php文件中 147-163行\nfunction modpage(){self::is_login();$aid = intval($_REQUEST['aid']);\tif($_POST){$_POST['status'] =0;\t$_POST['title'] = htmlspecialchars($_POST['title']);M('article')->where('dami_uid='.$_SESSION['dami_uid'].' and aid='.$aid)->save($_POST);\t$this->assign('jumpUrl',U('Member/tougaolist'));$this->success('修改成功~,请等待审核!');}else{$info = M('article')->where('dami_uid='.$_SESSION['dami_uid'].' and aid='.$aid)->find();if(!$info){$this->error('记录不存在');exit();}self::pub_class($info['typeid']);$this->assign('info',$info);}$this->display();}\n可以看到aid这个参数aid被intval了可是在我测试的时候，却发现aid这个参数是可以注入的。再往上看。开头\nclass MemberAction extends BaseAction{function _initialize() {R('Public','head');$member_menu = S('member_menu');if(!is_array($member_menu)){$member_menu = M('member_menu')->where('is_show=1')->order('drand')->select();S('member_menu',$member_menu);\t}$this->assign('member_menu',$member_menu);}\n看下R这个函数/Core/Common/functions.php\nfunction R($module, $action, $app='@') {    $class = A($module, $app);    if ($class)        return call_user_func(array(&$class, $action));    else        return false;}\n再来看看A/Core/Common/functions.php \nfunction A($name, $app='@') {    static $_action = array();    if (isset($_action[$app . $name]))        return $_action[$app . $name];    $OriClassName = $name;    if (strpos($name, '.')) {        $array = explode('.', $name);        $name = array_pop($array);        $className = $name . 'Action';        import($app . '.Action.' . implode('.', $array) . '.' . $className);    } else {        $className = $name . 'Action';        import($app . '.Action.' . $className);    }    if (class_exists($className)) {        $action = new $className();        $_action[$app . $OriClassName] = $action;        return $action;    } else {        return false;    }}\n意思就是调用一个远程模块。而回头看\\Web\\Lib\\Action\\MemberAction.class.phpR('Public','head');结合函数A 和 R也就是调用了PublicAction前台公共action，里面的head函数。我们再来看下head函数/Web/Lib/Action/PublicAction.class.php\npublic function head()    {\t//读取数据库和缓存\t\t$type = M('type');\t\t$article = M('article');\t\t$config = F('basic','','./Web/Conf/');\t\t\t//封装网站配置\t\t$this->assign('config',$config);\t\t\t//滚动公告\t\t$data['status'] = 1;\t\t$data['typeid'] = $config['noticeid']; \t\t$roll=$article->where($data)->field('aid,title')->order('addtime desc')->limit($config['rollnum'])->select();\t\t//处理标题:防止标题过长撑乱页面\t\tforeach ($roll as $k=>$v)\t\t{\t\t\t$roll[$k]['title'] = msubstr($v['title'],0,20,'utf-8');\t\t}\t\t$this->assign('roll',$roll);\t\t\t//网站导航\t\t$menu = $type->where('ismenu=1')->order('drank asc')->select();\t\tforeach( $menu as $k=>$v)\t\t{\t\t\t$menuson[$k] = $type->where('fid='.$v['typeid'].' AND drank <> 0')->order('drank asc')->select();\t\t\t$menu[$k]['submenu'] = $menuson[$k];\t\t}\t\t$this->assign('menuson',$menuson);\t\t$this->assign('menu',$menu);\t\t\t//位置导航\t\t$nav = '<a href=\"'.$config['siteurl'].'\">首页</a>';\t\tif(isset($_GET['aid']))\t\t{\t\t\t$typeid = $article->where('aid='.$_GET['aid'])->getField('typeid');\t\t}\t\telse\t\t{\t\t\t$typeid = intval($_GET['typeid']);\t\t}\t\t$typename = $type->where('typeid='.$typeid)->getField('typename');\t\t$path = $type->where('typeid='.$typeid)->getField('path');\t\t$typelist = explode('-',$path);\t\t//拼装导航栏字符串\t\tforeach($typelist as $v)\t\t{\t\t\tif($v==0) continue;\t\t\t$s = $type->where('typeid='.$v)->getField('typename');\t\t\t$nav.=\"&nbsp;&gt;&nbsp;<a href=\\\"\".U('lists/'.$v).\"\\\">{$s}</a>\";\t\t}\t\t$nav.=\"&nbsp;&gt;&nbsp;<a href=\\\"\".U('lists/'.$typeid).\"\\\">{$typename}</a>\";\t\t$this->assign('nav',$nav);\t//释放内存\t\tunset($type,$article);\t\t$this->assign('head',TMPL_PATH.cookie('think_template').'/head.html');\t\t$this->assign('footer',TMPL_PATH.cookie('think_template').'/footer.html');    }\n看这里\n//位置导航\t\t$nav = '<a href=\"'.$config['siteurl'].'\">首页</a>';\t\tif(isset($_GET['aid']))\t\t{\t\t\t$typeid = $article->where('aid='.$_GET['aid'])->getField('typeid');\t\t}\n这个aid没有经过过滤直接就带入到了sql中。getField函数。/Core/Lib/Think/Core/Model.class.php\npublic function getField($field,$condition='',$sepa=' ') {        if(empty($condition) && isset($this->options['where']))            $condition   =  $this->options['where'];        $options['where'] =  $condition;        $options['field']    =  $field;        $options =  $this->_parseOptions($options);        if(strpos($field,',')) { // 多字段            $resultSet = $this->db->select($options);            if(!empty($resultSet)) {                $field  =   explode(',',$field);                $key =  array_shift($field);                $cols   =   array();                foreach ($resultSet as $result){                    $name   = $result[$key];                    $cols[$name] =  '';                    foreach ($field as $val)                        $cols[$name] .=  $result[$val].$sepa;                    $cols[$name]  = substr($cols[$name],0,-strlen($sepa));                }                return $cols;            }        }else{   // 查找一条记录            $options['limit'] = 1;            $result = $this->db->select($options);            if(!empty($result)) {                return reset($result[0]);            }        }        return null;    }\n获取一条记录的某个字段值所以，总结一下。在我们注册一个用户之后发布一个投稿，然后修改他\n\n\n\n这个分类，就是保存在数据库中的，上面说的所有内容，就是通过文章修改这个函数获得aid参数，然后用aid这个参数从type中查找类型，显示出来。而查找这个过程的aid却没经过过滤，导致了注入的产生。\n\nSELECT * FROM `dami_article` WHERE dami_uid=6 and aid=129日志里，下面的这个，就是在修改文章这个函数中的aid是经过Intval的而上面的这个105 Query\tSELECT `typeid` FROM `dami_article` WHERE aid=129 LIMIT 1105 Query\tSELECT `typename` FROM `dami_type` WHERE typeid=14 LIMIT 1通过get传进来的aid函数，从article表中查找出typeid，然后再从type表中根据typeid来查找类型的名字（typeid）。http://127.0.0.1/dami/index.php?m=member&a=modpage&aid=129 and 1=2所以一个完整的sql操作就是这样的108 Query\tSELECT `typeid` FROM `dami_article` WHERE aid=129 and 1=2 LIMIT 1108 Query\tSELECT `typename` FROM `dami_type` WHERE typeid= LIMIT 1108 Query\tSELECT `path` FROM `dami_type` WHERE typeid= LIMIT 1108 Query\tSELECT * FROM `dami_article` WHERE dami_uid=6 and aid=129 LIMIT 1108 Query\tSELECT typeid,typename,fid,concat(path,'-',typeid) as bpath FROM `dami_type` WHERE islink=0 and isuser=1 ORDER BY bpath108 Query\tSELECT * FROM `dami_flash` WHERE status=1 ORDER BY rank asc108 Query\tSELECT * FROM `dami_link` WHERE islogo=1 and status=1 ORDER BY rank asc LIMIT 8108 Quit\t\n\n   漏洞证明：  见上面   修复方案：  在前台公共类(文件)/Web/Lib/Action/PublicAction.class.php把传入的参数intval一下。   版权声明：转载请注明来源 SLAckEr@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：低 漏洞Rank：5  确认时间：2014-10-19 23:38 厂商回复： 可能导致数据泄露，但无法直接操作数据，还是很感谢作者的细心发现 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n  \n\n\n", "wybug_level_fromcorp": "低", "wybug_rank_fromcorp": 5, "Ranks": null}