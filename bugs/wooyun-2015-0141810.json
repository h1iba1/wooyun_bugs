{"id": 84788, "wybug_id": "wooyun-2015-0141810", "wybug_title": "cnm_jpu 驱动多个拒绝服务漏洞可造成内核崩溃", "wybug_corp": "华为技术有限公司", "wybug_author": "jiayy", "wybug_date": "2015-10-13 12:20", "wybug_open_date": "2016-01-14 09:36", "wybug_type": "拒绝服务", "wybug_level": "低", "wybug_rank_0": "3", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["驱动"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2015-10-13：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2015-10-16：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2015-10-19：\t细节向第三方安全合作伙伴开放（绿盟科技、唐朝安全巡航）\t\t\t\t\t\t\t\t\t2015-12-10：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2015-12-20：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2015-12-30：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2016-01-14：\t细节向公众公开  简要描述： 华为多款手机（如p8青春版，荣耀x2）使用了jpu驱动（/dev/cnm_jpu）,该驱动在最新版本的实现里存在漏洞，system或者camera权限的恶意程序可以通过该驱动触发内核崩溃 详细说明：  测试平台： 华为P8 青春版shell@hwALE-H:/ $ getprop ro.product.modelgetprop ro.product.modelALE-UL00shell@hwALE-H:/ $ getprop ro.build.display.idgetprop ro.build.display.idALE-UL00 V100R001C00B131驱动设备 ：crw-rw---- system   camera   241,   0 2015-09-17 09:22 cnm_jpu内核源码下载地址： http://**.**.**.**/cn/plugin.php?id=hwdownload&mod=detail&mid=144出问题的文件：kernel/drivers/vcodec/jpu/v8_jpu/jpu.ckernel/drivers/vcodec/jpu/v8_jpu/jmm.hkernel/drivers/vcodec/jpu/v3_jpu/jmm.hkernel/drivers/vcodec/jpu/v3_jpu/jpu.c问题代码：jpu_ioctl 函数在处理  cmd = JDI_IOCTL_RESERVED_MEMORY_ALLOC 时有多处错误， 比如， jmem_init 函数内部，没有检测VMEM_P_ALLOC 返回值是否为 null 就直接操作会造成崩溃。比如，ERROR_RESERVED_MEMORY_ALLOC:            if (0 != ret)            {                jmem_exit(&s_jmem);                if (!IS_ERR((void *)s_jpeg_memory.base) && (s_jpeg_memory.base != 0))                {                    ion_unmap_kernel(s_ion_client, s_ion_handle);                    memset(&s_jpeg_memory, 0x00, sizeof(jpudrv_buffer_t));                }这段代码里， 调用 ion_unmap_kernel 时， 变量s_ion_client, s_ion_handle没有检测是否为null,如果为null , 则程序会崩溃在 ion_unmap_kernel 函数里。而事实上，这两个变量在这里是有可能为空的   漏洞证明：  用测试代码在运行 /dev/cnm_gpu 的手机上，用 system或者camera或者root权限运行，100% 奔溃   修复方案：  这里只给出 jmem_init 函数的修复方案\nintjmem_init(\tjpu_mm_t* mm,\tunsigned long addr,    unsigned long size    ){    int i;    if (NULL == mm)        return -1;    mm->base_addr  = (addr+(JMEM_PAGE_SIZE-1))&~(JMEM_PAGE_SIZE-1);    mm->mem_size   = size&~JMEM_PAGE_SIZE;    mm->num_pages  = mm->mem_size/JMEM_PAGE_SIZE;    mm->page_list  = (page_t*)VMEM_P_ALLOC(mm->num_pages*sizeof(page_t));    mm->free_tree  = NULL;    mm->alloc_tree = NULL;    mm->free_page_count = mm->num_pages;    mm->alloc_page_count = 0;    for (i=0; i<mm->num_pages; i++) {        mm->page_list[i].pageno       = i;        mm->page_list[i].addr         = mm->base_addr + i*JMEM_PAGE_SIZE;        mm->page_list[i].alloc_pages  = 0;        mm->page_list[i].used         = 0;        mm->page_list[i].first_pageno = -1;    }    set_blocks_free(mm, 0, mm->num_pages);    return 0;}\n改成\nintjmem_init(\tjpu_mm_t* mm,\tunsigned long addr,    unsigned long size    ){    int i;    if (NULL == mm)        return -1;    mm->base_addr  = (addr+(JMEM_PAGE_SIZE-1))&~(JMEM_PAGE_SIZE-1);    mm->mem_size   = size&~JMEM_PAGE_SIZE;    mm->num_pages  = mm->mem_size/JMEM_PAGE_SIZE;    mm->page_list  = (page_t*)VMEM_P_ALLOC(mm->num_pages*sizeof(page_t));    mm->free_tree  = NULL;    mm->alloc_tree = NULL;    mm->free_page_count = mm->num_pages;    mm->alloc_page_count = 0;    if(mm->page_list==NULL) return -1;    for (i=0; i<mm->num_pages; i++) {        mm->page_list[i].pageno       = i;        mm->page_list[i].addr         = mm->base_addr + i*JMEM_PAGE_SIZE;        mm->page_list[i].alloc_pages  = 0;        mm->page_list[i].used         = 0;        mm->page_list[i].first_pageno = -1;    }    set_blocks_free(mm, 0, mm->num_pages);    return 0;}\n   版权声明：转载请注明来源 jiayy@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：中 漏洞Rank：5  确认时间：2015-10-16 09:35 厂商回复： 感谢jiayy对华为公司安全的关注，我们已经将该漏洞通知了业务部门。 最新状态： 2015-12-17：目前该漏洞已发布了相关安全预警和修复补丁。再次感谢各位白帽子对华为公司安全的关注。  ", "replys": "漏洞评价：\n评价\n  \n\n\n", "wybug_level_fromcorp": "中", "wybug_rank_fromcorp": 5, "Ranks": null}