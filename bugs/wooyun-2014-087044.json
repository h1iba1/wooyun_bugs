{"id": 42011, "wybug_id": "wooyun-2014-087044", "wybug_title": "ThinkPHP一处XSS漏洞（需要特定环境触发）", "wybug_corp": "ThinkPHP", "wybug_author": "黑匣子", "wybug_date": "2014-12-15 18:27", "wybug_open_date": "2015-03-15 18:28", "wybug_type": "xss跨站脚本攻击", "wybug_level": "中", "wybug_rank_0": "10", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["持久型", "存储型", "第三方不可信程序", "源码审核"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-12-15：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2014-12-16：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2014-12-19：\t细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2015-02-09：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2015-02-19：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2015-03-01：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2015-03-15：\t细节向公众公开  简要描述： 一处XSS，在特定的环境下甚至触发SQL注入，该学代码审计，如果认为该漏洞无影响，直接忽略即可！ 详细说明：  代码出现在I方法中关于I的方法，我就不多介绍了，具体可以参考官方手册，下面贴出部分关键代码文件位置:/ThinkPHP/Common/functions.php\nfunction I($name,$default='',$filter=null,$datas=null) {    if(strpos($name,'.')) { // 指定参数来源        list($method,$name) =   explode('.',$name,2);    }else{ // 默认为自动判断        $method =   'param';    }    switch(strtolower($method)) {        case 'get'     :   $input =& $_GET;break;        case 'post'    :   $input =& $_POST;break;        case 'put'     :   parse_str(file_get_contents('php://input'), $input);break;        case 'param'   :            switch($_SERVER['REQUEST_METHOD']) {                case 'POST':                    $input  =  $_POST;                    break;                case 'PUT':                    parse_str(file_get_contents('php://input'), $input);                    break;                default:                    $input  =  $_GET;            }            break;        case 'path'    :               $input  =   array();            if(!empty($_SERVER['PATH_INFO'])){                $depr   =   C('URL_PATHINFO_DEPR');                $input  =   explode($depr,trim($_SERVER['PATH_INFO'],$depr));                        }            break;        case 'request' :   $input =& $_REQUEST;   break;        case 'session' :   $input =& $_SESSION;   break;        case 'cookie'  :   $input =& $_COOKIE;    break;        case 'server'  :   $input =& $_SERVER;    break;        case 'globals' :   $input =& $GLOBALS;    break;        case 'data'    :   $input =& $datas;      break;        default:            return NULL;    }    if(''==$name) { // 获取全部变量        $data       =   $input;        array_walk_recursive($data,'filter_exp');        $filters    =   isset($filter)?$filter:C('DEFAULT_FILTER');  //默认会用htmlspecialchars过滤        if($filters) {            if(is_string($filters)){                $filters    =   explode(',',$filters);            }            foreach($filters as $filter){                $data   =   array_map_recursive($filter,$data); // 参数过滤            }        }    }elseif(isset($input[$name])) { // 取值操作        $data       =   $input[$name];        is_array($data) && array_walk_recursive($data,'filter_exp');        $filters    =   isset($filter)?$filter:C('DEFAULT_FILTER');        if($filters) {            if(is_string($filters)){                $filters    =   explode(',',$filters);            }elseif(is_int($filters)){                $filters    =   array($filters);            }                        foreach($filters as $filter){                if(function_exists($filter)) {                \t//进入这里如果是数组会有TP自己的回调函数对数据进行处理，如果不是会直接用htmlspecialchars过滤                    $data   =   is_array($data)?array_map_recursive($filter,$data):$filter($data); // 参数过滤                }else{                    $data   =   filter_var($data,is_int($filter)?$filter:filter_id($filter));                    if(false === $data) {                        return   isset($default)?$default:NULL;                    }                }            }        }    }else{ // 变量默认值        $data       =    isset($default)?$default:NULL;    }    return $data;}\n关键就看对数据处理的这句//这里如果是数组会有TP自己的函数对数据进行处理，如果不是会直接用htmlspecialchars过滤$data=is_array($data)?array_map_recursive($filter,$data):$filter($data); 代码跟进看下array_map_recursiv这个函数是怎么对数据进行处理的\nfunction array_map_recursive($filter, $data) {     $result = array();     foreach ($data as $key => $val) {         $result[$key] = is_array($val)             ? array_map_recursive($filter, $val)             : call_user_func($filter, $val);     }     return $result; }\n以上的代码作用是递归过滤数组的值，并没有对索引进行处理,到这里应该明白了吧，所以只要是I方法获取的post、get、cookie...等，只要是数组，都可以造成XSS，特定的环境甚至触发sql注入   漏洞证明：  cookie测试\n\npost测试\n\n\n\n其他的就不测试了，同一个函数封装的，肯定都存在问题   修复方案：  过滤   版权声明：转载请注明来源 黑匣子@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：低 漏洞Rank：3  确认时间：2014-12-16 18:12 厂商回复： I函数只是用于获取数据，显示在页面的数据和I函数没有直接关联。用户在页面输出的时候需要尽可能的做好xss过滤。 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n  \n\n\n", "wybug_level_fromcorp": "低", "wybug_rank_fromcorp": 3, "Ranks": null}