{"id": 3733, "wybug_id": "wooyun-2014-053198", "wybug_title": "cmseasy绕过补丁SQL注入一枚", "wybug_corp": "cmseasy", "wybug_author": "′雨。", "wybug_date": "2014-03-09 20:40", "wybug_open_date": "2014-06-07 20:41", "wybug_type": "SQL注射漏洞", "wybug_level": "中", "wybug_rank_0": "20", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": "", "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-03-09：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2014-03-09：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2014-03-12：\t细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2014-05-03：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2014-05-13：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2014-05-23：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2014-06-07：\t细节向公众公开  简要描述： 继续注入。 详细说明：  在lib\\plugins\\pay\\alipay.php中。 上次提了这个文件的洞。 看了看官网发的补丁。 \nforeach($_POST as $key =>$data) {\t\t\t\tif(preg_match('/(=|<|>)/', $data)){                    return false;                }\n 就是过滤了几个运算符。    但是因为语句是 where xxx。 一般的注入的话 需要where id=xxx 来注入 但是这里过滤了这些。 没想出什么办法突破。但是在这文件 还有一个函数。\n$payment  = pay::get_payment($_GET['code']);        $seller_email = rawurldecode($_GET['seller_email']);        $order_sn = str_replace($_GET['subject'],'',$_GET['out_trade_no']);        $order_sn = trim($order_sn);        if (!pay::check_money($order_sn,$_GET['total_fee'])) {            return false;        }\t\t        if($_GET['trade_status'] == \"WAIT_SELLER_SEND_GOODS\"||$_GET['trade_status'] == \"TRADE_FINISHED\" || $_GET['trade_status'] == \"TRADE_SUCCESS\") {            pay::changeorders($order_sn,$_GET);            return true;        }else {            return false;        }\n上次是看的changeorders  现在 反正我是没办法利用了。那现在来看看check_money\npublic static function check_money($id,$money) {\t                $where=array();        $where['id']=$id;\t\t        $orders=orders::getInstance()->getrow($where);        $archive=archive::getInstance()->getrow($orders['aid']);                $prices = getPrices($archive['attr2']);        $archive['attr2'] = $prices['price'];\n可以看到是把order_sn 带入了getrow; 再继续\nfunction getrow($condition,$order='1 desc',$cols='*') {\t        $this->condition($condition);\t\t\t\t        return $this->rec_select_one($condition,'*',$order);\n\nfunction sql_select($tbname,$where=\"\",$limit=0,$fields=\"*\",$order='') {        $sql=\"SELECT \".$fields.\" FROM `\".$tbname.\"` \".($where ?\" WHERE \".$where : \"\").\" ORDER BY \".$order.($limit ?\" limit \".$limit : \"\");        //echo $sql.\"<br>\";        return $sql;\n这里来把语句输出一下看看。SELECT * FROM `cmseasy_p_orders` WHERE `id`='123aaaa' 被单引号了。 但是又全局转义 怎么办呢?看        $order_sn = str_replace($_GET['subject'],'',$_GET['out_trade_no']);        $order_sn = trim($order_sn);这里跟ecshop 那个洞挺像。在这里 有一个replace 是xx把清空 但是这个xxx是我们可控的。总所周知 %00 转义后会变成\\0 然后%00' 就是\\0\\'这里 如果我们把0清空 的话 就成了\\\\'  单引号成功出来。测试测试。   漏洞证明：  \n\n执行的语句有点多。。 直接全部输出来了。是成功的哦。   修复方案：  继续过滤。这次别忽略了。。   版权声明：转载请注明来源 ′雨。@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：高 漏洞Rank：20  确认时间：2014-03-09 20:43 厂商回复： 感谢，马上更新 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n     2014-03-16 12:08 |    \t\tskysheep \t\t\t( 路人 |\t\t\t        Rank:0 漏洞数:1        | 关注网络安全。)\t\t \n  哇哇哇哇哇。这个好。    \n  \n\n\n", "wybug_level_fromcorp": "高", "wybug_rank_fromcorp": 20, "Ranks": null}